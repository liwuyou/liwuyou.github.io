[{"title":"无聊的盒子制作","path":"/2024/06/23/无聊的盒子制作/","content":"前言一开始想把这个当成一个开源项目来做，然后发现想要超越网上现有的开源项目，还是需要费一番功夫，至少不是花一两天就能完成的。目前的项目其实还不是很完善，甚至部分打印件需要用小刀进行修正，遂本次制作仅自娱自乐，作为自己的练习项目。文件仓库如下 https://github.com/liwuyou/box.git arduino代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 无聊的盒子//使用mg90s舵机#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象int close_pos = 110; // 该变量用与存储舵机能够关闭钮子开关的角度int home_pos = 20; // 回正角度int pin_on = 2;void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制 myservo.write(home_pos); pinMode(pin_on,INPUT_PULLUP); randomSeed(analogRead(0));//随机数种子&#125; void case_1()&#123; // 快进快出 myservo.write(close_pos); delay(300); myservo.write(home_pos); delay(300); &#125;void case_2()&#123; //中速 delay(500); myservo.write(close_pos); delay(500); myservo.write(home_pos); delay(1000); &#125;void case_3()&#123; //低速 delay(500); myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(1000); &#125;void case_4()&#123; //疲惫 int pos; for(pos = home_pos; pos&lt;=close_pos-20; pos+=1) &#123; myservo.write(pos); delay(30); &#125; myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(500);&#125;void case_5()&#123; //生气 int pos; for(pos = home_pos; pos&lt;=close_pos-20; pos+=1) &#123; myservo.write(pos); delay(10); &#125; for(pos = close_pos-20; pos&gt;=home_pos+30; pos-=1) &#123; myservo.write(pos); delay(10); &#125; myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(500);&#125;void loop() &#123; int randNumber = random(5); if(digitalRead(2)==0)&#123; switch(randNumber)&#123; case 0:case_1();break; case 1:case_2();break; case 2:case_3();break; case 3:case_4();break; case 4:case_5();break; &#125; &#125;&#125;","tags":["arduino"]},{"title":"台式电脑组装DIY指南","path":"/2024/05/23/台式电脑组装DIY指南/","content":"前言该篇主要针对台式电脑一些基础知识的扫盲工作。 电脑基础硬件 快速链接CPU天梯图 https://topic.expreview.com/CPU/ 显卡天梯图 https://topic.expreview.com/GPU/ 其他1、内存条套条牌子不一样没事，蓝条，绿条，黑条也没事。但是频率要一样，不一样只能按照低的那个走2、io挡版上，如果你有核显接主板，有独显也尽量接主板，没有核显再接独显3、笔记本和台式机命名稍微有点不一样，比如intel中U是低压，H是高压但是不超频3、显卡前面数字是代数，后面是叠马甲，比如1080就比1650强点（玄学警告04、PCI-e这玩意功能很多，各种网卡、蓝牙等都能差，但是这种东西插的时候插低档次的条，高档次还是留给显卡比较好，PCI-e4虽然很牛逼，但是受到选择不一样结果相趋甚远5、SATA接口并不是区分也有固态，m.2就只有固态了。m.2由于电子原理上导致运行效率高，但是固态硬盘数据丢了几乎恢复不了。机械硬盘的电磁强弱，比较好恢复数据（多备份才是王道）6、SATA不能单独供电。m.2虽然固态硬盘虽然大部分都是这个接口，但是长短有不一样的，也是型号区别，记得甄别7、CPU三级缓存是虚的，你猜它为什么不说1、2级缓存，1、2级大家做的都一样。3级有区别但是意义不大8、内存确实是断电无，但是根据设置不同，可以操作超频，也可以把系统本身装进内存（相信我爽到起飞）9、intel很多系列芯片虽然不能超频但是可以睿频，就是智能忽高忽低。超频需要在BIOS设置，设置好频率和电压的关系，好好考虑散热压不压得住10、南桥芯片组很重要，掌管电脑除了显卡、CPU之外鼠标、键盘等小玩意11、装机有的时候真的要大力出奇迹12、装机版最麻烦的不是上面说的那些，而是理线13、台式机一般不自带蓝牙、WIFI需要自己购买14、不要装xp，xp只能用4G内存15、双通道内存条要错开装，13、24这样16、m.2有的情况和pcie供用带宽，注意看主板说明书17、新手不推荐水冷。风冷血滴子手剧痛18、硅脂是为了填补cpu盖板表面和散热器直接的缝隙，别涂在针脚 上，硅脂一般酷冷至尊效果好点吧，论克卖的，好的硅脂、正确手法真的猛压住了温度19、水冷不是没有风扇，只是导热和循环变成水，但是也不是自来水。同价位风冷好20、风冷水冷都有热管，里面是热胀冷缩，相变冷凝的原理，如果有瑕疵就废了21、风扇内外别装反22、cpu分成盒装和散片，盒装就intel、AMD直接卖给个人消费者分，自带散热器（垃圾玩意，挤铝下压工艺，被动散热效果极差，但是政府机关买的台式机一般都这个）。散片也叫流片，是Intel、amd卖给dell、惠普等OTA厂商后，他们基于某些原因又倒卖的，品质完全一样，只是没有散热器赠送，质保也不一样23、要装机的话选个长螺丝刀，散热器的弹簧螺丝角度很刁钻24、机箱不是必须的，拿鞋盒当机箱也行 CPU主要参数 频率 基频 睿频 超频 核心 架构 缓存 厂家 intel（celeron,pentium,core,xeon） AMD（速龙，线程撕裂者，RYZen） 其他 正式版（盒装，散片） ES版（不显版，正显版QS） 购买需检查CPU上的小电容是否脱落，特别防拆贴在电容上的 intel第一代处理器会省掉1 洋垃圾系类E3,E5 E5E5 2666V3第一位数字表示可同时工作的CPU第二位数字表示主板对应针脚，4为1356针，6为2011针V1,V2 使用x79平台V3,V4 使用X99平台 显卡CPU 线程少，逻辑能力强GPU 线程多，逻辑能力弱 显卡的分类 集成显卡 核心显卡 独立显卡集成显卡是将显卡集成在主板上，使得显卡和主板融为一体，但它会占用系统内存，可能会对电脑性能产生一定影响。 核显则是集成在 CPU 里的图形处理单元，与CPU融为一体，它依托CPU强大的运算能力和智能能效调节设计，进一步加强了图像处理的效率。 厂家 英伟达 AMD 公版卡和非公板卡 常见矿卡 RX580 GTX1660s RX5600XT RX5700XT RTX2080s 性能指标 流处理器数量（画师数量） 处理器架构（画师水平） 频率（画师绘画的速度） 显存频率（运输叉车的速度） 显存带宽（运输叉车每次运多少） 显存容量（仓库大小） 成果E5洋垃圾","tags":["电脑组装DIY"]},{"title":"第二十六届人工智能操作手册，测试版","path":"/2024/05/13/第二十六届人工智能操作手册，测试版/","content":"初始介绍用户名：racecar密码：1 思路通过gmapping算法建图，然后通过打点程序储存需要的导航点，在运行程序过程中，发布导航点，车辆就会达到目标点。 建图将车辆发在起始点，注意标注位置，⽐如说后编码器抵着后挡板 启动底盘，启动电调打开在终端中输入 1python3 ~/car_2024_rengong/src/auto_go/scripts/run_mapping.py 启动建图脚本，会弹出若干个弹窗。 在显示有control的终端进行键盘操作， W为向前⾛，Q为向左⽅⾛，E为向右⽅⾛，s为停止。 建图完成后，请按键盘上的m保存地图，此时会弹出⼀个新的终端，终端运⾏完成即可。 如果建图失败，或建图重叠，键盘控制界面按s停止，关闭所有终端，再次输入脚本。 建图时尽量直行，不要过多拐弯，观察rviz,有完。整图后及时按m保存。 标点标注的点为导航点，第一个点是第一个导航点结束标点时，发布⼀个和终点处箭头坐标⼀样的点即可请按照坐标抵达的先后顺序进⾏标点 1python3 ~/car_2024_rengong/src/auto_go/scripts/run_way_point_click.py 如果需要读取并修改之前保存的点，请填⼊1并回⻋，然后需要在rviz的任意处使⽤rviz的Publish Point功能发布⼀个点后，之前保存的点位才会显示。 然后在rviz中进⾏标点，使⽤2D nav goal 按钮进⾏坐标点的发布，如果需要移动以及发布的坐标点，请使⽤Publish Point对已经存在的点进⾏点击，箭头变红，然后就可以使⽤点 结束标点时，发布⼀个和终点处箭头坐标⼀样的点即可 打点时终点一段路多打几个，方便拟合 发车1python3 ~/car_2024_rengong/src/auto_go/scripts/wj_run.py 所有程序都打开后，在出现go?的终端回车，车辆运行 车辆运行关键：1.正确的地图2.合理的参数 参数调整: 12345678打开~/car_2024_rengong/src/racecar/launch/acml_nav.launch文件该参数及其附近参数能够调整其速度 &lt;param name=&quot;vp_min&quot; value=&quot;160&quot;/&gt; 打开~/car_2024_rengong/src/auto_go/scripts/wj_go_hh.py文件该参数能够调整距离导航点多远时，发布下一个导航点。Distance_min = 1.2"},{"title":"校巡线车校赛决赛代码","path":"/2024/04/19/校巡线车校赛决赛代码/","content":"校赛第二名，净挣1000，当然不妨碍代码是垃圾代码，没啥必要发github,发发博客差不多得了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;Servo.h&gt; #include &lt;MsTimer2.h&gt;Servo myservo; int pos = 70; //舵机中值，对于我的舵机左-&gt;右 40-100int lift = 20;int right = 120;// 舵机PWM引脚9，左电机PWM引脚5,右电机PWM引脚6；int servo = 9; int motor1=5; int motor2=6;int motor1_speed =60; int motor2_speed =60;// 设置对管状态int white = 0;int black = 1;int err,last_err; //pid 参数定义int output;float kp=10,ki=0,kd=0;float P,I,D;// 红外对管左-&gt;右引脚为2,3,4,7,8,12,13int infrared[7]=&#123;2,3,4,7,8,12,13&#125;;//实例特判int zhijiao = 0;int hu = 0;int hu2 = 0;int hu2_flag =0;int final =0;void flash() &#123; final =1;&#125;void setup() &#123; myservo.attach(9); // 该舵机由arduino第九脚控制 myservo.write(pos); //电机pwm引脚初始化，模式设置为输出模式 pinMode(motor1,OUTPUT); pinMode(motor2,OUTPUT); pinMode(10,OUTPUT); Serial.begin(9600);//串口初始化 //红外对管引脚模式设置为输入上拉模式 pinMode(infrared[0],INPUT_PULLUP); pinMode(infrared[1],INPUT_PULLUP); pinMode(infrared[2],INPUT_PULLUP); pinMode(infrared[3],INPUT_PULLUP); pinMode(infrared[4],INPUT_PULLUP); pinMode(infrared[5],INPUT_PULLUP); pinMode(infrared[6],INPUT_PULLUP); //初始速度 analogWrite(motor1,motor1_speed); analogWrite(motor2,motor2_speed);&#125;void loop() &#123; if(zhijiao == 0)&#123; zhijiao = 1; analogWrite(motor2,80); delay(1800); myservo.write(40); analogWrite(motor2,100); delay(1000); &#125; if((hu == 0 &amp;&amp; zhijiao == 1 &amp;&amp; digitalRead(infrared[0])==black &amp;&amp; digitalRead(infrared[3])==black) || (hu == 0 &amp;&amp; zhijiao == 1 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[3])==black))&#123; hu = 1; analogWrite(5,0); analogWrite(6,0); analogWrite(11,100); myservo.write(70); delay(1800); myservo.write(30); analogWrite(11,0); analogWrite(5,100); analogWrite(6,100); delay(1500); &#125; if(final==1 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[2])==black &amp;&amp; digitalRead(infrared[3])==black)&#123; analogWrite(5,0); analogWrite(6,0); delay(5500); &#125; if(hu==1 &amp;&amp; hu2==0 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[2])==black &amp;&amp; digitalRead(infrared[3])==black)&#123; hu2 = 1; analogWrite(5,0); analogWrite(6,0); analogWrite(11,140); myservo.write(90); delay(2000); myservo.write(30); analogWrite(11,0); analogWrite(5,120); analogWrite(6,120); delay(1000); motor1_speed =70;motor2_speed =70; MsTimer2::set(25000, flash); // 5000ms period MsTimer2::start(); &#125; sensor(); int control_turn =pos + pid(); myservo.write(control_turn); if(err == 4)&#123; analogWrite(motor1,motor1_speed+60); &#125; else if(err == -4)&#123; analogWrite(motor2,motor2_speed+60); &#125; else if(err == 2)&#123; analogWrite(motor1,motor1_speed+20); if(hu==1 &amp;&amp; hu2==0)&#123; analogWrite(motor1,motor1_speed+40); &#125; &#125; else if(err == -2)&#123; analogWrite(motor2,motor2_speed+20); if(hu==1 &amp;&amp; hu2==0)&#123; analogWrite(motor2,motor2_speed+40); &#125; &#125; else&#123; analogWrite(motor1,motor1_speed); analogWrite(motor2,motor2_speed); &#125;&#125;int pid()&#123; P = err; I += err; D = err - last_err; output = kp*P + ki*I + kd*D; last_err = err; return output;&#125;void sensor()&#123; int a_1 = digitalRead(infrared[0]); int a_2 = digitalRead(infrared[1]); int a_3 = digitalRead(infrared[2]); int a_4 = digitalRead(infrared[3]); int a_5 = digitalRead(infrared[4]); int a_6 = digitalRead(infrared[5]); int a_7 = digitalRead(infrared[6]); if(a_1==black &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -4; &#125; else if(a_1==white &amp;&amp; a_2==black &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -2; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==black &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -1; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==black &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = 0; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==black &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = 1; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==black &amp;&amp; a_7==white)&#123; err = 2; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==black)&#123; err = 4; &#125; Serial.println(err); //测试代码&#125;"},{"title":"讯飞二代车记录","path":"/2024/03/30/讯飞二代车记录/","content":"开始二代车https://github.com/liwuyou/xunfei_second.git 初始配置官方包编译键盘控制python文件使用，放在ucar_ws&#x2F;src&#x2F;目录下 建图配置1234567891011121314151617181920212223# 启动键盘节点roslaunch ucar_map ucar_gmapping.launch# 键盘控制节点python3 ~/ucar_ws/src/ucar_map/launch/mbot_teleop.py # 保存地图rosrun map_server map_saver -f /home/iflytek/ucar_ws/src/ucar_map/maps/name# name为自己命名的文件``` ## 挂载地图并取得点坐标```python# 发布已建好的地图rosrun map_server map_server /home/iflytek/ucar_ws/src/ucar_map/maps/name# 打开rviz,挂载地图，选择publisher,看左下角，确定x,yrviz# 修改pose文件欧拉角转四元数https://quaternions.online/ 导航123# 启动导航文件roslaunch ucar_nav ucar_navigation_wy.launch# rviz发布目标点，观察小车轨迹是否有异常，修改配置文件 官方局部路径规划不可用， 1234567891011# 安装teb_local_planner路径规划sudo apt-get install ros-noetic-teb-local-planner# 修改ucar_navi.launch文件下局部路径规划为teb_local_planner，在movebase下添加配置文件 &lt;param name=&quot;base_global_planner&quot; value=&quot;global_planner/GlobalPlanner&quot; /&gt; &lt;param name=&quot;planner_frequency&quot; value=&quot;10.0&quot; /&gt; &lt;param name=&quot;planner_patience&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;use_dijkstra&quot; value=&quot;true&quot; /&gt; &lt;param name=&quot;base_local_planner&quot; value=&quot;teb_local_planner/TebLocalPlannerROS&quot; /&gt; &lt;param name=&quot;controller_frequency&quot; value=&quot;30.0&quot; /&gt; &lt;param name=&quot;controller_patience&quot; value=&quot;10.0&quot; /&gt; &lt;param name=&quot;clearing_rotation_allowed&quot; value=&quot;true&quot; /&gt;"},{"title":"讯飞车找板子返回坐标点程序","path":"/2024/03/22/讯飞车找板子返回坐标点程序/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import numpy as npdef rotate_vector(vector, angle): &quot;&quot;&quot; 将向量旋转一定的角度 &quot;&quot;&quot; # 将角度转换为弧度 angle_rad = np.deg2rad(angle) # 构造旋转矩阵 rotation_matrix = np.array([[np.cos(angle_rad), -np.sin(angle_rad)], [np.sin(angle_rad), np.cos(angle_rad)]]) # 使用旋转矩阵对向量进行旋转 rotated_vector = np.dot(rotation_matrix, vector) # 保留三位有效数字 rotated_vector = np.around(rotated_vector, decimals=3) return rotated_vectordef radians_to_vector(theta): &quot;&quot;&quot; 将theta转化为向量 &quot;&quot;&quot; # 计算向量的 x 和 y 分量 x = np.cos(theta)*1 y = np.sin(theta)*1 # 保留三位小数 x = np.around(x, decimals=3) y = np.around(y, decimals=3) return np.array([x, y])def is_angle_less_than_X(x, v1, v2): # 计算向量的点积 dot_product = np.dot(v1, v2) # 计算向量的模长 v1_norm = np.linalg.norm(v1) v2_norm = np.linalg.norm(v2) # 计算夹角的余弦值 cos_angle = dot_product / (v1_norm * v2_norm) # 计算 X 度的余弦值 cos_x_deg = np.cos(np.deg2rad(x)) return cos_angle &gt; cos_x_degdef is_angle_greater_than_90(v1, v2): &quot;&quot;&quot; 判断两向量夹角是否大于90度，大于返回True &quot;&quot;&quot; # 计算向量的点积 dot_product = np.dot(v1, v2) # 如果点积小于 0，则夹角大于 90 度 return dot_product &lt; 0class BoardTrue: &quot;&quot;&quot; 用于判断并筛选出有效的板子 &quot;&quot;&quot; def __init__(self, my_list, car_x, car_y, car_theta, cv_po): self.my_list = my_list self.car_x = np.around(car_x, decimals=3) self.car_y = np.around(car_y, decimals=3) self.car_theta = np.around(car_theta, decimals=3) self.cv_po = np.around(cv_po, decimals=3) def chose_board(self): if len(self.my_list) == 0: return None else: n = len(self.my_list) print(n) for i in range(n): if 0.2 &lt; self.my_list[i][2] &lt; 0.7: x = self.my_list[i][0] - self.car_x y = self.my_list[i][1] - self.car_y v1 = np.array([x, y]) v2 = radians_to_vector(self.car_theta) print(&quot;i为&quot; + str(i)) print(is_angle_less_than_X(70, v1, v2)) if is_angle_less_than_X(70, v1, v2): print(&quot;dfg&quot;) mapped_value = (self.cv_po - (0)) * (70 - (-10)) / (640 - 0) + (-70) v3 = rotate_vector(v2, mapped_value) if is_angle_less_than_X(25, v1, v3): print(&quot;asd&quot;) return self.my_list[i] else: continue else: continue return Noneclass BoardWithCv: &quot;&quot;&quot; 使用此类时，请确保传入的板子是一个且有效,他会返回一个导航点x,y,theta &quot;&quot;&quot; def __init__(self, car_x, car_y, car_theta, board_x, board_y, board_theta): # 实例属性 self.car_x = np.around(car_x, decimals=3) self.car_y = np.around(car_y, decimals=3) self.car_theta = np.around(car_theta, decimals=3) self.board_x = np.around(board_x, decimals=3) self.board_y = np.around(board_y, decimals=3) self.board_theta = np.around(board_theta, decimals=3) def is_board_theta_ture(self): &quot;&quot;&quot; 判断并执行板子的角度是否需要反转,并返回导航点,弧度，是否有效 :return: &quot;&quot;&quot; v1 = np.array([self.board_x - self.car_x, self.board_y - self.car_y]) v2 = radians_to_vector(self.board_theta) if is_angle_greater_than_90(v1, v2): self.board_theta = self.board_theta + 3.141 v2 = radians_to_vector(self.board_theta) goal_x = np.around(self.board_x - 0.3 * v2[0], decimals=3) goal_y = np.around(self.board_y - 0.3 * v2[1], decimals=3) return goal_x, goal_y, self.board_thetaif __name__ == &quot;__main__&quot;: ## 测试代码 # board=[-1,1,0.785] board = [-1.6258577108383179, 1.445590853691101, 0.456392377614975, 0.011698315851390362, 1.518639469495104] # board=[-3,1,3.14-0.785] pos = BoardWithCv(-2, 0, 1.57, board[0], board[1], board[4]) print(pos.is_board_theta_ture()) my_list = [[-1, 1,0.5,0.02, 0.785], [-3, 1,0.5,0.02,3.14-0.785], [-2, 1,0.5,0.02,1.3]] my_list2 =[] my_list3 = [[-1.1039749383926392, -1.6410338878631592, 0.459942102432251, 0.006066703703254461, 2.404021134944642], [-1.0234383344650269, 1.4331644773483276, 0.6236299276351929, 0.0975717082619667, 0.6774194980518585], [-1.6258577108383179, 1.445590853691101, 0.456392377614975, 0.011698315851390362, 1.518639469495104], [-2.016007423400879, 1.6973320245742798, 0.17067547142505646, 0.008529485203325748, 1.4121627729088593], [-2.3203864097595215, 1.3803951740264893, 0.4648244082927704, 0.011016763746738434, 2.12274152271989]] my_list4 = [[-2.2005648612976074, -1.9698346853256226, 0.26301005482673645, 0.02629818394780159, 1.2184761268334674], [-1.6092170476913452, -1.8576725721359253, 0.3533917963504791, 0.029181374236941338, 1.9172304414045462], [-1.0438616275787354, -1.4628329277038574, 0.47950631380081177, 0.013515759259462357, 2.4409537863628334], [-1.6358827352523804, 1.4406025409698486, 1.5764230489730835, 0.26953673362731934, 1.4236640668400438]] my_list5 = [[-2.2020256519317627, -1.9928362369537354, 0.2039794772863388, 0.025548739358782768, 1.1120026801359906], [-1.6541303396224976, -1.898160457611084, 0.3227234482765198, 0.01702151633799076, 1.7969596897315867], [-1.4612840414047241, -1.1711866855621338, 0.4812791049480438, 0.05817915499210358, 2.159874044377892], [-1.0457868576049805, 1.2947330474853516, 0.44938141107559204, 0.009451523423194885, 0.8893285575700086], [-2.283306121826172, 1.518304705619812, 0.4721873700618744, 0.007294466253370047, 2.0108069978910965]] posa = BoardTrue(my_list5, -2, 0, 0.8, 331) print(posa.chose_board())&quot;&quot;&quot;[00:15:08.34] 前往pose_3&#123;u&#x27;spontoon&#x27;: 284.0&#125;targetspontoonfirst_1&#123;u&#x27;spontoon&#x27;: 284.0&#125;boards[[-2.20574951171875, -1.9964897632598877, 0.19374234974384308, 0.0202349741011858, 1.0713866771931375], [-1.6379033327102661, -1.9009284973144531, 0.34384506940841675, 0.010412354953587055, 1.8343551319682068], [-1.4544870853424072, -1.176705002784729, 0.4698032736778259, 0.053842246532440186, 2.147697938715995], [-1.02494215965271, 1.2817209959030151, 0.468691885471344, 0.005473896395415068, 0.8983430915438178], [-2.271810293197632, 1.5118887424468994, 0.46807199716567993, 0.00690682977437973, 2.0043066211443765]][-1.02494215965271, 1.2817209959030151, 0.468691885471344, 0.005473896395415068, 0.8983430915438178]quat=[0, 0, 0.434, 0.901]send the goal&quot;&quot;&quot;"},{"title":"ROS车记录","path":"/2024/03/12/ROS车记录/","content":"基于一代讯飞车的ROS记录 常见命令行123456789# 更改屏幕分辨率xrandr --fb 1600x900更改完后，远程桌面要关闭再打开压缩文件夹zip -r file.zip file 常用launch文件包12roslaunch ucar_controller base_driver.launch启动底盘节点 地图操作地图发布，rviz查看12rosrun map_server map_server 文件名.yamlrosrun rviz rviz 建图，并保存1234# 启动建图launch包# 启动键盘控制，小车运动# 保存地图rosrun map_server map_saver -f &lt;map_file_name&gt;","tags":["ros"]},{"title":"python算法实战","path":"/2024/03/12/python算法实战/","content":"去年报名了蓝桥杯，却一直没有练习，也该开始了，为了300的报名费 时间复杂度O(1),O(n),O($n^{2}$),O($log_{2}n$),O(n!)… 空间复杂度 递归 调用条件 结束自身 实例 12345678910def jiecheng(n): if n != 1: sum = n * jiecheng(n - 1) return sum else: return 1print(jiecheng(5)) 12#结果120 查找 顺序查找 二分查找 顺序查找12345678910def shuxu(list_1, val): for i in range(len(list_1)): if val == list_1[i]: return i else: returnlist_my = list(range(5))print(shuxu(list_my, 3)) 12#结果3 二分查找1234567891011121314def binary_search(my_list, val): # my_list 为list,val为待查找的值 lift = 0 right = len(my_list) - 1 mid = (lift + right) // 2 while lift &lt;= right: if my_list[mid] == val: return mid elif my_list[mid] &gt; val: right = mid - 1 else: lift = mid + 1 else: return None 排序将一组无序序列变为有序序列升序与降序内置排序算法sort() LOW 冒泡排序 选择排序 插入排序 NB 快速排序 堆排序 归并排序 其他 希儿排序 计数排序 基数排序 sort的使用需要注意的是，sort()方法会直接修改原列表，而不是返回一个新的排序后的列表 冒泡排序 列表每相邻的两个数，如果后面比前面大，交换两个数 一次排序，无序区减少一个数，有序区增加一个数 12345678910111213import randomdef bubble_sort(my_list): for i in range(len(my_list)-1): # -1防止内存溢出 for j in range(len(my_list)-1-i): if my_list[j]&gt;my_list[j+1]: my_list[j],my_list[j+1]=my_list[j+1],my_list[j]my_list = [random.randint(0,10000) for i in range(5)]print(my_list)bubble_sort(my_list)print(my_list) 123# 结果[3003, 7653, 1759, 5541, 3176][1759, 3003, 3176, 5541, 7653] range详解range() 函数是 Python 中常用的一个函数，用于生成一个整数序列。它常用于循环中，可以生成指定范围的整数序列。 range() 函数有三种常用的用法： range(stop): 生成从 0 开始到 stop-1 的整数序列。 range(start, stop): 生成从 start 开始到 stop-1 的整数序列。 range(start, stop, step): 生成从 start 开始到 stop-1 的整数序列，步长为 step。123456789101112# 生成从 0 到 4 的整数序列for i in range(5): print(i) # 输出：0, 1, 2, 3, 4# 生成从 2 到 5 的整数序列for i in range(2, 6): print(i) # 输出：2, 3, 4, 5# 生成从 1 到 10 的偶数序列for i in range(2, 11, 2): print(i) # 输出：2, 4, 6, 8, 10 需要注意的是，range() 函数生成的是一个可迭代对象，而不是一个列表。如果需要得到一个列表，可以使用 list() 函数将其转换为列表：12my_list = list(range(5)) # 将 range 对象转换为列表print(my_list) # 输出：[0, 1, 2, 3, 4] random详解使用前需要import random random.random(): 返回一个 [0.0, 1.0) 之间的随机浮点数。 random.randint(a, b): 返回一个 [a, b] 之间的随机整数。 random.uniform(a, b): 返回一个 [a, b] 之间的随机浮点数。 random.choice(seq): 从序列 seq 中随机选择一个元素返回。 random.shuffle(seq): 将序列 seq 中的元素随机排序 random.sample(population, k): 从 population 中随机选择 k 个不重复的元素返回，返回一个列表。 选择排序打擂台排序 1234567891011import randomdef select_sort(my_list): for i in range(len(my_list)): for j in range(i,len(my_list)): if my_list[j]&lt;my_list[i]: my_list[j],my_list[i]=my_list[i],my_list[j]my_list = [random.randint(0,10000) for i in range(5)]print(my_list)select_sort(my_list)print(my_list) 123# 结果[3871, 3692, 8939, 1310, 1203][1203, 1310, 3692, 3871, 8939] 插入排序 初始时手里（有序区）只有一张牌 每次（从无序区）摸一张牌，插入到手里已有牌的正确位置123456789101112131415161718import randomdef insert_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j &gt;= 0 and arr[j] &gt; key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = keymy_list = [random.randint(0, 10000) for i in range(5)]print(my_list)insert_sort(my_list)print(my_list) 123# 结果[904, 5335, 5843, 9487, 1597][904, 1597, 5335, 5843, 9487] 数据结构python中数据结构的类型 元组 无法修改，tuple,不可变数据结构 利用in查找 列表 支持增删改查 切片[x:y],左闭右开 追加，列表末尾增加元素list.append(元素) 插入，list.insert(下标,元素) 删除, list.pop(下标)，默认为最后一个元素 字典 删除，dictionary.pop(“键”) 字符与字符串实战统计出其中数字字符的个数输入一行字符，统计出其中数字字符的个数。 12345678user_input = input()digit_count = 0for char in user_input: if char &lt;= &#x27;9&#x27; and char &gt;= &#x27;0&#x27;: digit_count += 1print(digit_count) isdigit() 是 Python 中字符串对象的一个方法，用于检查字符串中的所有字符是否都是数字字符（即 0-9）。可以改为 12345678user_input = input()digit_count = 0for char in user_input: if char.isdigit(): digit_count += 1print(digit_count) 给定一个只包含小写字母的字符串请你找到第一个仅出现一次的字符。如果没有，输出 no 12345678my_list = input()for char in my_list: if my_list.count(char) == 1: print(char) breakelse: print(&quot;no&quot;) 详解countcount() 方法是字符串对象的一个内置方法，用于统计指定子字符串在原字符串中出现的次数。count() 方法只会统计不重叠的子字符串。例如，在字符串 “aaaaa” 中统计子字符串 “aa” 的出现次数，结果为 2，而不是 4，因为两个 “aa” 子字符串之间重叠","tags":["python"]},{"title":"数电重置版","path":"/2024/03/08/数电重置版/","content":"我希望在3月20号之前学完数电，开始挑战！数电第三章不学，七八章选学，带星号不写，over————2024.3.20 整体逻辑框架图 数制与码制10进制转2进制 2进制转10进制 10进制转8421BCD互转 逻辑代数基础异或与同或及其常见与或非 基本公式与常用公式 反演定理与对偶定理 卡诺图 最小项及其无关项无关项（d表示，卡诺图中用X） 任意项 约束项 目的：矩形圈最大，矩形数量最少 化简 转化 组合逻辑电路常见组合逻辑模块编码器 普通编码器 优先编码器（允许同时输入两个以上的编码信号） 译码器与显示译码器 数据选择器 半加器与全加器 数值比较器 竞争冒险现象及其如何消解消除方法 接入滤波电容 引入选通脉冲 增加冗余项（eg: Y&#x3D;A+A’+BC） 半导体电路分类存储大小 存储单元（一个字节） 静态存储单元 动态存储单元（需要定时刷新，主要用电容） 寄存器（一组字节） 存储器（大量字节） SR锁存器 与非门SR锁存器 或非门SR锁存器 触发器电平触发的SR触发器 电平触发的D触发器为了适应单端输入信号需求，常用D输入代替S,R输入利用CMOS传输门组成电平触发的D触发器在clk有效期间，输出与输入相同，该触发器又被称为透明D触发器 边沿触发的D触发器该电路上升沿有效Q*&#x3D;D 脉冲触发的SR触发器 脉冲触发的JK触发器 边沿触发的T触发器 触发器的分类触发方式分类 无触发 电平触发 边缘触发 脉冲触发 触发器分类 SR触发器 D触发器 JK触发器 T触发器 触发方式与逻辑功能无逻辑关系 存储器随机存储器RAM(断电丢失) 静态存储器（SRAM,速度快，集成度低，成本高） 动态存储器（DRAM，速度慢，集成度高，成本低）只读存储器ROM(断电不丢失) 掩膜ROM 可编程ROM 可擦除可编程ROM 存储器的拼装时序逻辑电路 同步，一个时钟信号 异步 同步时序电路"},{"title":"陀螺仪的工作原理","path":"/2024/02/15/陀螺仪的工作原理/","content":"陀螺仪的分类提供位置与角速度的装置 机械陀螺仪 光学陀螺仪 测量各部分压力 光学陀螺仪，计算接受的合成光束与初始光束的相位差，算得偏转量","tags":["其他"]},{"title":"基础电气知识部分综合","path":"/2024/01/29/基础电气知识部分综合/","content":"上拉电阻与下拉电阻下拉电阻没有下拉电阻，引脚浮空，将不确定的信号钳位在低电平不确定阻值设置为10k-100K 上拉电阻将不确定的信号钳位在高电平，有时io驱动能力不足时也可以加上拉电阻 寄生电容即电路中的元件在物理上不是电容时表现得像电容。在高频电路中会导致信号的失真和噪声的增加 如何减少寄生电容1.缩短元件之间的距离，从而减小元件之间的电容。2.将元件引脚与地之间的距离尽量缩短，减小元件与地之间的电容。3.合适的PCB布局，有效减小PCB板上的电容。4.采用屏蔽措施，以便减小电磁干扰。 滤波电容 GPIO的输出模式 高阻输出（有内置上拉电阻，或外加上拉电阻） 推挽输出（参考CMOS功能，输出高低电平）","tags":["PCB设计"]},{"title":"12V转5V电源模块","path":"/2024/01/27/12V转5V电源模块/","content":"前言看了B站孙老师的视频，受益匪浅，决定设计自己的12V转5V的电源模块采用同步整流芯片TPS54302，改芯片数据手册如下 https://www.ti.com/cn/lit/ds/symlink/tps54302.pdf?ts=1706321372159&amp;ref_url=https%253A%252F%252Fitem.szlcsc.com%252F 2 4.5V 至 28V 输入、3A 输出、EMI 友好型同步降压转换 降压电路原理 芯片原理图 自己画的原理图由于实际封装与原理图不一致，自己画的并没有芯片原理图那么规整 第一版pcb设计设计注意要点 线宽 避免直角走线 元件选型 正面 反面 第二版pcb设计设计要点 反馈电路选取电在电容附近 铜箔走线，过大电流 对称，美观 电容电阻选型时要选择合适的封装，电容电阻常见封装为0603,0805,1206等 正面 反图 实物图","tags":["PCB设计"]},{"title":"模电","path":"/2024/01/20/模电/","content":"信号时间和数值 时间连续，数值连续（模拟信号） 时间不连续，数值连续（抽样信号） 时间连续，数值不连续（脉冲信号） 时间不连续，数值不连续（数字信号） 常用半导体器件基础知识 导体 半导体 绝缘体 常见半导体，硅(si)和锗(ge)四价元素 半导体分类，本征半导体与杂质半导体 载流子有自由电子与空穴 N型半导体(五价磷)与P型半导体(三价硼) 重点 PN节硅(si)原子结构 单晶硅齐纳击穿与雪崩击穿扩散运动与漂移运动正向特征 截止区（死区） 导通区 过流区 反向特征 反向饱和区 反向击穿区","tags":["课程"]},{"title":"数电","path":"/2024/01/11/数电/","content":"数制与码制进制转化原码，反码，补码 正数三码合一 负数，反码标志位不变，其他取反，补码，在反码基础上加1 计算机以补码形式运算 逻辑代数基础与或非及其变种 门电路概述 单开关电路与互补开关电路门电路的基本元件 二极管 三极管 MOS管 半导体二极管学习要点 二极管 理想二极管 实际二极管 理想开关 二极管的动态电流效应（类似电容） 二极管实现门电路实现0&#x2F;1实现与电路实现或电路 二极管门电路的缺陷 二极管实现的与或门有高低电平的偏移 负载影响输出的高电平 MOS管P沟道与n沟道MOS管 mos管的输入输出特性 截止区 可变电阻区 恒流区 P沟道与N沟道MOS的区别 CMOS反相器 组合逻辑电路逻辑电路分类 组合逻辑电路 时序逻辑电路（含存储器） 编码器 普通编码器 优先编码器 74HC148引脚定义 16线-4线输出原理图 74HC147（二-十进制优先编码器） 竞争与冒险现象是什么？有尖峰-冒险可能尖峰-竞争 如何判断？是否出现Y&#x3D;A+A’或Y&#x3D;AA’用EDA软件检查是否有毛刺现象，检查时序 如何解决？ 接滤波电容 引入选通信号（再有毛刺发生的时候不输出） 修改逻辑设计（增加冗余项）","tags":["课程"]},{"title":"电子电路基础知识","path":"/2024/01/06/电子电路基础知识/","content":"基础元件 电阻 电容 电感 二极管 三极管&#x2F;mos管 电阻色环电阻的辨认电阻的符号电阻的单位转换电阻的封装 三极管基极B,集电极C,发射极D.B极小电流控制C极大电流，具有电流放大作用 三种工作状态 截止状态 放大状态 饱和状态 MOS管源极S 栅极G 漏极D 特性 栅极阻抗高 易被静电击穿 参数 Vgsth 电压临界值 Rdson 电阻 Cgs 栅极电容 三极管与MOS管的区别 三极管是电流控制的元件，MOS管是电压控制的元件 MOS管省电，阻抗小 三极管便宜，耐高压大电流","tags":["电路"]},{"title":"51单片机核心板绘制","path":"/2024/01/01/51单片机核心板绘制/","content":"参考资料 https://blog.csdn.net/weixin_61121477/article/details/127743905 https://mp.weixin.qq.com/s/Ca96Eaom3HDGVuQAlgokvg https://blog.csdn.net/flying_man_/article/details/82557816 原理图 pcb图 3D渲染图 详解单片机最小系统包括核心模块有： 电源模块 复位模块 外部晶振模块 下载模块 本原理图中，采用type-c 16pin为下载和电源接口，根据单片机手册，输入电压为3.8v~5.5v.根据手册，P0开漏输出，原理图设计时，加上拉电阻作为I&#x2F;O口使用。 晶振模块采用32M,由手册提供，原理图并不完全符合。 https://zhuanlan.zhihu.com/p/72583737晶振电路原理详解 滤波电容，消除震荡。 usb转串口模块常用的有CH340N与CH340G。","tags":["51单片机"]},{"title":"电子设计实训小组计划","path":"/2024/01/01/电子设计实训小组计划/","content":"电子设计实训小组计划于2024-01-01开启，新年新气象，这是一次积极的尝试。 初始成员6人 data:2024-01-01目的：锻炼电路设计，编程能力基本准则：共同商议，共同管理，共同进步 第一次计划：51单片机核心板的绘制 寒假学习：1.数电模电2.嘉立创的学习与使用3.个人博客（选修） data:2024-01-06四人完成51单片机的原理图绘制与pcb绘板工作准备开始打板测试工作 data:2024-01-17第一次寒假线上会议，确定基本任务 任务一：个人博客的制作 任务二：12V转5V电源模块 任务三：数电模电第一章的学习 任务四：在嘉立创免费范围内打点小东西 其他：电赛题目搜集。1月25复盘总结。 data:2024-01-25第二次寒假线上会议，总结上次成果12V转5V电源模块 个人博客的汇总http://shisan-ok.gitee.io https://sherlock000125.github.io https://fransic.top https://liwuyou.github.io 下阶段任务 数电第二章，模电第一章未完成继续 设计一个电机驱动模块 跑跑仿真 data:2024-02-02第三次寒假线上会议，总结上次成果电机驱动模块 data:2024-02-14会议重点:1.软件方面，自行处理2.本次做陀螺仪模块，主要处理信号方面，模块外围电路较少，尽量的设计好一点，熟悉芯片的选型，PCB走线信号线设计3.数电模电向前推进一章4.完善个人博客5.我们还差ADC的转换和射频，自行处理。ADC的转换比较重要","tags":["计划"]},{"title":"单片机的常见通讯协议","path":"/2023/12/30/单片机的常见通讯协议/","content":"常见单片机通讯协议 I2c通信 spi通信 I2c通信 https://blog.csdn.net/yanlaifan/article/details/72843577?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170393696216800226590203%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170393696216800226590203&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-72843577-null-null.142^v99^pc_search_result_base3&amp;utm_term=i2c%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E5%9B%BE&amp;spm=1018.2226.3001.4187 硬件层两根线，SDA(数据)和SCL(时钟)从最高位到最低位发送（MSB—&gt;LSB） 协议层协议 空闲态 起始信号 逻辑电平 时序图 停止位在时钟线为高时，数据线为高，为1，否则为0 代码以51单片机为例I2C.h文件 123456789101112#ifndef __I2C_H__#define __I2C_H__void I2C_Start(void);void I2C_Stop(void);void I2C_SendByte(unsigned char Byte);unsigned char I2C_ReceiveByte(void);void I2C_SendAck(unsigned char AckBit);unsigned char I2C_ReceiveAck(void);#endif I2C.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;REGX52.H&gt;sbit I2C_SCL=P2^1;sbit I2C_SDA=P2^0;/** * @brief I2C开始 * @param 无 * @retval 无 */void I2C_Start(void)&#123;\tI2C_SDA=1;\tI2C_SCL=1;\tI2C_SDA=0; I2C_SCL=0; &#125;/** * @brief I2C停止 * @param 无 * @retval 无 */void I2C_Stop(void)&#123;\tI2C_SDA=0;\tI2C_SCL=1;\tI2C_SDA=1;&#125;/** * @brief I2C发送一个字节 * @param Byte 要发送的字节 * @retval 无 */void I2C_SendByte(unsigned char Byte)&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; I2C_SDA=Byte&amp;(0x80&gt;&gt;i); I2C_SCL=1; I2C_SCL=0;\t&#125;&#125;/** * @brief I2C接收一个字节 * @param 无 * @retval 接收到的一个字节数据 */unsigned char I2C_ReceiveByte(void)&#123;\tunsigned char i,Byte=0x00;\tI2C_SDA=1;\tfor(i=0;i&lt;8;i++)\t&#123; I2C_SCL=1; if(I2C_SDA)&#123;Byte|=(0x80&gt;&gt;i);&#125; I2C_SCL=0;\t&#125;\treturn Byte;&#125;/** * @brief I2C发送应答 * @param AckBit 应答位，0为应答，1为非应答 * @retval 无 */void I2C_SendAck(unsigned char AckBit)&#123;\tI2C_SDA=AckBit;\tI2C_SCL=1;\tI2C_SCL=0;&#125;/** * @brief I2C接收应答位 * @param 无 * @retval 接收到的应答位，0为应答，1为非应答 */unsigned char I2C_ReceiveAck(void)&#123;\tunsigned char AckBit;\tI2C_SDA=1;\tI2C_SCL=1;\tAckBit=I2C_SDA;\tI2C_SCL=0;\treturn AckBit;&#125; 写入与读取1帧的数据 123456789101112131415161718192021222324252627282930313233void AT24C02_WriteByte(unsigned char WordAddress,Data)&#123;\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS);\tI2C_ReceiveAck();\tI2C_SendByte(WordAddress);\tI2C_ReceiveAck();\tI2C_SendByte(Data);\tI2C_ReceiveAck();\tI2C_Stop();&#125;/** * @brief AT24C02读取一个字节 * @param WordAddress 要读出字节的地址 * @retval 读出的数据 */unsigned char AT24C02_ReadByte(unsigned char WordAddress)&#123;\tunsigned char Data;\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS);\tI2C_ReceiveAck();\tI2C_SendByte(WordAddress);\tI2C_ReceiveAck();\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS|0x01);\tI2C_ReceiveAck();\tData=I2C_ReceiveByte();\tI2C_SendAck(1);\tI2C_Stop();\treturn Data;&#125; 实验验证4路OLED的驱动基于I2C通信的陀螺仪","tags":["单片机"]},{"title":"大物下，复习补充","path":"/2023/12/24/大物下，复习补充/","content":"量子的部分，6-8分左右，速成课无本部分内容，特补充","tags":["课程"]},{"title":"复变函数与积分变换","path":"/2023/12/15/复变函数与积分变换/","content":"马上就要考试了，悲 复数与复变函数复数的三种形式 复数的一般形式 $Z&#x3D;x+yi$ 复数的三角表示 $Z&#x3D;r(\\cos\\theta+j\\sin\\theta)$ 复数的指数形式 $Z&#x3D;re^{i\\theta}$ 复数的主值与辐值$$ArgZ &#x3D; argZ + 2k\\pi$$其中 $0 \\leq argZ&lt;2\\pi$ 主值的求解公式 棣莫弗公式 ★$$Z^n&#x3D;[r(\\cos\\theta+i\\sin\\theta)]^n&#x3D;r^n(\\cos{n\\theta}+\\sin{n\\theta})&#x3D;re^{in\\theta}$$当r&#x3D;1时，有$$(\\cos\\theta+i\\sin\\theta)^n&#x3D;\\cos{n\\theta}+\\sin{n\\theta}$$逆运用$$w&#x3D;r^{\\frac{1}{n}}[\\cos(\\frac{1}{n}(\\theta+2k\\pi))+i\\sin(\\frac{1}{n}(\\theta+2k\\pi))]$$ 其中$k&#x3D;0,1,2,…,n-1$$r&#x3D;|Z|$ 练习共轭复数$ReZ&#x3D;\\frac{Z+\\overline{Z}}{2}$$ImZ&#x3D;\\frac{Z-\\overline{Z}}{2i}$ 解析函数解析函数：概念性质、充分&#x2F;必要条件、调和函数、初等函数 解析概念：$w&#x3D;f(Z)$如果在$Z_{0}$及其领域内处处可导，则$f(Z)$在$Z_{0}$处解析解析-&gt;可导-&gt;连续反之不行 函数解析的充要条件（柯西-黎曼方程）C-R方程$f(z)&#x3D;u(x,y)+iv(x,y)$在$z&#x3D;x+iy$处处可导的充要条件是$u(x,y)$，$v(x,y)$在点$(x,y)$处可微$$\\frac{\\partial u}{\\partial x}&#x3D;\\frac{\\partial v}{\\partial y}且\\frac{\\partial u}{\\partial y}&#x3D;-\\frac{\\partial v}{\\partial x}$$ 调和函数调和函数和解析函数针对的对象不同解析函数针对$f(Z)$调和函数针对$u(x,y)与v(x,y)$ 拉普拉斯方程（Laplace）$$\\frac{\\partial^{2} \\varphi}{\\partial^{2}x}+ \\frac{\\partial^{2} \\varphi}{\\partial^{2}y}&#x3D;0$$解析函数的实部和虚部是调和函数 初等函数指数函数$$e^{Z}&#x3D;e^{x+iy}&#x3D;e^{x}(\\cos x +i\\sin y)$$指数函数性质有： $ |e^{Z}|&#x3D;e^{x}$ $Arg(e^{Z})&#x3D;y+2k\\pi$ $e^{Z+i2k\\pi}&#x3D;e^{Z}，即e^{Z}是以2k\\pi 为周期的周期函数$ $(e^{Z})’&#x3D;e^{Z}$ 对数函数$LnZ&#x3D;lnZ+i2k\\pi&#x3D;ln|Z|+iargZ+i2k\\pi$ 幂函数$a^{b}&#x3D;e^{(Lna)b}$ 三角函数 反三角函数 练习复变函数的积分定义及如何积分定义在简单光滑或分段光滑上的有向曲线上的积分$$f(Z)&#x3D;u(x,y)+iv(x,y)$$$$f_{c}(Z)dZ$$如何积分？两种方法 第二型曲线积分$$\\int_{c}(Z)dZ&#x3D;\\int_{c}u(x,y)+iv(x,y)dZ&#x3D;\\int_{c}udx-vdy+i\\int_{c}vdx+udy$$ 参数法$$\\int_{c}(Z)dZ&#x3D;\\int^{\\beta}_{\\alpha}f(Z(t))Z’(t)dt$$ 柯西-古萨定理$$\\oint_{c}f(Z)dZ&#x3D;0$$$f(Z)$在C上及D内解析则成立 复合闭路定理推导$f(Z)$在$\\Gamma$上解析，且$\\Gamma&#x3D;C+C^{-}{1}+C^{-}{2}$+…，则$\\oint_{\\Gamma}f(Z)dZ&#x3D;0$，代入$\\Gamma &#x3D;C+C^{-}{1}+C^{-}{2}$+…则$\\oint_{C+C^{-}{1}+C^{-}{2}+…}f(Z)dZ&#x3D;0$ 化简移项可得 $$\\oint_{c}f(Z)dZ&#x3D; \\sum_{n&#x3D;1}^n\\oint_{C_{k}}f(Z)dZ$$当k&#x3D;1时，则得 $$\\oint_{c}f(Z)dZ&#x3D; \\oint_{k}f(Z)dZ$$ 柯西积分公式 ★适用条件：$f(Z)$要在C上及其内部解析$$\\oint_{c}\\frac{f(Z)}{Z-Z_{0}}dZ&#x3D; 2\\pi if(Z_{0})$$高阶$$\\oint_{c}\\frac{f(Z)}{(Z-Z_{0})^{n-1}}dZ&#x3D; \\frac{2\\pi i}{n!} f(Z_{0})$$ 级数(研究其敛散性)级数的一些性质$\\sum_{n&#x3D;1}^n|Z|$收敛，则$\\sum_{n&#x3D;1}^nZ$也收敛 $\\sum_{n&#x3D;1}^n\\frac{1}{n}$是发散的 复数序列$Z_{1}&#x3D;a_{1}+b_{1}i$，$Z_{2}&#x3D;a_{2}+b_{2}i$，…$Z_{n}&#x3D;a_{n}+b_{n}i$，…上面的序列，简记为$${Z_{n}}$$ 项级数如何判断一个项级数是收敛还是发散的呢？部分和判断部分和为$$S_{n}&#x3D;Z_{1}+Z_{2}+…Z_{n}$$部分和序列$${S_{n}}&#x3D;S_{1}+S_{2}+…S_{n}$$ 幂级数 ★形式和收敛半径要记住，收敛半径的求法，比值法和根值法。其级数在其收敛半径内部绝对收敛，在其收敛半径上不一定。 幂级数和函数性质2的应用 幂级数的运算（加减乘除）对应题型，将函数展开为Z的幂级数（不熟练） 泰勒级数常见泰勒展开泰勒展开的形式 洛朗级数洛朗级数&#x3D;负幂项+正幂项洛朗级数是收敛圆环题型 求收敛圆环的半径 展开为洛朗级数负幂项的收敛半径按正幂项求，最后取倒数。 留数及其应用奇点及奇点的分类及求法 孤立奇点（洛朗展开仅有正幂项） n阶极点（有负幂项，部分为0） 本性奇点（洛朗展开既有正幂项，又有负幂项） 零点及m阶零点零点和极点的关系 留数定义计算 ★一阶极点的留数的快速求法","tags":["课程"]},{"title":"爬虫入门","path":"/2023/12/14/爬虫入门/","content":"爬虫简介爬虫的概念通过编写程序，模拟浏览器上网，然后让其抓取数据的过程 爬虫分类 通用爬虫（整张页面） 聚焦爬虫（局部内容） 增量式爬虫（抓取更新内容） 爬虫的矛与盾 爬虫 反爬机制 反反爬策略 robots.txt协议君子协议，规定可爬取，不可爬取网址后面加&#x2F;robots.txt 即可访问 http协议 概念：服务器与客户端进行数据交互的一种形式 常用请求头信息 User-Agent:请求载体的身份标识 Connection:请求完毕后，是断开连接还是保持连接 常用响应头信息 Content-Type: 服务器响应回客户端的数据类型 https协议:安全的超文本传输协议 加密方式 对称秘钥加密 非对称秘钥加密 证书秘钥加密 requests请求requests模块: python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 作用:模拟浏览器发请求。 如何使用: (requests模块的编码流程) 指定urT 发起请求 获取响应数据 持久化存储环境安装:pip install requests 实战编码:需求: 爬取搜狗首页的页面数据1234567891011121314import requestsif __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/&#x27; # 发起请求 response = requests.get(url=url) # 获取响应数据,text返回的是字符串 page_text = response.text print(page_text) # 持久化存储 with open(&quot;./sogou.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://blog.csdn.net/m0_46778548/article/details/121201868Python文件读写操作 https://blog.csdn.net/qiqicos/article/details/79200089python 里with… as.. 的操作方法 需求: 爬取搜狗指定头条学习点UA伪装 123456789101112131415161718192021222324252627import requests#UA:User-Agent.(请求载体的身份标识)# UA检测门户网站的服务器会检测对应请求的载体身份标识,不正常则服务器端就很有可能拒绝该次请求# UA伪装if __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/web&#x27; # UA伪装:将对应的User-Agent封装到一个完典中 headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0&#x27;&#125; # 处理参数并字典封装 ws = input(&quot;Please enter a word:&quot;) param = &#123;&#x27;query&#x27;: ws&#125; # 对指定的url发起的请求对应的urL是携带参数的，并且请求过程中处理了参数 response = requests.get(url=url, params=param, headers=headers) # 持久化存储 page_text = response.text print(page_text) with open(&quot;./&quot;+ws+&quot;.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://www.runoob.com/python3/python-requests.htmlrequest模块详解","tags":["python"]},{"title":"基于树莓派上位机与arduino下位机实现键盘控制","path":"/2023/12/14/基于树莓派上位机与arduino下位机实现键盘控制/","content":"实现键盘控制小车行驶 下位机代码，Arduino的5号引脚为电机引脚，9号引脚为舵机引脚 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;Servo.h&gt; Servo myservo;String str;int pos = 92; //舵机角度int motor_pwm = 100; //电机数值0 ~255int pos_mid = 92; // 储存舵机中值角度int motorPin = 5; // 确定motor控制引脚int servoPin = 9; //确定servo控制引脚 void setup() &#123; Serial.begin(115200); myservo.attach(servoPin); // 该舵机由arduino第9脚控制 pinMode(motorPin, OUTPUT); // 将电机引脚设为输出模式 myservo.write(pos_mid); // 舵机复位 analogWrite(motorPin,0); // 电机初始转动 delay(1000);&#125; void loop() &#123; if (Serial.available() &gt;= 2) &#123; int servoValue = Serial.read(); int motorValue = Serial.read(); // 控制舵机 myservo.write(servoValue); if (servoValue &lt;40) servoValue=40; else if(servoValue &gt; 140) servoValue=140; Serial.print(&quot;servo: &quot;); Serial.println(servoValue); // 控制电机 if (motorValue &lt;0) motorValue=0; else if(motorValue &gt; 255) motorValue=255; analogWrite(motorPin, motorValue); Serial.print(&quot;motor: &quot;); Serial.println(motorValue); &#125; &#125; 上位机代码文件名 key_control.py 123456789101112131415161718192021222324252627282930313233343536373839404142# Author: 无忧# Date: 2023-12-02# Description: 这是一个键盘控制的简单代码# 请调节键盘状态为英语小写状态# -------------------- import keyboardimport time# 要下包keyboardfrom send_M_S import * speed = 0speed_max = 60 # 速度的最大值turn = 92 # 舵机中值turn_l = 60 # 舵机打角最左turn_r = 120 # 舵机打角最右 if __name__ == &quot;__main__&quot;: ser = init_send() while True: try: if keyboard.is_pressed(&#x27;w&#x27;): speed += 5 if speed &gt;= speed_max: speed = speed_max elif keyboard.is_pressed(&#x27;a&#x27;): turn -= 8 if turn &lt;= turn_l: turn = turn_l elif keyboard.is_pressed(&#x27;d&#x27;): turn += 8 if turn &gt;= turn_r: turn = turn_r elif keyboard.is_pressed(&#x27;s&#x27;): speed -= 5 if speed &lt;= 0: speed = 0 time.sleep(0.1) # 系统响应速度 send_values(ser, turn, speed) except KeyboardInterrupt: break 上位机串口代码文件名send_M_S 123456789101112131415161718192021222324252627282930313233# Author:# Date: 2023-12-02# Description: This script does XYZ.import serialimport timeimport sys # 设置串口参数def init_send(): ser = serial.Serial(&#x27;COM4&#x27;, 115200, timeout=1) return ser def send_values(ser, servo_value, motor_value): # 向串口发送舵机值和电机值 time.sleep(0.1) ser.write(bytes([servo_value, motor_value])) while ser.in_waiting: arduino_feedback = ser.readline().decode() print(&quot;Arduino:&quot;, arduino_feedback) if __name__ == &#x27;__main__&#x27;: # 初始化串口 ser = init_send() try: while True: for i in range(60, 120, 1): send_values(ser, i, 50) for i in range(120, 60, -1): send_values(ser, i, 50) except KeyboardInterrupt: # 在用户按下 Ctrl+C 时，关闭串口并退出程序 ser.close() sys.exit()","tags":["arduino"]},{"title":"电路复习","path":"/2023/11/14/电路复习/","content":"写在前面的话我打算尝试一下，用markdown，部署到网页进行电路的学习与记录困难点来自两1.多图片，图床问题2.多数学公式 这是一次有意义的探索，一次尝试 电路的简化电压源串联电流源并联电压源与电流源的串联相当与电流源 电压源与电流源的并联相当与电压源 电流源的内阻为无穷大 电压源与电流源的转化$\\Delta$与Y的等效变换$\\Delta$ -&gt; Y $$Y型电阻 &#x3D; \\frac{\\Delta相邻电阻乘积}{\\Delta电阻之和}$$Y -&gt; $\\Delta$$$\\Delta型电阻 &#x3D; \\frac{Y型电阻两两乘积之和}{Y型不相邻电阻}$$相同阻值情况下，3Y&#x3D;$\\Delta$ 电源置零独立电压源短路，独立电流源断路 独立源与受控源受控源 vcvc 电压控制的电压源 vccs 电压控制的电流源 ccvs 电流控制的电压源 cccs 电流控制的电流源 voltage 电压 current 电流 control控制 source源 输入电阻无源一端口网络的等效变换，无源指的是无独立电源简而言之，一个不含独立源的一端口网路，等效为一个电阻$R_{eq}$输入电阻求法 外加电源法 建议外加电压源$$R_{eq} &#x3D; \\frac{u}{i}$$注意，在存在受控源的情况下，R可能为负。 【大学电路习题讲解——求输入电阻1】 【精准空降到 00:19】 https://www.bilibili.com/video/BV1z7411W72Z/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6&amp;t=19 三种电流方法基本概念 结点(n) 支路(b) 网孔 网孔数&#x3D;独立回路数 支路电流法（基本用不到） 找出支路数(b)，找出结点数(n) 列n-1个KCL方程 列b-n+1个KVL方程 联立求解 回路电流法 找出b-n+1个回路 列方程求解 $$R_{11}i_{1}+R_{12}i_{2}+… &#x3D; u_{11}$$$$R_{21}i_{1}+R_{22}i_{2}+… &#x3D; u_{22}$$$$R_{31}i_{1}+R_{32}i_{2}+… &#x3D; u_{22}$$$$……$$$$R_{n1}i_{1}+R_{n2}i_{2}+… &#x3D; u_{22}$$ 其中，$R_{11}$…$R_{nn}$为回路n的电阻之和$R_{21}$&#x3D;$R_{12}$为回路1，2共有的电阻(方向相同则为正)$u_{11}$回路1所有电压源之和，指定电流由“+” -&gt; “—”取负，反之 结点电压 找出所有结点，选取待测相关的一个结点为0，其他分别为1，2，… 将与电流源串联的电阻变导线，与电压源并联的电阻变短路 列方程求解$$G_{11}u_{n1}+G_{12}u_{n2}+… &#x3D; i_{s11}$$$$G_{21}u_{n1}+G_{22}u_{n2}+… &#x3D; i_{s22}$$$$G_{31}u_{n1}+G_{32}u_{n2}+… &#x3D; i_{s33}$$ 其中，$i_{s11}$&#x3D;$\\frac{电压源}{所在支路电阻}+电流源$，流入结点为正，流出为负 例题精讲（待补充）电路原理叠加定理 https://www.bilibili.com/video/BV1HF411W7L9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=755a0f899976f771c7923daed9448d48 表述：在线性电阻电路中，某处电压或电流都是各个独立电源单独作用时，电压与电流的叠加 注意： 某电源作用时，其他独立源置零 受控源不置零 线性电路 可设置0电压的点，即接地 替换定理简述：任何一个支路（端口）已知电压或电流，就可以将该支路（端口）用电压源或电流源替代。既可以线性电路，也可以非线性 适用条件及其注意点不要把受控源的控制量替换掉 戴维南定理（等效电压源定理）简述：将一个二端网路，等效为一个电压源串联一个等效电阻。注意开路，开路！！步骤： 剥离待求项，将原电路化为开路二端网络，求U, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电压源串联一个等效电阻 诺顿定理（等效电流源定理）简述：将一个二端网路，等效为一个电流源并联一个等效电阻。 剥离待求项，将原电路d待求项短接，求I, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电流源并联一个等效电阻 戴维宁求谁断路谁，诺顿求谁断路谁，然后电源置零，用外加电压法$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$，求输入电阻 储能元件电容（电流记忆元件）VCR为$$i &#x3D; C\\frac{ d_{u}}{d_{t}}$$ 电感（电压记忆元件）VCR为$$u&#x3D; L\\frac{ d_{i}}{d_{t}}$$ 电容与电感的串并联电容的串并联与电阻相反电感的串并联与电阻类似 RC电路与RL电路的响应$$U_{c}&#x3D;U_{c}(\\infty)+[U_{c}(0_{+})-U_{c}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;RC)$$1.电容断路，求$U_{c}(\\infty)$和$U_{c}(0_{+})$，求变化前后稳定时的电压。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电容断路，求输入电阻3.代入求解 $$I_{L}&#x3D;I_{L}(\\infty)+[I_{L}(0_{+})-I_{L}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;R&#x2F;L)$$1.电感短路路，求$I_{L}(\\infty)$和$I_{L}(0_{+})$，求变化前后稳定时的电流。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电感断路，求输入电阻3.代入求解 补充$$U(t)&#x3D;U(t_{0})+\\frac{1}{C}\\int_{t_{0}}^tI_{t}d\\xi$$$$I(t)&#x3D;I(t_{0})+\\frac{1}{L}\\int_{t_{0}}^tu_{t}d\\xi$$ 一阶电路与二阶电路的时域分析零输入响应（无电源）零状态响应（未充能）全响应（有电源且电容已充能）向量法复数的三种形式$$F&#x3D;|F|(\\cos\\theta+j\\sin\\theta)&#x3D;a+jb$$$$F&#x3D;|F|e^{j\\theta}$$$$F&#x3D;|F|\\angle\\theta$$ 欧拉公式$$e^{j\\theta}&#x3D;(\\cos\\theta+j\\sin\\theta)$$$$e^{j\\pi}+1&#x3D;0$$ 正弦量$$u&#x3D;U_{max}\\cos(wt+\\psi)&#x3D;\\sqrt{2}V\\cos(wt+\\psi)&#x3D;V\\angle\\theta$$注意，向量法表述时为有效值 https://zhuanlan.zhihu.com/p/110148728 电路定理的向量形式基尔霍夫定律$$\\Sigma i(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{I}(t)&#x3D;0$$$$\\Sigma u(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{U}(t)&#x3D;0$$ 电路元件的向量关系$$u&#x3D;Ri \\rightleftarrows \\dot{U}&#x3D;R\\dot{I}$$$$u&#x3D; L\\frac{ d_{i}}{d_{t}} \\rightleftarrows \\dot{U}&#x3D;jwL\\dot{I}$$$$u&#x3D;\\frac{1}{C}\\int idt \\rightleftarrows \\dot{U}&#x3D;\\frac{1}{jwC}\\dot{I}&#x3D;-j\\frac{1}{wC}\\dot{I}$$","tags":["课程"]},{"title":"numpy库的学习","path":"/2023/10/24/numpy库的学习/","content":"参考资料 https://www.runoob.com/numpy/numpy-tutorial.html 线性代数基础概念理解线性代数的概念忘了，这里补一补 https://zhuanlan.zhihu.com/p/422251943 numpyNumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C&#x2F;C++&#x2F;Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能","tags":["python"]},{"title":"python的os库的使用","path":"/2023/10/22/python的os库的使用/","content":"参考资料 https://blog.csdn.net/m0_55697123/article/details/119464001 https://blog.csdn.net/wulishinian/article/details/106420532 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport time# print(os.system(&#x27;C:\\\\Windows\\\\System32\\\\calc.exe&#x27;))print(os.name) # linux 显示posixprint(os.environ) # 环境变量# windows \\ , linux /# 常用系统相关变量，sep分隔符print(os.sep)print(os.pathsep)print(os.linesep)# 文件和目录操作# os.mkdir(&quot;test&quot;) # 在当前路径下创建目录# os.rmdir(&quot;test&quot;) # delete目录# os.remove(&quot;文件名&quot;) #delete文件print(os.getcwd()) # 打印当前目录# os的子模块 os.pathfile = os.getcwd()+&quot;/main.py&quot;print(os.path.split(file)) # 分割文件名和路径mkdir, filename = os.path.split(file)print(filename)# 判断绝对路径与相对路径print(os.path.isabs(file)) # 是绝对，则返回TRUE# 判断文件或目录是否存在print(os.path.exists(file))# 拿到目录或文件最后修改时间，开始创建时间print(os.path.getatime(file)) # 显示时间戳print(os.path.getctime(file)) #print(os.path.getsize(file)) # 拿到文件大小,字节# 执行命令# os system popen 不推荐使用 执行结果 1234567891011121314151617181920ntenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming&#x27;, &#x27;COMMONPROGRAMFILES&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMMONPROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)\\\\Common Files&#x27;, &#x27;COMMONPROGRAMW6432&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMPUTERNAME&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;COMSPEC&#x27;: &#x27;C:\\\\Windows\\\\system32\\\\cmd.exe&#x27;, &#x27;DRIVERDATA&#x27;: &#x27;C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData&#x27;, &#x27;HOMEDRIVE&#x27;: &#x27;C:&#x27;, &#x27;HOMEPATH&#x27;: &#x27;\\\\Users\\\\Windows&#x27;, &#x27;IDEA_INITIAL_DIRECTORY&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\Desktop&#x27;, &#x27;LOCALAPPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local&#x27;, &#x27;LOGONSERVER&#x27;: &#x27;\\\\\\\\DESKTOP-0R6DJK5&#x27;, &#x27;NUMBER_OF_PROCESSORS&#x27;: &#x27;4&#x27;, &#x27;ONEDRIVE&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;ONEDRIVECONSUMER&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;OS&#x27;: &#x27;Windows_NT&#x27;, &#x27;PATH&#x27;: &#x27;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\ odejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Scripts\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming\\ pm;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PATHEXT&#x27;: &#x27;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#x27;, &#x27;PROCESSOR_ARCHITECTURE&#x27;: &#x27;AMD64&#x27;, &#x27;PROCESSOR_IDENTIFIER&#x27;: &#x27;Intel64 Family 6 Model 78 Stepping 3, GenuineIntel&#x27;, &#x27;PROCESSOR_LEVEL&#x27;: &#x27;6&#x27;, &#x27;PROCESSOR_REVISION&#x27;: &#x27;4e03&#x27;, &#x27;PROGRAMDATA&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;PROGRAMFILES&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)&#x27;, &#x27;PROGRAMW6432&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PSMODULEPATH&#x27;: &#x27;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules&#x27;, &#x27;PUBLIC&#x27;: &#x27;C:\\\\Users\\\\Public&#x27;, &#x27;PYCHARM&#x27;: &#x27;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PYCHARM_DISPLAY_PORT&#x27;: &#x27;63342&#x27;, &#x27;PYCHARM_HOSTED&#x27;: &#x27;1&#x27;, &#x27;PYTHONIOENCODING&#x27;: &#x27;UTF-8&#x27;, &#x27;PYTHONPATH&#x27;: &#x27;D:\\\\opencv_study;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_matplotlib_backend;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_display&#x27;, &#x27;PYTHONUNBUFFERED&#x27;: &#x27;1&#x27;, &#x27;SESSIONNAME&#x27;: &#x27;Console&#x27;, &#x27;SYSTEMDRIVE&#x27;: &#x27;C:&#x27;, &#x27;SYSTEMROOT&#x27;: &#x27;C:\\\\Windows&#x27;, &#x27;TEMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;TMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;USERDOMAIN&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERDOMAIN_ROAMINGPROFILE&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERNAME&#x27;: &#x27;Windows&#x27;, &#x27;USERPROFILE&#x27;: &#x27;C:\\\\Users\\\\Windows&#x27;, &#x27;WINDIR&#x27;: &#x27;C:\\\\Windows&#x27;&#125;)\\;D:\\opencv_study(&#x27;D:\\\\opencv_study&#x27;, &#x27;main.py&#x27;)main.pyTrueTrue1697922899.98245931697807194.7697878986Process finished with exit code 0 python文件打开新的终端，并执行文件linux 环境在写Python程序的时候遇到需要打开一个新的终端(terminal)或者说命令行窗口进行监视的情况 12345import osos.system(&quot;gnome-terminal -e &#x27;ls&#x27;&quot;) # 窗口执行后关闭os.system(&quot;gnome-terminal -e &#x27;bash -c \\&quot;ls; exec bash\\&quot;&#x27;&quot;) # 窗口执行后不关闭# 其中 &#x27;ls&#x27; 部分即为所需执行的内容。 Windows环境1234import osos.system(&quot;start powershell.exe cmd /k &#x27;dir&#x27;&quot;)# 其中 &#x27;dir&#x27; 部分即为所需执行的内容","tags":["python"]},{"title":"opencv學習","path":"/2023/10/19/opencv學習/","content":"参考资料 https://www.bilibili.com/video/BV1ET4y127vd/?spm_id_from=333.999.0.0&amp;vd_source=755a0f899976f771c7923daed9448d48 https://opencv.apachecn.org/ opencv简介是什么？计算机视觉开源软件库 numpy opencv-python的安装打开cmd输入 123pip install opencv-pythonpip install opencv-contrib-python 开梯子下载更快 测试代码 123456import cv2# 读一个图片并进行显示(图片路径需自己指定)lena=cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, lena) # 打开新窗口，窗口名为image,显示Lenacv2.waitKey(0) opencv模块其中core、highgui、imgproc是最基础的模块，该课程主要是围绕这几个模块展开的，分别介绍如下: core模块实现了最核心的数据结构及其基本运算，如绘图函数、数组操作相关函数等 highgui模块实现了视频与图像的读取、显示、存储等接口。 imgproc模块实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、闻值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。 其他 features2d模块用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。obidetect模块实现了一些目标检测的功能，经典的基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification (级联分类)和Latent SVM等。 stitching模块实现了图像拼接功能。 FLANN模块 (Fast Library for Approximate Nearest Neighbors)，包含快速近似最近搜索FLANN和聚类Clustering算法。 ml模块机器学习模块 (SVM，决策树，Boosting等等) photo模块包含图像修复和图像去噪两部分。 video模块针对视频处理，如背景分离，前景检测、对象跟踪等。 calib3d模块即Calibration (校准)3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。G-API模块包含超高效的图像处理pipeline引擎 图像的基础操作 掌握图像的读取和保存方法 能够使用OpenCV在图像上绘制几何图形 能够访问图像的像素 能够获取图像的属性，并进行通道的分离和合并0 能够实现颜色空间的变换 读取图像1cv.imread(&quot;路径&quot;) cv.IMREAD*COLOR:以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。 cv.IMREAD*GRAYSCALE: 以灰度模式加载图像 Cv.IMREAD UNCHANGED: 包括alpha通道的加载图像模式。可以使用1、0或者-1来替代上面三个标志12345678import numpy as npimport cv2#以灰度图的形式读取图像img = cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, img)cv2.waitKey(0) 注意:如果加载的路径有错误，不会报错，会返回一个None值 显示图像1cv.imshow(&quot;窗口名&quot;， 图片) 注意:在调用显示图像的API后，要调用cv.waitKey()&#x2F;&#x2F;等待键盘输入 给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来。waitkey(0)，永远等待另外我们也可使用matplotlib对图像进行展示。 保存图像1cv.imwrite(&quot;文件名&quot;， 图片变量) 总结： 12345678910import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt#读取图像img = cv.imread(&#x27;1.png&#x27;,1)# 利用opencv展示图像cv.imshow( &#x27; image&#x27;, img)k = cv.waitKey(0)# 3 保存图像cv.imwrite( &#x27;messigray.png&#x27;,img) course_1code123456789101112131415161718192021222324252627# 学习了基本操作，imread(), imwrite()等import cv2 as cv# 获取摄像头cap = cv.VideoCapture(0)# set the height(3) and width(4) of the windows# windows系统下，微软surface的系统摄像头，该设置失效，原因未明# 外置摄像头OKcap.set(3, 640)cap.set(4, 480)# set brightness# 但好像也没什么用cap.set(10, 0.00001)while True: success, img = cap.read() cv.imshow(&quot;camera&quot;, img) if cv.waitKey(1) == ord(&#x27;Q&#x27;) or cv.waitKey(1) == 27: # 当所有事完成，释放 VideoCapture 对象 cap.release() cv.destroyAllWindows() break 详解1234cap = cv.VideoCapture(2)VideoCapture()中参数是0，表示打开笔记本的内置摄像头，参数是视频文件路径，打开方式如下：cap = cv2.VideoCapture(“../test.avi”) 12success, img = cap.read()cap.read()按帧读取视频，ret,frame是获cap.read()方法的两个返回值。 其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就为False。frame就是每一帧的图像，是个三维矩阵。 1234waitKey（）方法本身表示等待键盘输入，参数是1，表示延时1ms切换到下一帧图像。对于视频而言；参数为0，如cv2.waitKey(0)只显示当前帧图像，相当于视频暂停；参数过大如cv2.waitKey(1000)，会因为延时过久而卡顿感觉到卡顿。c得到的是键盘输入的ASCII码，esc键对应的ASCII码是27，即当按esc键是if条件句成立 course_2code1234567891011121314151617181920212223242526272829303132333435import cv2 as cvimport numpy as npaaa = np.ones((5, 5), np.uint8)# cv.imread(&quot;路径&quot;， 参数)，参数不传，默认参数1img = cv.imread(&quot;img/1 (1).jpg&quot;)# cv2.namedWindow(‘窗口标题’,默认参数) 创建新窗口cv.namedWindow(&#x27;Local Camera&#x27;, 0)# 设置显示的窗口大小为500,500，建议大于等于摄像头分辨率cv.resizeWindow(&quot;Local Camera&quot;, 300, 300)cv.imshow(&quot;Local Camera&quot;, img)# 灰度图片imgGray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)cv.imshow(&quot;show imgGray&quot;, imgGray)# 高斯模糊imgBlur = cv.GaussianBlur(img, (7, 7), 0)cv.imshow(&quot;show imgBlur&quot;, imgBlur)# 边缘检测imgCanny = cv.Canny(img, 150, 200)cv.imshow(&quot;show imgCanny&quot;, imgCanny)# 膨胀imgDilation = cv.dilate(imgCanny, aaa, iterations=1)cv.imshow(&quot;show imgDilation&quot;, imgDilation)# 腐蚀imgErode = cv.erode(imgDilation, aaa, iterations=1)cv.imshow(&quot;show imgErode&quot;, imgErode)cv.waitKey(0) course_3学习图像像素查看，图片大小调整，图片裁剪 opencv的X,Y的位置 code12345678910111213141516171819202122232425import cv2 as cvimport numpy as npimg = cv.imread(&quot;img/1 (1).jpg&quot;)print(img.shape)print(img.shape[0])# 打印出(1526, 1080, 3)# 打印出的分别是，高，宽，BGR# 图像大小调整，参数为宽，高a = int(img.shape[1]*0.3)b = int(img.shape[0]*0.3)imgResize = cv.resize(img, (a, b))print(imgResize.shape)# 图像裁剪 高与宽imgCropped = img[0:400, 200:400]cv.imshow(&quot;LOCAL img&quot;, img)cv.imshow(&quot;LOCAL imgResize&quot;, imgResize)cv.imshow(&quot;LOCAL imgCropped&quot;, imgCropped)cv.waitKey(0) course_4 绘画12345678910111213141516171819202122import cv2 as cvimport numpy as np# 0为黑，1为白img = np.zeros((400, 400))img1 = np.zeros((400, 400, 3))imgBlue = img1.copy() # 令imgBlub = img，则会报错，img为二维数组，只有黑白imgBlue[:] = 255, 0, 0# 划线，参数1,图片，参数2，起始点,参数3，终止点，参数4，color 参数5，厚度cv.line(img1, (0, 0), (400, 250), (255, 255, 255), 1)# 画矩形，参数配置同上,参数5也可用cv.FILLED,填充cv.rectangle(img1, (0, 0), (400, 200), (255, 255, 0), 2)# 画圆cv.circle(img1, (200, 70), 30, (255, 255, 100), cv.FILLED)cv.imshow(&quot;img&quot;, img)cv.imshow(&quot;img2&quot;, img1)cv.imshow(&quot;imgBlue&quot;, imgBlue)cv.waitKey(0) course_5 透视变换12345678910111213141516import cv2 as cvimport numpy as np# 矩阵变换width, height = 250, 350img = cv.imread(&quot;img/1 (15).png&quot;)pts1 = np.float32([[108, 240], [276, 209], [150, 491], [342, 451]])pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])matrix = cv.getPerspectiveTransform(pts1, pts2) # 获得透视矩阵out_img = cv.warpPerspective(img, matrix, (width, height)) # 透视cv.imshow(&quot;local img&quot;, img)cv.imshow(&quot;out_img img&quot;, out_img)cv.waitKey(0) 解析cv2.getPerspectiveTransform()是一个OpenCV函数，用于获取透视变换矩阵。它需要两个参数，分别是源图像中待测矩形的四点坐标和目标图像中矩形的四点坐标。它返回一个3x3的变换矩阵，可以用于cv2.warpPerspective()函数进行透视变换。 1234567891011121314import cv2import numpy as np# 定义源图像中待测矩形的四点坐标pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])# 定义目标图像中矩形的四点坐标pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])# 获取透视变换矩阵M = cv2.getPerspectiveTransform(pts1, pts2)# 输出变换矩阵print(M) 输出为 123[[ 8.24482681e-01 -1.02318154e-01 -3.33674687e+01] [ 1.18180922e-01 9.43895645e-01 1.17818491e+01] [ 1.65498408e-04 -1.69338403e-04 1.00000000e+00]] warpPerspective()函数主要作用：对图像进行透视变换，就是变形cv.warpPerspective是OpenCV中的一个函数，主要用于对图像进行透视变换。它可以将原始图像中的任意四边形区域转换为目标图像中的矩形区域，从而实现图像的透视变换。该函数的语法如下： 1dst = cv.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) 其中，参数含义如下：src：输入图像，可以是8位无符号整数、32位浮点数或16位有符号整数。M：3x3变换矩阵。dsize：输出图像的大小。dst：输出图像，与输入图像具有相同的数据类型和通道数。flags：插值方法的标志，可以是cv2.INTER_NEAREST、cv2.INTER_LINEAR、cv2.INTER_CUBIC、cv2.INTER_AREA、cv2.INTER_LANCZOS4等。borderMode：边界填充模式，可以是cv2.BORDER_CONSTANT、cv2.BORDER_REPLICATE、cv2.BORDER_REFLECT、cv2.BORDER_WRAP等.borderValue：边界填充值。","tags":["opencv"]},{"title":"linux系统学习","path":"/2023/10/10/linux系统学习/","content":"计算机硬件结构冯 诺依曼结构 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 其他主流计算机硬件结构 哈佛体系 计算机之父 冯 诺依曼图灵 计算机硬件组成输入设备输出设备存储器RAMRAM(random access memory) 即随机存储内存 速度快，容量小 掉电易失 逻辑IO ROMROM (Read-Onboy Memory) 即只读内存硬盘 容量大，速度相对较慢 长久保存 物理10 运算器、控制器网络连接 ip地址 子网掩码 默认网关 DNS ip地址IPADDRip地址 &#x3D; 网络地址+主机地址ip地址是一个4*8bit由0&#x2F;1组成的字符串（ip4协议） 子网掩码","tags":["linux"]},{"title":"arduino的系统学习","path":"/2023/09/29/arduino的系统学习/","content":"我还是决定系统学一下arduino，虽然系统学，但仍是速成，由于碰到一些事情我意识到自己还不够努力，就从arduino开始吧 arduino IDE下载 www.arduino.cc arduino uno引脚图 Arduino UNO是基于ATmega328P的Arduino开发板。它有14个数字输入&#x2F;输出引脚（其中6个可用于PWM输出）、6个模拟输入引脚，一个16 MHz的晶体振荡器，一个USB接口，一个DC接口，一个ICSP接口，一个复位按钮。它包含了微控制器所需的一切，你只用简单地把它连接到计算机的USB接口，或者使用AC-DC适配器，再或者用电池，就可以驱动它。 存储空间ATmega328 有32KB Flash存储空间（其中0.5KB被用于存储bootloader），2KB 的SRAM和1KB 的EEPROM。可以使用官方提供的EEPROM库读写EEPROM空间。 输入输出Arduino Uno有14个数字输入输出引脚，可使用 pinMode()、digitalWrite() 和 digitalRead() 控制。其中一些带有特殊功能，这些引脚如下 Serial0（RX）、1（TX），被用于接收和发送串口数据。这两个引脚通过连接到ATmega16u2来与计算机进行串口通信。 外部中断2、3，可以输入外部中断信号。中断有四种触发模式：低电平触发、电平改变触发、上升沿触发、下降沿触发。 PWM输出：3、5、6、9、10、11，可用于输出8-bit PWM波。对应函数 analogWrite() 。 SPI：10（SS）、11（MOSI）、12（MISO）、13（SCK），可用于SPI通信。可以使用官方提供的SPI库操纵。 L-LED：13。13号引脚连接了一个LED，当引脚输出高电平时打开LED，当引脚输出低电平时关闭LED。 TWI：A4（SDA）、A5（SCL）和TWI接口，可用于TWI通信，兼容I²C通信。可以使用官方提供的Wire库操纵。 点亮一个LED灯点灯大师，闪亮登场LED灯正负两端会有2v的电压差 pinMode(引脚号，状态) 设置引脚模式 输出(OUTPUT) 输入(INPUT) 输入上拉模式(INPUT_PULLUP) digitalWrite(引脚号,状态); 引脚输出状态 HIGH(高电平) LOW(低电平) 上拉电阻arduino开发板上拉电阻10K 引脚悬空引脚设置成INPUT却没有加任何电路，引脚检测状态不定（0&#x2F;1） 123456789//点亮二号引脚void setup() &#123; pinMode(2,OUTPUT);&#125;void loop() &#123; digitalWrite(2,HIGH);&#125; 串口通信digitalRead(引脚号)读取某个引脚状态，常与pinMode(引脚号,INOUT)搭配使用 Serial.begin(9600);串口初始化设置9600为常用波特率 Serial.println(打印内容);在电脑的串口监视器上输出相应内容 delay(时间)延时函数，单位为ms 12345678910void setup() &#123; pinMode(2,INPUT); Serial.begin(9600);&#125;void loop() &#123; int buttonState = digitalRead(2); Serial.println(buttonState); delay(1);&#125; 模拟输出标有~的数字引脚可输出PWM信号 analogWrite(Pin,bringtness)模拟输出，Pin,引脚号; brigngness为亮度范围0~255,输出的为Pwm信号，PWM信号的频率大约为490Hz.在Arduino UNO控制器中，5号引脚和6号引脚的PWM频率为980Hz。 呼吸灯（周期未测）12345678910111213141516void setup() &#123; Serial.begin(9600);&#125;void loop() &#123;for (int brightness = 0;brightness &lt;= 255;brightness+=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;for (int brightness = 255;brightness &gt;= 0;brightness-=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;&#125; 模拟输入电位器 ananaloRead(Pin)读取范围0-5v,返回0~1023的数值，读入的最大频率为10 000次，引脚悬空状态读的数值不定 变量B &#x3D; map(变量A,A_min,A_max,B_min,B_max)将变量A等比映射到变量B 1234567891011void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; int a = map(analogRead(A0),0,1023,0,255); Serial.println(a); delay(10);&#125; 电机驱动电机种类 直流电机(DC) 交流电机(AC) 交直流两用电机(Universal) 使用arduino的引脚直接驱动直流电机简直蠢爆了，引脚输出电流不够,pwm给小了根本不动，当然，这里只是验证analogWrite是PWM信号，周期490Hz 12345678void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; analogWrite(9,200);&#125; 舵机驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 12345678910111213141516171819202122232425262728293031323334353637383940/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 步进电机驱动步进电机优点 精准控制电机输出轴角度 低速运行时扭矩大 开环控制&#x2F;性价比高 步进电机的分类 单极性步进电机 5-6条引脚，相对输出扭矩低，控制简单 双极性步进电机 4条引脚，相对输出扭矩高，控制复杂 步进电机的参数 额定电流 额定电压 定位转矩 不通电 保持转矩 通电 相数 可独立通电的定子电磁线圈数步进电机详解 http://t.csdnimg.cn/TkxCb","tags":["arduino"]},{"title":"gazebo的学习与应用","path":"/2023/09/26/gazebo的学习与应用/","content":"学习目标与任务 Gazebo和环境模型设计 机器人模型设计 为模型上装备传感器与执行器 https://gazebosim.org/docs","tags":["ros"]},{"title":"基于古月居的ros入门","path":"/2023/09/21/基于古月居的ros入门/","content":"前言由于前段时间的学习总结的习惯不好，决定新开一栏用于ros基础学习。有一说一，通过和学长的进度比较，总感觉自己是个废物。 虚拟机的安装不要装机械盘，运行慢。使用VMwareubantu系统18 linux基本命令行123456789101112cdlsmvrm -rcppwdmkdirtouchshutdown -h nowrebootsudo 基本命令行12sudo apt-get update //更新源source ~/catkin_ws/devel/setup.bash //刷新环境变量 前置安装123456789//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim//ros安装wget http://fishros.com/install -O fishros &amp;&amp; . fishros ros的核心概念节点（node）与节点管理器（ros master）节点名称唯一 话题(topic)与服务(serve) 话题：单向 发布者 订阅者 消息(massage):话题的数据由.msg文件定义 服务：双向 客户端 服务端 .srv文件定义命名请求应答数据 参数(parameter)—全局共享字典适合静态，非二进制的配置参数 文件系统 功能包（package） ：含节点源码，配置文件，数据定义 功能包清单： 作者信息，许可信息，依赖选项 元功能包：组织多个同一目的的功能包 ros命令行工具123456rostopicrosservicerosnoderosparamrosmsgrossrv 小海龟123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 工具123456789rqt_graph //节点可视化rosnode //显示节点rostopic //话题 pubrosmsgrosservice //服务 callrosbag record -a -O cmd_record //话题记录 cmd_record位保存文件名，默认hom目录下rosbag play cmd_record.bag //话题复现 ros的文件结构 1234567891011121314151617181920212223242526272829303132WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 创建工作空间123456789101112131415//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_makecatkin_make install //可要可不要//设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash 问题：我需要在原有的ROS工程基础之上，新建一个ROS功能包。我直接复制了其他目录下原有的一个包，进行修改。然后问题来了：catkin_make后竟然没有反应。甚至没有检测到我新改写的cmake 解决：ros允许多个工作空间使用相同功能包，但多个工作空间source不要放在脚本里，手动敲，否则会被覆盖,在catkin_make之前source一下，之后再source一下。而且要多次执行，如下。注意要先开下roscore，py文件要给其可执行权限. 123456//将文件复制过来后，在工作空间目录下打开终端source ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bash 脚本文件的source只在新的终端开启时才运行 发布者与订阅者以海龟为例 python文件要记得给可执行权限 发布者123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher():\t# ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True)\t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)\t#设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 订阅者123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber():\t# ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True)\t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)\t# 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 消息的自定义定义msg文件在功能包的src同级目录下创建msg文件夹12345678910// 举例，该文件名为Person.msgstring nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 launch文件使用 launch 文件，可以一次性启动多个 ROS 节点launch文件自动启动ROS Master 123456789101112131415161718192021&lt;!-- 包名 节点名称 自定义节点名 --&gt;&lt;!-- 注释 --&gt;&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt; &lt;!-- 参数设置 --&gt; &lt;param name=&quot;output_feame&quot; value=&quot;odom&quot;/&gt; &lt;!-- name:参数名称，value 参数值 --&gt; &lt;rosparam= file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!-- 重映射remap --&gt; &lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt; &lt;!-- from:原名 to:映射后的名字 --&gt; &lt;!-- 嵌套include --&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 客户端与服务端客户端 rosservice call &#x2F;clear “{}” 参数的使用parameter Server 全局变量存储空间 123456789101112// 列出当前有多个参数rosparam list// 显示某个参数值rosparam get param_key// 设置某个参数值rosparam set param_key param_value//保存参数到文件rosparam dump file_name// 从文件读取参数rosparam load file_anme// 删除参数rosparam delete param_key yaml 参数文件在程序里实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config():\t# ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True)\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;);\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() TF坐标管理系统tf功能包，默认10秒 实现机制 广播TF变换 监听TF变换12345678//安装功能包sudo apt-get install ros-melodic-turtle-tf//启动节点roslaunch turtle tfturtle tf demo.launch//turtles键盘控制节点rosrun turtlesim turtle teleop_key//保存tf tree为 pdf 至当前目录rosrun tf view frames tf工具 命令行工具rosrun tf tf_echo turtle1 turtle2 可视化工具 rosrun rviz rviz -d rospack find turtle tf &#x2F;rviz&#x2F;turtle rviz.rviz tf坐标的广播与监听单词释义quaternion 四元数radian 弧度degree 角度 常用可视化工具QT工具箱 日志输出rqt_console 计算图ret_graph 数据绘图rqt_plot 图像渲染rqt_image_view rviz gazebo 进阶 控制与仿真 gazebo + ros +ros_control","tags":["ros"]},{"title":"stc驱动TM1608","path":"/2023/09/16/stc驱动TM1608/","content":"tm1638.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef _TM1638_H#define _TM1638_H#include &lt;STC32G.H&gt;//TM1638模块引脚定义sbit DIO=P1^3; //数据线sbit CLK=P1^0; //时钟线sbit STB=P1^1; //片选线//共阴数码管显示代码unsigned char code dis[11]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x00&#125;; unsigned char while_one[8]=&#123;0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce&#125;;void TM1638_Write(unsigned char Data) //写数据函数&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; CLK=0; DIO=Data&amp;0x01; Data&gt;&gt;=1; CLK=1;\t&#125;&#125;void Write_Command(unsigned char Command) //发送命令&#123;\tSTB=0;\tTM1638_Write(Command);\tSTB=1;&#125;void Write_Data(unsigned char add,unsigned char Data) //指定地址写入数据&#123;\tSTB=0;\tTM1638_Write(0x00|add);\tTM1638_Write(Data);\tSTB=1;&#125;//TM1638初始化函数void init_TM1638(void)&#123;\tunsigned char i;\tWrite_Command(0x8F); Write_Command(0x40); //采用地址自动加1\tSTB=0; TM1638_Write(0xc0); //设置起始地址\tfor(i=0;i&lt;16;i++) //传送16个字节的数据 TM1638_Write(0x00);\tSTB=1;&#125;#endif tm1638.c 123456789101112131415161718192021#include &lt;STC32G.H&gt;#include &quot;tm1638.h&quot;void TMmain(void)&#123; unsigned char i;\tP0=0xff;P2=0x80;P2&amp;=0x1f; P0=0;P2=0xa0;P2&amp;=0x1f; //关闭单片机LED、蜂鸣器、继电器，主要是刺眼。。。 init_TM1638(); //初始化TM1638\tfor(i=0;i&lt;8;i++)\tWrite_Data(i,dis[10]); //初始化寄存器\twhile(1)\t&#123; Write_Data(while_one[0],dis[6]); //选中GRID1，令第一位数码管显示0\t&#125;&#125;","tags":["单片机"]},{"title":"stc32学习","path":"/2023/09/14/stc32学习/","content":"时隔三月，再摸单片机，这一次我要把遗忘的全部拿回来 STC32介绍 STC I&#x2F;O口工作模式 除了P3.0和P3.1（准双向口）外，其他默认高阻输入模式准双向口和推挽输出模式默认为高电平 define和typedef12typedf unsigned char u8;给已存在的数据类型起别名 WTST程序读取等待控制寄存器，上电默认为70-255 volatile设置变量，防止优化 预编译处理12345678910//主要命令有#include#ifndef //如果宏未定义则执行#define //定义宏#endif //结束有if的定义#elif#undef // 取消已定义的宏#line#program#error 模块化编程思想 移位法点亮LED 1234567while(1)&#123; for(i = 0;i &lt; 8; i++) &#123; P2 = ~(0x01 &lt;&lt; i); delayms(500); &#125;&#125; 上拉电阻和下拉电阻所有IO口都配置了一个4.1K的上拉电阻和10K的下拉电阻都是8位寄存器上拉电阻控制寄存器：PxPU上拉电阻控制寄存器：PxPD(x &#x3D;0,1,2,3,4,5,6,7) 123456789P7M1 = 0xFF;P7M0 = 0x00; //高阻输入模式EAXFR = 1; //使能XFR,特殊寄存器，设置使之能访问while(1)&#123; P7PU = 0x01; //加上拉电阻等于准双向口模式 delayms(1000); P&amp;PD = 0x00; delayms(1000);&#125; 自适应delayms()函数12345678#define MAIN_Fose = 35000000 //设置主频void delayms(int ms)&#123; int i; do&#123; i = MAIN_Fose/6000; while(i--); &#125;while(--ms);&#125; 特殊功能寄存器（SFR，XFR） 地址范围0x7E0000-0x7EFFF如需访问扩展寄存器，需先设置SFR使能寄存器CKCON 外部数据总线时钟控制寄存器CKCON &#x3D; 0x00;(上电默认为7，建议设为0) 74HC595独立按键定时器与计数器5个24位定时器&#x2F;计数器（八位预分频+16位计数）","tags":["单片机"]},{"title":"python study","path":"/2023/08/10/python-study/","content":"python规范 结尾空一行 导入库空两行 注释# 空一格 Python库的安装1pip install 库名 Python的导包方式12345678910111213# 1.import 常规导入，直接导入整个包的所有的功能函数##eg# 2.import多个导入，导入多个包的所有功能函数。##eg# 3.from … import …导入整个包的部分功能函数。##eg# 4.当然也可以通过from … import * 这个也是直接导入包的所有功能。相当于import … 重要的，在实际的应用中用得也是比较多的，我们自定义我们自己写的功能包。第一：在test_package文件夹中创建_init_.py文件，里边什么都不需要编辑。第二：在代码中把test_package的文件的路径加入到python解释器可以搜索到的路径列表中，这里就用到了python的包sys模块。下边是运行过一次的目录结构：pyc文件是py文件编译后生成的字节码文件，不需要自己创建，在你第一次成功导入包并运行成功之后会自动生成。 自定义导包 https://blog.csdn.net/weixin_45577864/article/details/121714956?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-121714956.nonecase&amp;spm=1018.2226.3001.4187","tags":["python"]},{"title":"links","path":"/2023/07/30/links/","content":"图标 介绍 网址 triority’s blog https://triority.cn/ 天鹅绒房间 https://qwqpap.xyz/ 北矿3D打印社 https://cumtb.club/"},{"title":"arduino小项目2——电压表","path":"/2023/07/30/arduino小项目2——电压表/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕，小按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V; void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; float a = Voltage_detect(); displayMenu(a);&#125; //oled屏幕显示void displayMenu(float a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); u8g2.print(&quot;Voltage, (0-5v)&quot;); // 显示电压表... u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.setCursor(20, 34); u8g2.println(a); u8g2.sendBuffer();&#125; //检测并转化为0-5vfloat Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); //读取io口模拟值 float Voltage = analogdate*5.0/1023.0; //转化 //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); //串口打印 &#125; else Serial.println(Voltage); return Voltage; //返回值&#125; 本来想弄万用表来着，emmp,放弃了,没写完，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int gear = 0; // 万用表状态 0.菜单；1.电压表；2.电流表；3.电阻表int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V;int R_I=220; // 电流表状态，电阻为220欧姆 void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; double a = Voltage_detect(); switch1(); displayMenu(a); int analogdate = analogRead(A0); &#125; void switch1() &#123; int key = digitalRead(2); // 第一次判断 if (key == 0) &#123; // 延时20ms 消除按键抖动 delay(20); // 第二次判断 if (key == 0) &#123; gear++; // 状态++ if (gear &gt; 3) &#123; gear = 0; // 循环到第一个菜单状态 &#125; &#125; // 等待按键被松开 while (!digitalRead(2)) &#123; // 等待按键松开 &#125; &#125;&#125; void displayMenu(double a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); switch (gear) &#123; case 0: //u8g2.print(&quot;Menu&quot;); // 显示菜单选项... face(); break; case 1: u8g2.print(&quot;Voltage&quot;); // 显示电压表... u8g2.setCursor(20, 34); u8g2.println(a); break; case 2: u8g2.print(&quot;Current&quot;); // 显示电流表... break; case 3: u8g2.print(&quot;Resistance&quot;); // 显示电阻表... break; &#125; u8g2.sendBuffer();&#125; void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; float Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); float Voltage = analogdate*5.0/1023.0; //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); &#125; else Serial.println(Voltage); return Voltage;&#125;","tags":["arduino"]},{"title":"arduino小项目1——小时钟","path":"/2023/07/30/arduino小项目1——小时钟/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕 接线图，文字描述。单片机上的A4接小屏幕上的SDA，A5接SCL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;MsTimer2.h&gt;#include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int year = 2020, month = 1, day = 1, hour = 0, minute = 0, second = 0; void onTimer() &#123; second++; if (second &gt;= 60) &#123; second = 0; minute++; if (minute &gt;= 60) &#123; minute = 0; hour++; if (hour &gt;= 24) &#123; hour = 0; &#125; &#125; &#125;&#125; void setup() &#123; Serial.begin(9600); u8g2.begin(); u8g2.clearBuffer(); MsTimer2::set(1000, onTimer); // 中断时间为1秒 MsTimer2::start(); // 启动定时器&#125; void loop() &#123; displayTime();&#125; void displayTime() &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.drawStr(0, 15, &quot;TIME:&quot;); u8g2.setFont(u8g2_font_ncenB12_tr); char strTemp[12]; sprintf(strTemp, &quot; %d.%.2d.%.2d&quot;, year, month, day); u8g2.drawStr(35, 15, strTemp); u8g2.setFont(u8g2_font_ncenB14_tr); sprintf(strTemp, &quot;%.2d.%.2d.%.2d&quot;, hour, minute, second); u8g2.drawStr(25, 45, strTemp); u8g2.sendBuffer();&#125;","tags":["arduino"]},{"title":"markdown基本介绍与语法","path":"/2023/07/26/markdown基本介绍与语法/","content":"markdown是什么？Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等 我为什么使用markdown写个人博客需要，且markdown使用简单，b站搜索十分钟学会，word无法完成个人博客的书写.markdown和word可相互转化,但效果不好，排版问题较大。markdown无法实现精细排版要求。 在线编译器网址https://markdown.com.cn/editor/在线转化器网址https://www.easeconvert.com/markdown-to-word/ 基本语法12345678910111213141516171819202122232425262728293031323334353637383940——————标题——————# 一级标题## 二级标题### 三级标题...###### 六级标题——————字体———————**这个是粗体***这个是斜体****这个是粗体加斜体***~~这里想用删除线~~--- 分割线——————列表———————无序列表的使用，在符号`-`后加空格使用有序列表的使用，在数字及符号`.`后加空格后输入内容——————图片———————使用符号&gt;&gt; 引用内容——————表格———————可以使用冒号来定义表格的对齐方式，如下：| 姓名 | 年龄 | 工作 || :----- | :--: | -------: || 小可爱 | 18 | 吃可爱多 || 小小勇敢 | 20 | 爬棵勇敢树 || 小小小机智 | 22 | 看一本机智书 |——————链接———————[描述](链接)——————图片———————&#123;% image 链接 %&#125;——————代码———————```语言代码块``` (占位，不管) 笔记over","tags":["markdown"]},{"title":"ros车基本学习（基于讯飞车）","path":"/2023/07/24/ros车基本学习/","content":"ros是什么（个人理解）ros是个机器人操作系统，可以在上面实现对机器人的操作，好比一个工作台，别人给你造好，直接使用上面的工具方便造自己的作品. 我为什么学ROS竞赛需要,智能车讯飞比赛及人工智能比赛甚至电赛控制类赛题也能用到 节系统是乌班图18的系统。 123456//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim 代码运行实例（c++） 123456789101112//终端输入，在主目录下创造一个test的文件夹。mkdir test//创建一个名为hello的点cpp文件。touch hello.cpp//在文件中写入内容//写完后保存关闭//打开终端输入,编译C加加文件g++ hello.cpp -o hello//执行可执行文件。./hello//同理。执行python文件python hello.py ros安装 1234567891011121314151617181920//添加ros软件源sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; //添加密匙sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 //安装rossudo apt updatesudo apt install ros-melodic-desktop-full //初始化rosdepsudo rosdep initrosdep update //设置环境变量echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc //安装rosinstallsudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 鱼香ros一键安装 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 小乌龟实例 123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 创建工作空间 1234567891011121314//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_make //设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译 12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs geometry_msgs turtlesim //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash C++编译配置&lt;cmakelists.txt&gt;12add_executable($&#123;PROJECT_NAME&#125;_node src/my_package_name_node.cpp)target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;)自定义消息1.在功能包文件夹内创建msg文件夹，并新建Person.msg文件，在里面写入 1234567string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 2.在package.xml文件内添加依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.在CMakeLists.txt内加入： 123456789 add_message_files( FILES Person.msg) generate_messages( DEPENDENCIES std_msgs)并把1# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim改为1CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime系统关机及重启 1234//关机shutdown -h now//重启sudo reboot ctrl all+T打开新的终端 摄像头参数命令1qv4l2 launch文件启动rviz每次启动rviz都要设置订阅的话题、点云大小等等机械化的设置，为了方便快捷的操作，把rviz的设置写入launch文件内，就可以一键启动了。1.先启动需要运行的节点，再启动一个rviz；2.设置好订阅的话题、点云大小、坐标轴等需要用到的设置3.点击左上角的file，选择另存为到一个指定地址(功能包文件夹下创建config文件夹，rviz配置文件放里面)；4、写入launch文件 1234&lt;launch&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find my_package)/config/path_to_your_rviz_config_file.rviz&quot; /&gt;&lt;/launch&gt; 其中 find my_package 为你的功能包名，path_to_your_rviz_config_file.rviz为rviz文件名","tags":["ros"]},{"title":"我的技术栈","path":"/2023/07/24/我的技术栈/","content":"我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32(未学) stm32(未学) 网络基础 树莓派(未学) 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的个人博客联系邮箱：&#51;&#51;&#49;&#49;&#x37;&#48;&#52;&#x35;&#x30;&#57;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d; 姓名：李无忧爱好：睡觉和吃饭以及听音乐性格：温和喜静理想：实现共产主义，追求社会公平讨厌的事：被他人意志所裹挟擅长的事：模仿与学习 为什么写博客？ 主要原因有二个方面吧，首先呢，记录学习状态。学习的时候很多代码确实很难记住，知道怎么用就好了，必要的时候翻翻个人博客就可以找到。然后吧，记录生活日常。当然这个可能比较少。 我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32(未学) stm32(未学) 网络基础 树莓派(未学) 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"成就","path":"/achievement/index.html","content":"学科竞赛 第十七届智能车室外组ROS 省二（首座） 第十八届智能车室外组ROS 国一（首座） 第十八届智能车讯飞创意组 国一 第二十五届中国机器人及人工智能大赛 国二（首座） 2023全国大学生电子设计大赛 省三 学校奖励 2023年校级三等奖学金 学院新生辩论赛一等奖 优秀团员"}]