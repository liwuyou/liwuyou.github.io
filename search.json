[{"title":"python考试的基础知识","path":"/2025/03/28/python考试的基础知识/","content":"前言计算机二级真是米奇妙妙屋，考了我几乎不会用到的知识点和一些操作,补充知识了 python的异常处理使用 try-except 语句来捕获和处理运行时错误，并可以在 finally 代码块中执行清理操作。 捕获多个异常12345try: lst = [1, 2, 3] print(lst[5]) # 触发 IndexErrorexcept (IndexError, ZeroDivisionError) as e: print(f&quot;发生错误：&#123;e&#125;&quot;) 3. 捕获所有异常1234try: x = 10 / 0except Exception as e: print(f&quot;捕获所有异常：&#123;e&#125;&quot;) 🔹 解释： Exception 是所有异常的基类，捕获任何异常。 不推荐滥用 Exception，因为可能忽略关键错误。 4. 使用 finally 语句1234567try: file = open(&quot;test.txt&quot;, &quot;r&quot;) data = file.read()except FileNotFoundError: print(&quot;文件未找到！&quot;)finally: print(&quot;无论是否发生异常，都会执行此处&quot;) 🔹 finally 语句的作用： 无论是否发生异常，finally 块的代码都会执行（比如关闭文件、释放资源等）。 5. 使用 else 语句1234567try: num = int(input(&quot;输入一个数字: &quot;)) result = 100 / numexcept ZeroDivisionError: print(&quot;不能除以零！&quot;)else: print(f&quot;计算结果: &#123;result&#125;&quot;) 🔹 else 语句的作用： 只有在 try 代码块无异常时才执行（适用于有可能引发异常但希望后续代码不受影响的情况）。 6. 自定义异常12345678910class MyError(Exception): &quot;&quot;&quot;自定义异常类&quot;&quot;&quot; def __init__(self, message): self.message = message super().__init__(message)try: raise MyError(&quot;这是一个自定义异常&quot;)except MyError as e: print(f&quot;捕获到异常: &#123;e&#125;&quot;) 🔹 解释： raise MyError(&quot;错误信息&quot;) 主动抛出异常。 MyError 继承 Exception，定义自定义异常类型。 7. raise 关键字123456try: age = int(input(&quot;请输入年龄: &quot;)) if age &lt; 0: raise ValueError(&quot;年龄不能为负数&quot;)except ValueError as e: print(f&quot;异常: &#123;e&#125;&quot;) 🔹 解释： raise 用于手动抛出异常。 总结 语法 作用 try-except 捕获异常，避免程序崩溃 except Exception as e 获取异常信息 except (TypeError, ValueError) 捕获多个异常 else 只有 try 代码块没有异常时才执行 finally 无论是否异常都会执行（释放资源） raise 主动抛出异常 自定义异常 继承 Exception，创建自己的异常类 python的异常处理类型以下是 Python 常见 的异常，按类别精简整理： 异常类型 说明 ZeroDivisionError 除数为零，如 10 / 0 ValueError 传入无效参数，如 int(&quot;abc&quot;) TypeError 数据类型错误，如 &quot;abc&quot; + 123 IndexError 列表索引越界，如 lst[10] KeyError 字典键不存在，如 dict[&quot;missing_key&quot;] AttributeError 访问对象不存在的属性，如 &quot;abc&quot;.no_method() NameError 变量未定义，如 print(undeclared_var) FileNotFoundError 文件未找到，如 open(&quot;missing.txt&quot;) IOError I&#x2F;O 读写错误 ImportError 模块导入失败，如 import nonexistent_module RuntimeError 运行时错误的通用异常 SyntaxError 代码语法错误 IndentationError 缩进错误 KeyboardInterrupt 用户手动终止程序（Ctrl + C） 这些是开发过程中最常见的异常类型，掌握它们可以更好地进行异常处理！ 字符串的操作123456s = &quot;apple&quot;print(s[:-1]) # 输出applprint(s[:-1:]) # 输出applprint(s[:4]) # 输出applprint(s[:5]) # 输出appleprint(s[:6]) # 输出apple 123456s = &quot;banana&quot;print(s[::-1]) # 输出ananab,逆向print(s[:-1:-1]) # 输出为空行print(s[:-1:2]) # 输出为bnnprint(s[:5:2]) # 输出bnnprint(s[:6:-2]) # 输出为空行 s[start:end] 不包含 end 位置的字符。 s[::-1] 倒序字符串。 start、end 和 step 的方向要匹配，否则会返回空字符串。 random库 函数 作用 random.random() 生成 0 ~ 1 的随机小数 random.uniform(a, b) 生成范围 [a, b] 内的随机小数 random.randint(a, b) 生成范围 [a, b] 内的随机整数 random.randrange(a, b, step) 生成 a 到 b 之间步长为 step 的随机整数 random.choice(seq) 随机选择一个元素 random.choices(seq, k=n) 选择 k 个元素（可重复） random.sample(seq, k=n) 选择 k 个不重复元素 random.shuffle(seq) 打乱序列顺序 random.choice([True, False]) 生成随机布尔值 random.randbytes(n) 生成 n 个随机字节 ✅ random 适用于随机抽奖、游戏随机事件、数据加密、模拟实验等场景！ 🚀 join()函数🔹 join() 函数简介join() 是 Python 字符串方法，用于将多个字符串拼接成一个字符串，适用于列表、元组、集合等可迭代对象。 🔹 语法1&quot;分隔符&quot;.join(可迭代对象) 🔹 常见用法 用途 代码示例 输出 连接列表 &quot; &quot;.join([&quot;Hello&quot;, &quot;World&quot;]) &quot;Hello World&quot; 使用 - 连接 &quot;-&quot;.join([&quot;2025&quot;, &quot;03&quot;, &quot;28&quot;]) &quot;2025-03-28&quot; 直接拼接 &quot;&quot;.join([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]) &quot;ABC&quot; 连接元组 &quot;,&quot;.join((&quot;apple&quot;, &quot;banana&quot;)) &quot;apple,banana&quot; 连接集合 &#96;” “.join({“Python”, “Java”})&#96; 连接字典键 &quot;,&quot;.join(&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: &quot;25&quot;&#125;) &quot;name,age&quot; 连接数字（错误） &quot;-&quot;.join([1, 2, 3]) ❌ TypeError 连接数字（正确） &quot;-&quot;.join(map(str, [1, 2, 3])) &quot;1-2-3&quot; 连接多行字符串 &quot; &quot;.join([&quot;第一行&quot;, &quot;第二行&quot;]) 换行显示 📌 turtle 库常用函数📌 1. 画笔移动 🎯 函数 作用 forward(n) &#x2F; fd(n) 前进 n 像素 backward(n) &#x2F; bk(n) 后退 n 像素 right(deg) &#x2F; rt(deg) 右转 deg 度 left(deg) &#x2F; lt(deg) 左转 deg 度 seth(deg) 设置画笔绝对方向（0° 右，90° 上，180° 左，270° 下） goto(x, y) 移动到 (x, y) 位置 setx(x) &#x2F; sety(y) 移动到 指定 x 或 y 坐标 home() 回到 (0,0) 初始点 📌 2. 画笔控制 ✏️ 函数 作用 pendown() &#x2F; pd() 落笔（开始画图） penup() &#x2F; pu() 抬笔（不画图移动） pensize(n) 设置画笔粗细 pencolor(&quot;red&quot;) 设置画笔颜色 speed(n) 设置绘画速度（1~10，0最快） 📌 3. 画图 🖌️ 函数 作用 circle(r) 画半径 r 的圆 dot(size, color) 画指定大小和颜色的点 begin_fill() &#x2F; end_fill() 填充颜色（需 fillcolor()） fillcolor(&quot;blue&quot;) 设置填充颜色 📌 4. 其他 🎨 函数 作用 clear() 清空画布 reset() 重置画布 hideturtle() 隐藏画笔 showturtle() 显示画笔 done() 结束绘制，窗口保持 📌 🎯 示例：画一个正方形12345678910import turtleturtle.pensize(3)turtle.pencolor(&quot;blue&quot;)for _ in range(4): turtle.forward(100) turtle.right(90)turtle.done() 一些error1234a =&quot;3.14&quot;print(int(a))# 输出不是3,而是下面的内容ValueError: invalid literal for int() with base 10: &#x27;3.14&#x27; img1 &#x3D; img2 并没有复制 img2，只是让 img1 指向 img2 的内存地址 1234567891011img1 = [&quot;123&quot;,&quot;123&quot;]img2 = [&quot;cnm&quot;,&quot;123&quot;]img1 = img2img1.append([5,6])print(img2) # 输出[&#x27;cnm&#x27;, &#x27;123&#x27;, [5, 6]]img1.append([&quot;5&quot;,&quot;6&quot;])print(img2) # 输出[&#x27;cnm&#x27;, &#x27;123&#x27;, [5, 6], [&#x27;5&#x27;, &#x27;6&#x27;]] 赋值方式 是否影响原列表 img1 = img2 ✅ 影响（指向同一块内存） img1 = img2.copy() ❌ 不影响（但嵌套列表仍会受影响） img1 = copy.deepcopy(img2) ❌ 完全不影响（独立拷贝） 选择题避坑点📌 静态语言 vs. 脚本语言（简介） 静态语言：变量类型固定，需编译后运行，速度快（如 C、C++、Java）。 脚本语言：变量类型动态，解释执行，开发效率高（如 Python、JavaScript）。🚀 总结：高性能选 静态语言，开发效率选 脚本语言。 📌 编译 vs. 解释 编译：代码先转换为机器码，再运行，速度快（如 C、C++）。源代码-&gt;目标代码 解释：代码逐行翻译并执行，开发效率高（如 Python、JavaScript）。逐条转换-&gt;逐条运行 📌 a / b vs. a // b 的区别12345a = 6b = 3print(a / b) # 2.0 （浮点除法，结果为浮点数）print(a // b) # 2 （整除，结果为整数） python的数据类型123456数字类型- 整数- 浮点数- 复数字符串类型 📌 ord() vs. chr()✅ **ord()**：返回字符的 Unicode 编码（整数）✅ **chr()**：返回 Unicode 编码对应的字符 12345print(ord(&#x27;A&#x27;)) # 65print(chr(65)) # &#x27;A&#x27;print(ord(&#x27;中&#x27;)) # 20013print(chr(20013)) # &#x27;中&#x27; 🚀 结论： ord(字符) → 获取 Unicode 码 chr(整数) → 获取对应字符 格式化输出📌 Python 格式化输出对比 🎯 方式 语法 示例 特点 % 格式化（旧） &quot;格式符&quot; % (值1, 值2, …) &quot;姓名: %s, 年龄: %d&quot; % (name, age) 旧式写法，不推荐 str.format() &quot;&#123;&#125; &#123;&#125;&quot;.format(值1, 值2) &quot;姓名: &#123;&#125;, 年龄: &#123;&#125;&quot;.format(name, age) 灵活但较冗长 f-string（推荐） f&quot;字符串 &#123;变量&#125; 其他文本&quot; f&quot;姓名: &#123;name&#125;, 年龄: &#123;age&#125;&quot; 最简洁，推荐使用 📌 eval() 函数✅ 作用：执行字符串中的Python 表达式，并返回结果。📍 示例： 1234567print(eval(&quot;3 + 5 * 2&quot;)) # 输出 13x = 10print(eval(&quot;x + 5&quot;)) # 输出 15data = eval(&quot;&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;&quot;)print(data[&quot;name&quot;]) # 输出 Alice format()1234567print(&quot;姓名: &#123;0&#125;, 年龄: &#123;1&#125;, 姓名: &#123;0&#125;&quot;.format(name, age)) # 输出: 姓名: Alice, 年龄: 25, 姓名: Aliceprint(&quot;姓名: &#123;n&#125;, 年龄: &#123;a&#125;&quot;.format(n=name, a=age)) # 输出: 姓名: Alice, 年龄: 25pi = 3.1415926535print(&quot;圆周率: &#123;:.2f&#125;&quot;.format(pi)) # 输出: 圆周率: 3.14 📌 Python format() 字符串格式化 🎯format() 方法用于格式化字符串，支持 位置参数、关键字参数 和 格式控制。 1️⃣ 基本用法1234name = &quot;Alice&quot;age = 25print(&quot;姓名: &#123;&#125;, 年龄: &#123;&#125;&quot;.format(name, age)) # 输出: 姓名: Alice, 年龄: 25 2️⃣ 位置参数12print(&quot;姓名: &#123;0&#125;, 年龄: &#123;1&#125;, 再次姓名: &#123;0&#125;&quot;.format(name, age))# 输出: 姓名: Alice, 年龄: 25, 再次姓名: Alice 3️⃣ 关键字参数12print(&quot;姓名: &#123;n&#125;, 年龄: &#123;a&#125;&quot;.format(n=name, a=age)) # 输出: 姓名: Alice, 年龄: 25 4️⃣ 格式控制 格式 作用 示例 &#123;:&gt;10&#125; 右对齐 &#39; text&#39; &#123;:^10&#125; 居中对齐 &#39; text &#39; &#123;:*^10&#125; *填充 + 居中 &#39;**text***&#39; &#123;:.2f&#125; 保留2位小数 3.14 &#123;:b&#125; 二进制 1010 &#123;:x&#125; 十六进制 a &#123;:.2%&#125; 百分比 95.00% 示例： 1234print(&quot;&#123;:*&gt;10&#125;&quot;.format(&quot;hi&quot;)) # 输出: &#x27;********hi&#x27;print(&quot;&#123;:.2f&#125;&quot;.format(3.14159)) # 输出: &#x27;3.14&#x27;print(&quot;&#123;:b&#125;&quot;.format(10)) # 输出: &#x27;1010&#x27;print(&quot;&#123;:.2%&#125;&quot;.format(0.95)) # 输出: &#x27;95.00%&#x27; 📌 print() 函数 🎯print() 是 Python 的内置函数，用于将信息输出到控制台。它常用于调试、显示结果或与用户交互。 📍 语法： 1print(*objects, sep=&#x27; &#x27;, end=&#x27; &#x27;, file=sys.stdout, flush=False) 📍 参数解释： **objects**：要输出的内容，可以是多个对象，使用逗号分隔。 **sep**：用于分隔多个对象的字符，默认为空格 &#39; &#39;。 **end**：输出的结尾字符，默认为换行符 。可以设置为其他字符。 **file**：输出目标，默认为 sys.stdout，即屏幕。如果要输出到文件，可以传递文件对象。 **flush**：是否立即刷新输出缓冲区，默认为 False。设置为 True 时，输出会立即刷新。 📌 split() 函数 🎯split() 是 Python 字符串的内置方法，用于将字符串拆分成多个子字符串，默认按空白字符（如空格、换行符）进行分割。 常见用法：12345678910text = &quot;apple,orange,banana&quot;# 默认按空格分割print(&quot;Hello World&quot;.split()) # [&#x27;Hello&#x27;, &#x27;World&#x27;]# 按逗号分割print(text.split(&#x27;,&#x27;)) # [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]# 限制分割次数print(text.split(&#x27;,&#x27;, 1)) # [&#x27;apple&#x27;, &#x27;orange,banana&#x27;] 📌 Python 字符串大小写格式化函数 🎯 函数 作用 示例 输出 upper() 转换为大写 &quot;hello&quot;.upper() &quot;HELLO&quot; lower() 转换为小写 &quot;HELLO&quot;.lower() &quot;hello&quot; capitalize() 首字母大写，其余小写 &quot;hello world&quot;.capitalize() &quot;Hello world&quot; title() 每个单词首字母大写 &quot;hello world&quot;.title() &quot;Hello World&quot; swapcase() 大小写互换 &quot;Hello World&quot;.swapcase() &quot;hELLO wORLD&quot; 示例代码1234567text = &quot;hElLo WoRlD&quot;print(text.upper()) # HELLO WORLDprint(text.lower()) # hello worldprint(text.capitalize()) # Hello worldprint(text.title()) # Hello Worldprint(text.swapcase()) # HeLLo wOrLd 这些方法适用于文本格式化、数据处理等场景。 📌 replace() 函数 🎯replace() 是 Python 字符串的内置方法，用于 替换字符串中的指定子串。 📍 语法 1str.replace(old, new, count) 📍 参数 参数 描述 默认值 old 需要被替换的子字符串 必填 new 替换后的新字符串 必填 count （可选） 替换次数，默认全部替换 None replace() 方法不会修改原字符串，而是返回一个新字符串。 📌 Unicode 编码 &amp; 进制转换内置函数 🎯Python 提供了一些 Unicode 编码 处理和 进制转换 的内置函数，常用于字符编码、数制转换等场景。 📍 Unicode 相关函数 函数 作用 示例 输出 ord(c) 获取字符的 Unicode 码点 ord(&#39;A&#39;) 65 chr(n) 将 Unicode 码点转换为字符 chr(65) &#39;A&#39; encode() 将字符串编码为字节串 &quot;你好&quot;.encode(&quot;utf-8&quot;) b&#39;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#39; decode() 将字节串解码为字符串 b&#39;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#39;.decode(&quot;utf-8&quot;) &quot;你好&quot; 📍 进制转换相关函数 函数 作用 示例 输出 bin(x) 整数 → 二进制 bin(10) &#39;0b1010&#39; oct(x) 整数 → 八进制 oct(10) &#39;0o12&#39; hex(x) 整数 → 十六进制 hex(10) &#39;0xa&#39; int(s, base) 任意进制 → 十进制整数 int(&#39;1010&#39;, 2) 10 📍 示例代码123456789# Unicode 相关print(ord(&#x27;你&#x27;)) # 20320print(chr(20320)) # 你# 进制转换print(bin(255)) # 0b11111111print(oct(255)) # 0o377print(hex(255)) # 0xffprint(int(&#x27;ff&#x27;, 16)) # 255 这些函数适用于 字符处理、数制转换、编码解码等 场景。 📌 time 库简介 🎯time 是 Python 的内置库，用于处理时间相关的操作，如获取当前时间、执行延迟、时间格式转换等。 📍 常用函数 函数 作用 示例 time() 返回当前时间的 时间戳（秒级） time.time() → 1711785600.123456 sleep(sec) 让程序暂停 sec 秒 time.sleep(2) → 暂停 2 秒 localtime(sec) 将时间戳转换为 本地时间对象 time.localtime(time.time()) gmtime(sec) 转换为 UTC 时间对象 time.gmtime(time.time()) strftime(format, t) 按格式转换时间对象为 字符串 time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) strptime(str, fmt) 将时间字符串转换为 时间对象 time.strptime(&quot;2025-03-29&quot;, &quot;%Y-%m-%d&quot;) mktime(t) 将 本地时间对象 转换为 时间戳 time.mktime(time.localtime()) 📍 示例代码1234567891011import time# 获取当前时间戳print(time.time()) # 1711785600.123456# 暂停 2 秒time.sleep(2)# 获取本地时间local_time = time.localtime()print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, local_time)) # 2025-03-29 12:34:56 time 主要用于 时间管理、计时器、日期转换等 场景。 python的数据类型📌 列表操作函数 🎯 函数 作用 append(x) 在末尾添加 元素 x extend(iter) 合并 可迭代对象 iter 到列表 insert(i, x) 在索引 i 处插入 元素 x remove(x) 删除 列表中第一个值为 x 的元素 pop(i) 删除并返回 索引 i 处的元素（默认删除最后一个） del list[i] 删除 索引 i 处的元素 del list[i:j] 删除 i 到 j-1 之间的元素 clear() 清空列表 index(x) 返回 x 第一次出现的索引 count(x) 返回 x 在列表中出现的次数 sort() 排序（默认升序，可用 reverse=True 降序） reverse() 反转列表 顺序 copy() 返回列表副本 📌 extend(iter) 📍 示例： 123456789list1 = [1, 2, 3]list1.extend([4, 5, 6])print(list1) # 输出 [1, 2, 3, 4, 5, 6]list1 = [1, 2, 3]list1.append([4, 5, 6])print(list1) # 输出 [1, 2, 3, [4, 5, 6]] ⚠ 区别：append(x) 直接添加整个对象，extend(iter) 拆开元素 依次添加！ 🚀","tags":["计算机二级"]},{"title":"线代考研","path":"/2025/03/24/线代考研/","content":"行列式的概念排列不同的元素排成一列，就称之为这n个元素的n级排列，简称为排列，记为$j_{1}j_{2}j_{3}…j_{n}$ 逆序在一个n级排列$j_1j_2\\cdots j_s\\cdots j_t\\cdots j_n$中，数$j_s$与$j_t$满足$j_s&gt;j_t$（“大前小后”），则$j_s$与$j_t$构成一个逆序。一个排列中逆序的总数称为此排列的逆序数，记为$\\tau(j_1j_2\\cdots j_n)$。 如：一个6级排列231645的逆序数为：$\\tau(231645)&#x3D;1 + 1+0 + 2+0 &#x3D; 4$123456（自然排列）的$\\tau(123456)&#x3D;0 + 0+0 + 0+0 &#x3D; 0$ 对换排列$j_1j_2\\cdots j_n$中，交换任意两个数的位置，其余不变，则称对排列作了一次对换。 奇排列，偶排列若排列$j_1j_2\\cdots j_n$的$\\tau(j_1j_2\\cdots j_n) &#x3D;$奇数，则称$j_1j_2\\cdots j_n$为奇排列 如：$\\tau(231645)&#x3D;4$，则231645为偶排列.$\\tau(123\\cdots n)&#x3D;0$，则$(123\\cdots n)$为偶排列.$\\tau(n,n - 1,\\cdots,3,2,1)&#x3D;\\frac{n(n - 1)}{2}$，其奇偶性与n有关.$\\tau(132)&#x3D;1$，则132为奇排列.$\\tau(231)&#x3D;2$，则231为偶排列. 对换一次，奇偶性改变 对角线法则 n阶行列式定义 三角形的行列式 行列式的性质1.行列式的行和列互换，行列式的值不变 2.行列式的某两行（两列）互换，值反号 若行列式有两行或两列相同，则行列式为0 3.行列式的某行（列）可以提取公因子 若行列式有行全为0则行列式的值为0 4.若行列式有两行(列)成比例，则为0 5.若行列式某行（列）元素均为两数之和，则行列式可拆分为两个简单的行列式值和 习题 行列式展开定理","tags":["考研"]},{"title":"Docker 的安装","path":"/2025/03/22/Docker-的安装/","content":"ubuntu系统docker的安装 1234567891011121314151617181920212223242526Step1：更新系统软件包sudo apt updateStep2：安装依赖包【用于通过HTTPS来获取仓库】sudo apt install apt-transport-https ca-certificates curl software-properties-commonStep3：添加Docker官方GPG密钥sudo -icurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/trusted.gpg.d/docker-ce.gpgStep4：验证sudo apt-key fingerprint 0EBFCD880EBFCD88 是公钥的指纹。执行这个命令后，系统会显示与该指纹相关的公钥信息。Step4：添加Docker阿里稳定版软件源sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;Step5：再次更新软件包sudo apt updateStep6：安装默认最新版sudo apt install docker-ce docker-ce-cli containerd.ioStep7：测试，安装好后默认启动sudo docker run hello-world如果输出“Hello from Docker!”则表示Docker已经成功安装。 大概会报错，如下，原因是国内不能直接拉取docker官网，梯子不好也不行，必须配置镜像站 root@ubuntu:~# sudo docker run hello-worldUnable to find image ‘hello-world:latest’ locallydocker: Error response from daemon: Get https://registry-1.docker.io/v2/: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).See ‘docker run –help’. 配置方法如下，网站可以换 https://www.cnblogs.com/wwkjs/p/18757415/dockerhub 123456789101112131415161718192021222324sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;registry-mirrors&quot;: [ &quot;https://docker.zhai.cm&quot;, &quot;https://a.ussh.net&quot;, &quot;https://hub.littlediary.cn&quot;, &quot;https://hub.rat.dev&quot;, &quot;https://atomhub.openatom.cn&quot;, &quot;https://docker.m.daocloud.io&quot;, &quot;https://docker.1ms.run&quot;, &quot;https://dytt.online&quot;, &quot;https://func.ink&quot;, &quot;https://lispy.org&quot;, &quot;https://docker.xiaogenban1993.com&quot;, &quot;https://docker.mybacc.com&quot;, &quot;https://docker.yomansunter.com&quot;, &quot;https://dockerhub.websoft9.com&quot; ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 1234567891011121314151617Step8：查看有哪些镜像sudo docker imagesStep9：配置用户组sudo usermod -aG docker galaxfysu - galaxfy # 刷新shell状态docker images # 验证Step10：其他docker运行命令查看状态：sudo systemctl status docker启动：sudo systemctl start docker开机自启：sudo systemctl enable docker停止：sudo systemctl stop docker其他：安装特定版dockersudo apt-cache madison docker-ce # 显示可用版本sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io # 将需要的版本替换VERSION_STRING进行安装，例如 5:20.10.17~3-0~ubuntu-focal 百度星火的安装首先，已经安装了Ubuntu系统 docker 的安装1234567891011121314151617181920212223242526更新系统软件包sudo apt update安装依赖包【用于通过HTTPS来获取仓库】sudo apt install apt-transport-https ca-certificates curl software-properties-common添加Docker官方GPG密钥sudo -icurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/trusted.gpg.d/docker-ce.gpg验证sudo apt-key fingerprint 0EBFCD880EBFCD88 是公钥的指纹。执行这个命令后，系统会显示与该指纹相关的公钥信息。添加Docker阿里稳定版软件源sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;再次更新软件包sudo apt updateStep6：安装指定版本的docker，星火需要sudo apt-get install -y docker-ce=5:19.03.15~3-0~ubuntu-focal docker-ce-cli=5:19.03.15~3-0~ubuntu-focal containerd.io# 查看docker --version 可以看到docker指定版本已经安装 百度星火1234注意很多报错是缺少文件夹，建立文件夹即可root@ubuntu:~/application-core# aem profile use sample[ERROR] 2025-03-22 14:02:42,422 [line:115] dir [] not exists![FATAL] 2025-03-22 14:02:42 update conf /apollo_workspace/profiles/sample failed 解决 1mkdir -p /profiles/sample 运行报错buildtool build -p core 1234567891011121314151617181920212223242526[buildtool] 2025-03-22 13:08:14 INFO Download the latest package index to construct a local database...[buildtool] 2025-03-22 13:08:17 INFO update repo apollo-tools[buildtool] 2025-03-22 13:08:17 INFO update repo apollo-core-jammy[buildtool] 2025-03-22 13:08:17 INFO update repo apollo-coreTraceback (most recent call last): File &quot;/usr/bin/buildtool&quot;, line 107, in check_version_available update_pkg_version_available(VERSION_AVAILABLE_CHECK_PATH, code) File &quot;/opt/apollo/neo/packages/buildtool/10.0.0-rc1-r1/core/__init__.py&quot;, line 114, in update_pkg_version_available with open(file_path, &#x27;w&#x27;) as fn:FileNotFoundError: [Errno 2] No such file or directory: &#x27;/root/.apollo/available_check&#x27;During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/usr/bin/buildtool&quot;, line 300, in &lt;module&gt; sys.exit(main() or 0) File &quot;/usr/bin/buildtool&quot;, line 287, in main obj = PackageBuilder() File &quot;/usr/bin/buildtool&quot;, line 97, in __init__ self.check_version_available(repository) File &quot;/usr/bin/buildtool&quot;, line 132, in check_version_available update_pkg_version_available(VERSION_AVAILABLE_CHECK_PATH, 500) File &quot;/opt/apollo/neo/packages/buildtool/10.0.0-rc1-r1/core/__init__.py&quot;, line 114, in update_pkg_version_available with open(file_path, &#x27;w&#x27;) as fn:FileNotFoundError: [Errno 2] No such file or directory: &#x27;/root/.apollo/available_check&#x27; 解决方法 123sudo mkdir -p /root/.apollosudo touch /root/.apollo/available_checksudo chmod 777 /root/.apollo/available_check"},{"title":"web实战-网页相册展示","path":"/2025/03/19/web实战-网页相册展示/","content":"https://github.com/liwuyou/HTML.git 项目结构1234567PhotoShow/├── assets/│ ├── images/ # 图片资源│ └── backgrounds/ # 背景图片├── index.html # 主页面├── style.css # 样式文件└── script.js # 交互逻辑 实现思路 图片加载 使用fetch API动态获取assets&#x2F;images目录下的图片资源 通过DOMParser解析目录结构，提取图片路径 自动生成图片网格布局 图片展示 使用CSS Grid布局实现响应式图片网格 图片容器保持1:1比例，使用object-fit: cover保持图片比例 添加hover缩放效果提升交互体验 图片查看 实现模态框查看大图功能 支持左右箭头切换图片 点击背景或关闭按钮关闭模态框 缩放功能 实现图片区域缩放控制 支持放大、缩小、重置操作 缩放时动态调整网格列数和间距 添加平滑过渡效果 关键代码图片加载123456789async function getImagePaths() &#123; const response = await fetch(&#x27;assets/images/&#x27;); const text = await response.text(); const parser = new DOMParser(); const html = parser.parseFromString(text, &#x27;text/html&#x27;); return Array.from(html.querySelectorAll(&#x27;a&#x27;)) .map(a =&gt; a.href) .filter(href =&gt; /\\.(jpg|jpeg|png|gif)$/i.test(href));&#125; 缩放控制12345678910111213function updateGalleryScale() &#123; // 更新缩放比例 gallery.style.transform = `scale($&#123;currentScale&#125;)`; gallery.style.transformOrigin = &#x27;top left&#x27;; // 根据缩放比例动态调整网格列数 const baseColumns = Math.floor(window.innerWidth / 200); const adjustedColumns = Math.max(1, Math.floor(baseColumns / currentScale)); gallery.style.gridTemplateColumns = `repeat($&#123;adjustedColumns&#125;, minmax(200px, 1fr))`; // 调整间距 const spacing = 16 * currentScale; gallery.style.gap = `$&#123;spacing&#125;px`; gallery.style.padding = `$&#123;spacing&#125;px`;&#125; 样式要点123456789101112131415.gallery &#123; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; padding: 16px; transition: all 0.3s ease;&#125;.image-container &#123; aspect-ratio: 1; overflow: hidden; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;&#125; 使用说明 将图片放入assets&#x2F;images目录 打开index.html即可查看相册 使用右下角按钮控制缩放 点击图片查看大图，使用左右箭头切换","tags":["web实战"]},{"title":"大创仿真操作","path":"/2025/03/13/大创仿真操作/","content":"查看TF坐标树 rosrun rqt_tf_tree rqt_tf_tree 键盘控制节点 rosrun teleop_twist_keyboard teleop_twist_keyboard.py 打印odom坐标 rostopic echo &#x2F;odom gmapping建图 rosrun gmapping slam_gmapping"},{"title":"Blender基础学习","path":"/2025/03/09/Blender基础学习/","content":"前言为了gazebo的模型操作，不得不学习一下3D场景建模软件 what is blenderBlender 是一款开源免费的3D 建模、渲染、动画和视频编辑软件，支持 Windows、macOS 和 Linux。它提供 三维建模、PBR 渲染、动画绑定、物理模拟、视频剪辑等功能，并可用 Python 进行扩展。Blender 广泛应用于 影视、游戏、建筑可视化、3D 打印和机器人仿真，支持与 Unreal Engine、ROS 等结合，适合个人和专业用户。🚀 blender 的操作","tags":["3D建模"]},{"title":"马丁格尔策略","path":"/2025/03/09/马丁格尔策略/","content":"马丁格尔策略（Martingale Strategy）马丁格尔策略是一种资金管理策略，常用于赌博和金融交易。其核心思想是： 每次输掉后，下注金额加倍，直到赢得一局。 赢了后，回到最小下注金额，重新开始。 目标是赢一次，即可弥补所有损失并获得初始下注的利润。 规则示例 初始下注 1 枚硬币。 输 → 下注翻倍（2、4、8、16…）。 赢 → 回到最小下注，循环进行。 优缺点✅ 优点： 理论上资金无限时，总能盈利。 短期内可能获得小额利润。 ❌ 缺点： 资金需求指数级增长，连续失败可能破产。 赌场设有限注规则，防止无限翻倍。 数学期望不变，长期来看仍可能亏损。 变种策略🔹 反马丁格尔：赢了加倍，输了回到最小下注，适合抓住连胜机会。🔹 斐波那契投注：下注按斐波那契数列增长，比马丁格尔风险更小。 总结 策略 规则 优点 缺点 马丁格尔 输了加倍下注，赢了回到起点 赢一次即回本 资金需求大，赌场有限制 反马丁格尔 赢了加倍，输了回到起点 适合连胜情况 亏损时难回本 斐波那契投注 下注按斐波那契数列增长 资金压力较小 亏损恢复较慢 🔹 适合短期投机，但长期风险极高。盈利更依赖概率、资金管理和心理控制，而非单纯加倍下注。 实例代码结果是赢得硬币数&#x3D;回合数X胜率X基准币值！ 1234567891011121314151617181920212223242526272829303132333435363738import randomdef gambling_machine(bet): &quot;&quot;&quot; 模拟赌博机器，胜率50% :param bet: 投入的硬币数 :return: 赢得的硬币数（赢了返回2倍，输了返回0） &quot;&quot;&quot; return bet * 2 if random.random() &lt; 0.5 else 0def simulate_gambling(n): &quot;&quot;&quot; 模拟赌博N轮，并计算玩家总共挣了多少钱 :param n: 允许的最大轮数 &quot;&quot;&quot; initial_bet = 1 # 初始投注额 total_bet = 0 # 统计总投入的硬币数量 total_win = 0 # 统计总赢得的硬币数量 current_bet = initial_bet # 当前投注额，初始为1 for _ in range(n): # 进行n轮赌博 total_bet += current_bet # 记录本轮的投入 result = gambling_machine(current_bet) # 进行赌博 if result &gt; 0: # 如果赢了 total_win += result # 记录赢得的硬币数量 print(f&quot;赢了！本轮投入 &#123;current_bet&#125;，赢得 &#123;result&#125;，总投入 &#123;total_bet&#125;&quot;) current_bet = initial_bet # 赢了，下一轮恢复初始投注 else: # 如果输了 print(f&quot;输了！本轮投入 &#123;current_bet&#125;，总投入 &#123;total_bet&#125;&quot;) current_bet *= 2 # 输了，下一轮翻倍投注 total_profit = total_win - total_bet # 计算总利润 print(f&quot;赌博结束，总投入 &#123;total_bet&#125; 枚硬币，总赢得 &#123;total_win&#125; 枚硬币，总利润 &#123;total_profit&#125; 枚硬币&quot;)# 设定比赛轮数为1000simulate_gambling(1000)","tags":["经济学"]},{"title":"Flask基础开发","path":"/2025/03/05/Flask基础开发/","content":"https://www.runoob.com/flask/flask-tutorial.html Flask 是一个用 Python 编写的轻量级 Web 应用框架。Flask 基于 WSGI（Web Server Gateway Interface）和 Jinja2 模板引擎，旨在帮助开发者快速、简便地创建 Web 应用。Flask 被称为”微框架”，因为它使用简单的核心，用扩展增加其他功能。 相关链接Flask 官网：https://flask.palletsprojects.com/Flask 中文文档：https://flask.palletsprojects.com/zh-cn/stable/quickstart/Flask 源码：https://github.com/pallets/flask/","tags":["python"]},{"title":"轮式机器人运动学模型","path":"/2025/03/04/轮式机器人运动学模型/","content":"精简版推导版"},{"title":"电子音乐","path":"/2025/03/02/电子音乐/","content":"宿主软件 Live fl(PC,教程最多) 库乐队(手机) 曲风House（eg:OVERDO$E） PhonK 基础知识 乐理 混音 混音 压缩器（效果器） 均衡器 混响 延迟 瞬态整形器 门限器其他","tags":["电子音乐"]},{"title":"高数","path":"/2025/03/02/高数/","content":"函数","tags":["考研"]},{"title":"考研安排","path":"/2025/03/01/考研安排/","content":"基础知识考试时间：12月份左右 初试 信息来源 时间安排 择校 要看具体导师组 查看院校歧视"},{"title":"电机与拖动重制版","path":"/2025/02/25/电机与拖动重制版/","content":"第二章，多轴传动单轴电机拖动模型 多轴平动模型题目 解答 补充 同型题 解答 1待加入... 提升下放模型知识点 例题 直流电机(包括电动机与发电机)知识点直流电机的优点 额定值 电动机与发电机的额定功率不同，发电机Pn&#x3D;Un*In，pn为电功率,电动机Pn,为输出的机械功率需要计算输入功率，电功率 电动势与转矩 他励并励直流电机 例题 解答已知： 额定功率：$ P_N &#x3D; 22kW $ 额定电压：$ U_N &#x3D; 220V $ 额定电流：$ I_N &#x3D; 115A $ 额定转速：$ n_N &#x3D; 1500r&#x2F;min $ 电枢回路总电阻：$ R_a &#x3D; 0.1\\Omega $ 负载转矩：$ T_L &#x3D; 0.85T_N $ （1）计算电枢电流 $ I_a $在他励直流电动机中，若励磁电流不变，则磁通 $ \\Phi $ 近似恒定，电磁转矩 $ T $ 与电枢电流 $ I_a $ 成正比：$$T_N &#x3D; C_t \\cdot \\Phi_N \\cdot I_N$$$$T_L &#x3D; 0.85T_N &#x3D; C_t \\cdot \\Phi_N \\cdot I_a$$两式相除，得：$$I_a &#x3D; 0.85 I_N &#x3D; 0.85 \\times 115 &#x3D; 97.75 A$$ （2）计算感应电动势 $ E_a $感应电动势计算公式：$$E_a &#x3D; U_N - R_a I_a$$代入数值：$$E_a &#x3D; 220 - 0.1 \\times 97.75 &#x3D; 210.225V$$ （3）计算转速 $ n $在他励电动机中，转速与感应电动势成正比：$$n &#x3D; \\frac{E_a}{E_{aN}} \\cdot n_N$$其中，额定状态下的感应电动势：$$E_{aN} &#x3D; U_N - R_a I_N &#x3D; 220 - 0.1 \\times 115 &#x3D; 208.5V$$因此：$$n &#x3D; \\frac{210.225}{208.5} \\times 1500 &#x3D; 1513.9 \\text{ r&#x2F;min}$$ 最终结果 电枢电流：$ I_a &#x3D; 97.75A $ 感应电动势：$ E_a &#x3D; 210.225V $ 转速：$ n &#x3D; 1513.9 \\text{ r&#x2F;min} $ 结论：由于负载转矩小于额定转矩，电枢电流减小，使得电枢电阻压降变小，电动势增大，因此转速略微上升。 第四章第五章异步电机分类 转子鼠笼型 绕线型 额定值 运动分析 磁动势 电动势 原理 转子测平衡方程 左边为相对运动，右边为相对静止","tags":["课程"]},{"title":"python小游戏-井字棋（双人对弈版）","path":"/2025/02/17/python小游戏-井字棋（双人对弈版）/","content":"前言2025,02,17，其实AI也好加上，甚至穷举就行，但目前暂时没有懂AI的算法，就不加了。后面再说。 实现思路 1.展示棋盘 2.先手落子（刷新界面）3.判断胜负4.后手落子（刷新界面）5.判断胜负 循环2-5，直至正负判断结束 结构 代码main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from game_ui import TicTacToeGUI# 创建棋盘board = [[0] * 3 for _ in range(3)]# 打印棋盘def print_board(): for row in board: print(&quot; &quot;.join(str(cell) for cell in row)) print()# 落子函数def place_mark(x, y, mark): if board[x][y] == 0: board[x][y] = mark return True return False# 判断胜负def check_winner(): for row in board: # 检查行 if row[0] == row[1] == row[2] and row[0] != 0: return row[0] for col in range(3): # 检查列 if board[0][col] == board[1][col] == board[2][col] and board[0][col] != 0: return board[0][col] if board[0][0] == board[1][1] == board[2][2] and board[0][0] != 0: # 检查主对角线 return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != 0: # 检查副对角线 return board[0][2] if all(cell != 0 for row in board for cell in row): # 检查平局 return &quot;draw&quot; return None# 运行游戏def game(): game = TicTacToeGUI() turn = &quot;x&quot; running = True screen, clock, = game.screen, game.clock while running: clock.tick(30) game.run(board) ## 获取棋子位置 running,vocation = game.handle_events() while running and vocation is None: # 确保 vocation 不是 None running, vocation = game.handle_events() r, c= vocation # 判断是否点击已有占位棋子，如果重复点击就再次获取鼠标点击 while not place_mark(r, c, turn): running, vocation = game.handle_events() while running and vocation is None: # 确保 vocation 不是 None running, vocation = game.handle_events() r, c = vocation winner = check_winner() #判断是否胜利 if winner: game.run(board) print(f&quot;&#123;winner&#125; 胜利！&quot; if winner != &quot;draw&quot; else &quot;平局！&quot;) break turn = &quot;o&quot; if turn == &quot;x&quot; else &quot;x&quot;if __name__ == &quot;__main__&quot;: game() game_ui.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import pygameclass TicTacToeGUI: def __init__(self, width=600, height=600): &quot;&quot;&quot; 初始化游戏窗口和资源 &quot;&quot;&quot; pygame.init() self.WIDTH, self.HEIGHT = width, height self.screen = pygame.display.set_mode((self.WIDTH, self.HEIGHT)) pygame.display.set_caption(&quot;井字棋&quot;) self.clock = pygame.time.Clock() self.GRAY = (100, 100, 100) self.cell_size = self.WIDTH // 3 # 每个格子大小 # 加载图片 self.board_image = pygame.image.load(&quot;board_3.jpg&quot;) self.board_image = pygame.transform.scale(self.board_image, (self.WIDTH, self.HEIGHT)) self.chess_o = pygame.image.load(&quot;chessman1.png&quot;) self.chess_o = pygame.transform.scale(self.chess_o, (self.WIDTH // 3, self.HEIGHT // 3)) self.chess_x = pygame.image.load(&quot;chessman2.png&quot;) self.chess_x = pygame.transform.scale(self.chess_x, (self.WIDTH // 3, self.HEIGHT // 3)) def draw_board(self): &quot;&quot;&quot; 画出井字棋棋盘 &quot;&quot;&quot; line_width, line_width1 = 20, 10 color = self.GRAY # 画边界 pygame.draw.line(self.screen, color, (0, 0), (self.WIDTH, 0), line_width) pygame.draw.line(self.screen, color, (0, 0), (0, self.HEIGHT), line_width) pygame.draw.line(self.screen, color, (0, self.HEIGHT), (self.WIDTH, self.HEIGHT), line_width) pygame.draw.line(self.screen, color, (self.WIDTH, 0), (self.WIDTH, self.HEIGHT), line_width) # 画内部网格 pygame.draw.line(self.screen, color, (self.WIDTH / 3, 0), (self.WIDTH / 3, self.HEIGHT), line_width1) pygame.draw.line(self.screen, color, (self.WIDTH / 3 * 2, 0), (self.WIDTH / 3 * 2, self.HEIGHT), line_width1) pygame.draw.line(self.screen, color, (0, self.HEIGHT / 3), (self.WIDTH, self.HEIGHT / 3), line_width1) pygame.draw.line(self.screen, color, (0, self.HEIGHT / 3 * 2), (self.WIDTH, self.HEIGHT / 3 * 2), line_width1) def draw_pieces(self, board): &quot;&quot;&quot; 根据传入的棋盘状态绘制棋子 &quot;&quot;&quot; for row in range(3): for col in range(3): if board[row][col] == &quot;o&quot;: self.screen.blit(self.chess_o, (col * self.cell_size, row * self.cell_size)) elif board[row][col] == &quot;x&quot;: self.screen.blit(self.chess_x, (col * self.cell_size, row * self.cell_size)) def handle_events(self): &quot;&quot;&quot;处理键盘和鼠标事件&quot;&quot;&quot; for event in pygame.event.get(): if event.type == pygame.QUIT: return False, None # 退出信号，返回 None if event.type == pygame.MOUSEBUTTONDOWN: # 检测鼠标点击 x, y = event.pos # 获取鼠标点击的像素位置 row = y // (600 // 3) # 计算点击的行（假设棋盘是 600x600） col = x // (600 // 3) # 计算点击的列 return True, (row, col) # 返回行列索引 return True, None # 没有点击时，返回继续运行 def run(self, board): # while True: self.screen.fill((255, 255, 255)) # 填充背景为白色 self.screen.blit(self.board_image, (0, 0)) # 绘制背景棋盘 self.draw_board() # 绘制网格线 self.draw_pieces(board) pygame.display.flip() # 更新屏幕# 只有当直接运行此文件时才执行游戏if __name__ == &quot;__main__&quot;: game = TicTacToeGUI() test_board = [ [&quot;x&quot;, &quot;o&quot;, &quot;x&quot;], [&quot;o&quot;, &quot;x&quot;, &quot;o&quot;], [&quot;o&quot;, &quot;x&quot;, &quot;o&quot;] ] game.run(test_board)","tags":["python小游戏"]},{"title":"基础乐理学习","path":"/2025/02/15/基础乐理学习/","content":"前言为了更好的做出自己的电子琴，还是得学习一下乐理的基础知识 简谱的认识 什么是唱名 钢琴和钢琴的组 什么是音名音名不变，唱名变化 什么是1&#x3D;c,调号 钢琴的黑键，为什么其他调号的音出现在黑键上 为什么有两种表示？ 会在以后的学习中（和声等）带来便利 半音与全音 钢琴上相邻两个音的距离是一个半音，黑键与白健实际上是平等的 半音（Semitone）与全音（Whole Tone）1. 什么是半音？半音（Semitone） 是音乐中 最小的音程单位（在现代西方音乐体系中）。 🎵 在钢琴上： 两个相邻的琴键（包括黑键和白键）之间的音程 就是半音。例如： **C → C#**（升 C） 是一个半音。 E → F（没有黑键）也是一个半音。 🎵 在五线谱上： 例如 C → C#、D → D#、E → F、A → A#，这些都是半音。 自然半音（没有变音记号）：E→F，B→C。 2. 什么是全音？全音（Whole Tone） 是 两个半音的间隔，等于 两个相邻音之间的距离为两个半音。 🎵 在钢琴上： C → D 是一个全音（因为 C → C# 是一个半音，C# → D 也是一个半音，所以 C → D 是两个半音，即全音）。 E → F 是半音，而 E → F# 是全音。 🎵 在五线谱上： 例如 C → D、D → E、F → G、G → A、A → B，都是全音。 3. 半音与全音的关系 1 个半音 &#x3D; 1&#x2F;2 全音 2 个半音 &#x3D; 1 个全音 📌 举例说明： 音程 半音数 例子 半音 1 C → C#，E → F 全音 2 C → D，F → G 4. 自然音阶中的半音与全音分布在 C 大调（自然大调） 中，音程的分布如下： 全音：C → D，D → E，F → G，G → A，A → B 半音：E → F，B → C（这是自然音阶中的固定半音位置） 📌 总结规律： 在 大调音阶（如 C 大调）中： 全音：1→2、2→3、4→5、5→6、6→7 半音：3→4、7→1（每个八度循环） 5. 应用 乐器演奏：在钢琴、吉他、小提琴等乐器上，半音与全音是演奏音阶、和弦、旋律的基础。 和弦构造：比如 C 大三和弦（C-E-G），E → G 是全音加半音（即 3 个半音）。 调性关系：大调与小调的音阶结构基于全音和半音的排列顺序。 6. 总结 半音（Semitone）：最小的音程，相邻的琴键或音符之间的间隔。 全音（Whole Tone）：等于两个半音（一个音程跨度为两个相邻音符之间的距离）。 自然大调中，半音出现在 3-4 和 7-1 之间，其余都是全音。 调式调式（Mode）是什么？调式（Mode） 是指 一组特定音高按照一定规律排列形成的音阶体系，并以其中的一个音为主音（Tonic）。不同的调式会给音乐带来不同的色彩和情感。 1. 调式的基本概念调式由 音阶（Scale） 和 主音（Tonic） 组成： 音阶：由一组固定顺序排列的音组成，例如 C 大调音阶（C D E F G A B C）。 主音（Tonic）：音阶的起始音，也是旋律和和声的核心音。例如 C 大调的主音是 C。 2. 主要的调式类型（1）自然调式最常见的自然调式有 大调（Major）和小调（Minor）。 ① 大调（Major Scale） 由 全音和半音 组成，模式固定：全 - 全 - 半 - 全 - 全 - 全 - 半 例如 C 大调（C Major）：C - D - E - F - G - A - B - C半音位置在 E → F 和 B → C 之间。 特点：明亮、欢快、稳定，多用于流行音乐、古典音乐、进行曲等。 ② 小调（Minor Scale）小调有 自然小调、和声小调、旋律小调 三种，其中 自然小调 最基础： 规律：全 - 半 - 全 - 全 - 半 - 全 - 全 例如 A 小调（A Minor）：A - B - C - D - E - F - G - A半音位置在 B → C 和 E → F 之间。 特点：忧郁、悲伤、神秘，常用于抒情曲、悲剧音乐、爵士等。 （2）教会调式（Church Modes）在西方早期音乐（中世纪、文艺复兴时期）中，使用了一系列 古典调式，即 教会调式。这些调式是从自然大调的不同音级开始，形成不同的音阶排列： 调式 结构（全&#x2F;半音） 例子（从 C 开始） 特点 1. 伊奥尼亚调式（Ionian） 全 - 全 - 半 - 全 - 全 - 全 - 半 C D E F G A B C 即大调，明亮欢快 2. 多利亚调式（Dorian） 全 - 半 - 全 - 全 - 全 - 半 - 全 D E F G A B C D 爵士、民谣，带点忧郁感 3. 弗里吉亚调式（Phrygian） 半 - 全 - 全 - 全 - 半 - 全 - 全 E F G A B C D E 异域风情、悬疑感 4. 利底亚调式（Lydian） 全 - 全 - 全 - 半 - 全 - 全 - 半 F G A B C D E F 童话般、梦幻感 5. 混合利底亚调式（Mixolydian） 全 - 全 - 半 - 全 - 全 - 半 - 全 G A B C D E F G 摇滚、布鲁斯，轻松自由 6. 爱奥利亚调式（Aeolian） 全 - 半 - 全 - 全 - 半 - 全 - 全 A B C D E F G A 即自然小调，悲伤 7. 洛克里亚调式（Locrian） 半 - 全 - 全 - 半 - 全 - 全 - 全 B C D E F G A B 神秘、不稳定 🎵 应用： 爵士、摇滚、电子音乐等风格常用这些调式来创造特殊氛围。 例如：多利亚调式（Dorian）用于爵士，混合利底亚调式（Mixolydian）用于布鲁斯。 （3）五声调式（Pentatonic Scale）中国传统音乐主要使用 五声调式，它由 五个音 组成，没有半音，旋律流畅。 常见的五声调式： 宫（Do） → C 商（Re） → D 角（Mi） → E 徵（Sol） → G 羽（La） → A 🎵 应用： 中国古典音乐、民歌、二胡、琵琶等民族乐器演奏。 蓝调（Blues）和摇滚（Rock） 也常用 五声音阶。 3. 总结 调式 是音阶的排列方式，不同调式带来不同的音乐色彩。 大调（Major） 和 小调（Minor） 是最常见的调式。 教会调式 提供了更多音乐风格，如爵士、摇滚、古典音乐。 五声调式 是中国音乐的重要组成部分，没有半音，旋律优美流畅。 音阶 以黑键开始的大调 音域 拍号 附点与休止符 常用四拍 单拍子，复拍子，强弱关系","tags":["乐理"]},{"title":"python小游戏-贪吃蛇","path":"/2025/02/14/python小游戏-贪吃蛇/","content":"结构 game.py为主程序 代码game_config.py 12345678910# 设置窗口大小WIDTH, HEIGHT = 600, 400GRID_SIZE = 20 # 每个网格的大小# 颜色定义WHITE = (255, 255, 255)GREEN = (0, 255, 0) # 贪吃蛇颜色RED = (255, 0, 0) # 食物颜色BLACK = (0, 0, 0) # 背景颜色BLUE = (0, 0, 255) # 蛇头颜色 game.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import pygamefrom snake_and_food import Snake, Foodimport game_configimport timedef init_game(): &quot;&quot;&quot;初始化 Pygame、窗口和时钟和字体&quot;&quot;&quot; pygame.init() screen = pygame.display.set_mode((game_config.WIDTH, game_config.HEIGHT)) pygame.display.set_caption(&quot;贪吃蛇&quot;) clock = pygame.time.Clock() # 初始化字体 pygame.font.init() font = pygame.font.Font(None, 36) # 使用默认字体，大小36 return screen, clock, fontdef handle_events(snake_dir): &quot;&quot;&quot;处理键盘事件&quot;&quot;&quot; for event in pygame.event.get(): if event.type == pygame.QUIT: return False, snake_dir elif event.type == pygame.KEYDOWN: if event.key == pygame.K_UP and snake_dir != (0, 1): snake_dir = (0, -1) elif event.key == pygame.K_DOWN and snake_dir != (0, -1): snake_dir = (0, 1) elif event.key == pygame.K_LEFT and snake_dir != (1, 0): snake_dir = (-1, 0) elif event.key == pygame.K_RIGHT and snake_dir != (-1, 0): snake_dir = (1, 0) return True, snake_dirdef Ui_OVER(screen, font): for i in range(3):#闪烁三次 screen.fill(game_config.WHITE) # 清屏 pygame.display.flip() # 刷新屏幕 time.sleep(0.1) screen.fill(game_config.BLACK) # 清屏 pygame.display.flip() # 刷新屏幕 time.sleep(0.1) screen.fill(game_config.BLACK) # 清屏 text_surface = font.render(&quot;GAME OVER&quot;, True, (255, 255, 255)) text_rect = text_surface.get_rect(center=(game_config.WIDTH // 2, game_config.HEIGHT // 2)) # 清屏并绘制文本 screen = pygame.display.set_mode((game_config.WIDTH, game_config.HEIGHT)) screen.fill(game_config.BLACK) screen.blit(text_surface, text_rect) # 让文本居中 pygame.display.flip() time.sleep(1) def game_loop(): &quot;&quot;&quot;主游戏循环&quot;&quot;&quot; screen, clock, font = init_game() snake = Snake() food = Food() running = True snake_dir = (1, 0) # 初始方向 while running: clock.tick(10) running, snake_dir = handle_events(snake_dir) screen.fill(game_config.BLACK) # 清屏 running = snake.move(snake_dir, food) # 绘制食物 food_x = food.food[0] * game_config.GRID_SIZE food_y = food.food[1] * game_config.GRID_SIZE food_rect = (food_x, food_y, game_config.GRID_SIZE, game_config.GRID_SIZE) pygame.draw.rect(screen, game_config.RED, food_rect) # 绘制蛇身 for index, segment in enumerate(snake.body): segment_x = segment[0] * game_config.GRID_SIZE segment_y = segment[1] * game_config.GRID_SIZE segment_rect = (segment_x, segment_y, game_config.GRID_SIZE, game_config.GRID_SIZE) # 蛇头颜色为蓝色，蛇身颜色为绿色 color = game_config.BLUE if index == 0 else game_config.GREEN pygame.draw.rect(screen, color, segment_rect) # 绘制蛇身 # 渲染并绘制文本 score = len(snake.body) - 3 text_surface = font.render(f&quot;Game Score: &#123;score&#125;&quot;, True, (255, 255, 255)) screen.blit(text_surface, (10, 10)) # 位置 (10, 10) pygame.display.flip() # 刷新屏幕 Ui_OVER(screen, font) pygame.quit()if __name__ == &quot;__main__&quot;: game_loop() snake_and_food.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import randomimport game_config# 访问变量的方式WIDTH = game_config.WIDTHHEIGHT = game_config.HEIGHTGRID_SIZE = game_config.GRID_SIZEGREEN = game_config.GREENRED = game_config.REDBLACK = game_config.BLACKclass Snake: &quot;&quot;&quot;贪吃蛇类&quot;&quot;&quot; def __init__(self, body=None, direction=None): &quot;&quot;&quot;初始化蛇身和方向&quot;&quot;&quot; self.body = body[:] if body else [(5, 5), (4, 5), (3, 5)] # 复制默认蛇身，防止共享 self.direction = direction if direction else (1, 0) def move(self, direction, food): &quot;&quot;&quot;蛇移动逻辑&quot;&quot;&quot; new_head = (self.body[0][0] + direction[0], self.body[0][1] + direction[1]) # 检查是否撞墙 if new_head[0] &lt; 0 or new_head[1] &lt; 0 or new_head[0] &gt;= WIDTH // GRID_SIZE or new_head[1] &gt;= HEIGHT // GRID_SIZE: return False # 撞墙，游戏结束 # 检查是否咬到自己 if new_head in self.body: return False # 更新蛇的位置 self.body.insert(0, new_head) if new_head == food.food: food.eaten(self.body) # 生成新食物 else: self.body.pop() # 移除尾部，保持长度 return True # 移动成功class Food: &quot;&quot;&quot;食物类&quot;&quot;&quot; def __init__(self, color=RED): &quot;&quot;&quot;初始化食物位置&quot;&quot;&quot; self.color = color self.food = self.generate_food([]) # 初始时不与蛇重叠 def generate_food(self, snake_body): &quot;&quot;&quot;生成新的食物位置，确保不与蛇身重叠&quot;&quot;&quot; while True: food = (random.randint(0, (WIDTH // GRID_SIZE) - 1), random.randint(0, (HEIGHT // GRID_SIZE) - 1)) if food not in snake_body: return food def eaten(self, snake_body): &quot;&quot;&quot;被吃掉后重新生成&quot;&quot;&quot; self.food = self.generate_food(snake_body)","tags":["python小游戏"]},{"title":"算法基础-十大排序算法","path":"/2025/02/13/算法基础-十大排序算法/","content":"十大排序算法 选择排序 冒泡排序 插入排序 希尔排序 计数排序 桶排序 基数排序 归并排序 快速排序 堆排序 1. 时间复杂度（Time Complexity）时间复杂度 是 衡量算法执行时间增长与输入规模关系的指标。它描述了 输入规模 ( n ) 变化时，算法执行的基本操作次数。 🔹 常见时间复杂度 时间复杂度 复杂度名称 示例 ( O(1) ) 常数时间 直接返回结果 return a + b ( O(\\log n) ) 对数时间 二分查找 ( O(n) ) 线性时间 遍历数组 ( O(n \\log n) ) 线性对数时间 归并排序、快速排序 ( O(n^2) ) 二次时间 双层嵌套循环（冒泡排序） ( O(2^n) ) 指数时间 递归斐波那契 ( O(n!) ) 阶乘时间 旅行商问题（TSP） 🔹 计算时间复杂度 只关注最大数量级，忽略常数 12for i in range(n): # O(n) print(i) 遍历 ( n ) 次，时间复杂度是 ( O(n) )。 嵌套循环相乘 123for i in range(n): # O(n) for j in range(n): # O(n) print(i, j) 总共执行 ( n \\times n &#x3D; O(n^2) ) 次。 对数复杂度 ( O(\\log n) ) 123i = 1while i &lt; n: i *= 2 i 每次翻倍，循环运行约 ( \\log_2 n ) 次，因此复杂度是 ( O(\\log n) )。 2. 空间复杂度（Space Complexity）空间复杂度 是 衡量算法运行时需要占用多少额外的存储空间。 🔹 常见空间复杂度 空间复杂度 说明 示例 ( O(1) ) 只使用常数级别的额外存储 交换两个数 ( O(n) ) 需要存储 ( n ) 个数据 额外创建数组 ( O(n^2) ) 需要存储 ( n \\times n ) 矩阵 图的邻接矩阵 🔹 计算空间复杂度 基本变量（O(1） 12a = 10b = 20 只使用了 常数级别的变量，所以是 ( O(1) )。 数组或列表（O(n） 1arr = [0] * n 额外创建了 ( n ) 个存储单元，复杂度是 ( O(n) )。 递归（O(n)） 1234def factorial(n): if n == 0: return 1 return n * factorial(n - 1) 递归调用占用 ( O(n) ) 栈空间。 总结 复杂度类型 时间复杂度 空间复杂度 示例 最优算法 ( O(1) ) ( O(1) ) 直接返回值 一般算法 ( O(n) ) ( O(n) ) 遍历列表 较差算法 ( O(n^2) ) ( O(n^2) ) 矩阵运算 最差算法 ( O(2^n) ) ( O(n) ) 递归斐波那契 💡 目标：尽量优化算法，使时间复杂度和空间复杂度更小！ 🚀 选择排序 🔹 选择排序原理 遍历数组，在未排序部分找到最小值； 交换最小值与当前元素； 重复步骤 1 和 2，直到整个数组有序。 等同于打擂台排序 🔹 Python 代码1234567891011121314151617def selection_sort(arr): n = len(arr) for i in range(n - 1): # 遍历每个位置（除了最后一个） min_index = i # 假设当前索引是最小值 for j in range(i + 1, n): # 在剩下的部分查找更小的值 if arr[j] &lt; arr[min_index]: min_index = j # 记录最小值索引 if min_index != i: # 如果找到了更小的值，则交换 arr[i], arr[min_index] = arr[min_index], arr[i] return arr# 测试代码arr = [64, 25, 12, 22, 11]sorted_arr = selection_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [11, 12, 22, 25, 64] 🔹 时间复杂度 最佳情况：( O(n^2) )（已经排序仍然需要比较） 最差情况：( O(n^2) )（完全逆序，需要交换） 平均情况：( O(n^2) ) 🔹 空间复杂度 ( O(1) )（原地排序，无额外空间开销） ✅ 选择排序适用于小规模数据，但对于大数据不够高效 🚀 冒泡排序 冒泡排序原理： 两两比较相邻元素，如果顺序不对，则交换它们； 一轮遍历后，最大元素会被“冒泡”到数组末尾； 重复步骤 1 和 2，直到整个数组有序。 🔹 Python 代码12345678910111213141516def bubble_sort(arr): n = len(arr) for i in range(n - 1): # 总共进行 n-1 轮排序 swapped = False # 标记变量，优化性能 for j in range(n - 1 - i): # 每轮遍历未排序部分 if arr[j] &gt; arr[j + 1]: # 交换相邻元素 arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: # 如果没有发生交换，说明已排序好 break return arr# 测试代码arr = [64, 25, 12, 22, 11]sorted_arr = bubble_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [11, 12, 22, 25, 64] 🔹 时间复杂度 最佳情况：( O(n) )（已排序，优化版本只需 1 轮） 最差情况：( O(n^2) )（完全逆序） 平均情况：( O(n^2) ) 🔹 空间复杂度 ( O(1) )（原地排序，无额外空间） ✅ 适用于小规模数据，但对于大数据效率低 🚀 插入排序 插入排序原理： 将数组分成 已排序 和 未排序 两部分。 依次从未排序部分取出元素，插入 到已排序部分的正确位置。 直到所有元素都插入完成，数组变为有序。 开始有序区只有一个，比他大的都往后移动一个格子 🔹 Python 代码123456789101112131415def insertion_sort(arr): n = len(arr) for i in range(1, n): # 从第二个元素开始（索引 1） key = arr[i] # 取出当前待插入的元素 j = i - 1 while j &gt;= 0 and arr[j] &gt; key: # 向左寻找合适位置 arr[j + 1] = arr[j] # 后移元素 j -= 1 arr[j + 1] = key # 插入元素 return arr# 测试代码arr = [64, 25, 12, 22, 11]sorted_arr = insertion_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [11, 12, 22, 25, 64] 🔹 时间复杂度 最佳情况：( O(n) )（数组已排序） 最差情况：( O(n^2) )（完全逆序） 平均情况：( O(n^2) ) 🔹 空间复杂度 ( O(1) )（原地排序） ✅ 适用于小规模数据，稳定排序，性能优于冒泡排序 🚀 希尔排序 【数据结构——一分钟搞定插入排序】 https://www.bilibili.com/video/BV1Y8411T7LC/?share_source=copy_web&amp;vd_source=59d9734fc97a6b9510465651bf85b98c 希尔排序原理： 基于插入排序 的改进版本，先对 较大间隔 的元素进行排序，再逐步减小间隔，最终进行普通插入排序。 这样可以减少数据移动次数，提高效率。 🔹 Python 代码12345678910111213141516171819def shell_sort(arr): n = len(arr) gap = n // 2 # 初始步长 while gap &gt; 0: for i in range(gap, n): key = arr[i] j = i while j &gt;= gap and arr[j - gap] &gt; key: arr[j] = arr[j - gap] # 后移元素 j -= gap arr[j] = key # 插入元素 gap //= 2 # 缩小步长 return arr# 测试代码arr = [64, 25, 12, 22, 11]sorted_arr = shell_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [11, 12, 22, 25, 64] 🔹 时间复杂度 最佳情况：( O(n \\log n) )（取决于步长选择） 最差情况：( O(n^2) )（极端情况下） 平均情况：( O(n^{1.3 - 2}) )（根据步长序列不同） 🔹 空间复杂度 ( O(1) )（原地排序） ✅ 适用于中等规模数据，比插入排序和冒泡排序更快 🚀 计数排序 🔹 计数排序（Counting Sort）计数排序原理： 适用于整数排序，尤其是范围较小的非负整数。 统计每个元素出现的次数，利用计数数组（桶）进行排序。 时间复杂度接近 ( O(n) )，但空间复杂度较高。 🔹 Python 代码12345678910111213141516171819202122232425262728293031def counting_sort(arr): if not arr: return arr max_val = max(arr) # 找到数组中的最大值 min_val = min(arr) # 找到数组中的最小值 range_val = max_val - min_val + 1 # 计算值域大小 # 创建计数数组并初始化为0 count = [0] * range_val output = [0] * len(arr) # 统计元素出现次数 for num in arr: count[num - min_val] += 1 # 计算前缀和，确定元素在输出数组中的位置 for i in range(1, len(count)): count[i] += count[i - 1] # 填充排序后的数组（倒序遍历确保稳定性） for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output# 测试代码arr = [4, 2, 2, 8, 3, 3, 1]sorted_arr = counting_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [1, 2, 2, 3, 3, 4, 8] 🔹 时间复杂度 最佳情况：( O(n + k) )（k 为数值范围） 最差情况：( O(n + k) ) 平均情况：( O(n + k) ) 🔹 空间复杂度 ( O(k) ) + ( O(n) )（需要额外的计数数组） ✅ 适用于整数排序，尤其是数据范围较小、重复率较高的情况 🚀 桶排序 每个桶内部的排序方式多种多样 基数排序 归并排序 🔹 归并排序（Merge Sort）归并排序原理： 分割：将数组递归地分成两半，直到每部分只剩一个元素。 合并：合并两个有序数组，保持整体有序。 时间复杂度：( O(n \\log n) )，适用于大规模数据排序。 🔹 Python 代码1234567891011121314151617181920212223242526272829303132333435def merge_sort(arr): if len(arr) &lt;= 1: # 递归终止条件 return arr # 1. 分割数组 mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) # 递归排序左半部分 right_half = merge_sort(arr[mid:]) # 递归排序右半部分 # 2. 合并两个有序数组 return merge(left_half, right_half)def merge(left, right): sorted_list = [] i = j = 0 # 左右数组的索引 # 逐步合并两个有序数组 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # 处理剩余元素 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list# 测试代码arr = [12, 11, 13, 5, 6, 7]sorted_arr = merge_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [5, 6, 7, 11, 12, 13] 🔹 时间复杂度 最佳情况：( O(n \\log n) ) 最差情况：( O(n \\log n) ) 平均情况：( O(n \\log n) ) 🔹 空间复杂度 ( O(n) )（需要额外的存储空间） ✅ 适用于大规模数据排序，尤其是稳定排序需求场景 🚀 快速排序 🔹 快速排序（Quick Sort）原理： 选择基准（pivot）：一般选择数组中的一个元素作为基准。 分区（Partition）： 小于基准的放左边， 大于基准的放右边。 递归处理：分别对左、右子数组递归执行快速排序，直到数组有序。 🔹 Python 代码123456789101112131415def quick_sort(arr): if len(arr) &lt;= 1: # 递归终止条件 return arr pivot = arr[len(arr) // 2] # 选择中间元素作为基准 left = [x for x in arr if x &lt; pivot] # 小于基准的元素 middle = [x for x in arr if x == pivot] # 等于基准的元素 right = [x for x in arr if x &gt; pivot] # 大于基准的元素 return quick_sort(left) + middle + quick_sort(right) # 递归排序并合并# 测试代码arr = [10, 7, 8, 9, 1, 5]sorted_arr = quick_sort(arr)print(&quot;排序后的数组:&quot;, sorted_arr) 🔹 运行结果1排序后的数组: [1, 5, 7, 8, 9, 10] 🔹 时间复杂度 最佳情况：( O(n \\log n) ) 最差情况（已排序数组）：( O(n^2) ) 平均情况：( O(n \\log n) ) 🔹 空间复杂度 ( O(\\log n) )（递归栈空间） 最差情况可能达到 ( O(n) )（当每次都选到最小&#x2F;最大元素作为基准） ✅ 快速排序通常比归并排序更快，因为它不需要额外的合并步骤！ 🚀 堆排序 总结","tags":["python算法"]},{"title":"提示词工程","path":"/2025/02/13/提示词工程/","content":"what is prompt Engineering技巧将指令与代码分开1使用###内容，或&quot;&quot;&quot;内容&quot;&quot;&quot;，将指令与遥操作的对象分开 少量提示在让AI执行某重复指令时，可以提示实例一个操作 Prompt 的典型构成 角色：给 AI 定义一个最匹配任务的角色，比如：「你是一位软件工程师」「你是一位小学老师」 指示：对任务进行描述 上下文：给出与任务相关的其它背景信息（尤其在多轮交互中） 例子：必要时给出举例，学术中称为 one - shot learning, few - shot learning 或 in - context learning；实践证明其对输出正确性有帮助 输入：任务的输入信息；在提示词中明确的标识出输入 输出：输出的格式描述，以便后继模块自动解析模型的输出结果，比如（JSON、XML） 大模型对 prompt 开头和结尾的内容更敏感 原则与原理大模型（Large Model） 通常指的是 参数规模庞大、训练数据丰富，并且具备通用能力 的人工智能模型，尤其是在 自然语言处理（NLP）、计算机视觉（CV）和多模态AI 领域。 大模型 &#x3D; 超大规模参数 + 大量训练数据 + 强泛化能力","tags":["AI"]},{"title":"HTML的学习","path":"/2025/02/03/HTML的学习/","content":"https://www.runoob.com/html/html-tutorial.html HTML的标签什么是 HTML?HTML 是用来描述网页的一种语言。 123456HTML 指的是超文本标记语言: HyperText Markup LanguageHTML 不是一种编程语言，而是一种标记语言标记语言是一套标记标签 (markup tag)HTML 使用标记标签来描述网页HTML 文档包含了HTML 标签及文本内容HTML文档也叫做 web 页面 HTML文档的后缀名 html htm 以上两种后缀名没有区别，都可以使用。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 1234567对于设置 &lt;meta charset=&quot;utf-8&quot; /&gt; 后出现网页乱码问题，其实归根到底就是：你通过 meta 标签设置的编码和网页文件在保存时所使用的文档编码不相同造成的！至于有的人说什么 360 浏览器默认 GBK 会造成乱码，我只想说的是，只要你在 html 文件里写了 &lt;!doctype hmtl&gt;和 &lt;meta charset=&quot;utf-8&quot; /&gt;，浏览器就绝对会按照 utf-8 编码解析网页，没有第二种可能！再次重点说明：保存 html 文件时，文档编码和 meta 设置的编码，一定要相同，只要不相同，就一定会出现乱码！之所以一定要写上 &lt;!doctype html&gt;，就是为了防止浏览器的怪异模式，强制浏览器按照标准模式渲染网页！ HTML的元素 HTML 属性属性是 HTML 元素提供的附加信息。 属性通常出现在 HTML 标签的开始标签中，用于定义元素的行为、样式、内容或其他特性。 属性总是以 name&#x3D;”value” 的形式写在标签内，name 是属性的名称，value 是属性的值。","tags":["前端"]},{"title":"硬件基础篇-显示屏幕","path":"/2025/01/20/硬件基础篇-显示屏幕/","content":"前言常见的什么数码管，4p小屏幕就略过了，重点关注不知道的知识 https://lceda001.feishu.cn/wiki/NiQKwDgsuiwLiHkCtFtcZnoFnFg 立创的教程https://blog.csdn.net/qq_28877125/article/details/123076973 屏幕40pin 分类 显示模组分类和特点按显示技术分类 技术 分类 特点 应用 LCD TN 价格低，响应快，视角和色彩表现较差 智能手机、工业设备 IPS 视角广，色彩还原好，适用于高端显示 高端显示设备 VA 对比度高，适合深色与亮色对比强烈的场景 电视、专业显示器 STN 多用于字符显示和简单图形显示 工业设备、家用电器 OLED PMOLED 结构简单，适合小尺寸显示 小型智能设备 AMOLED 高亮度、色彩丰富，广泛用于高端设备 智能手机、可穿戴设备 MicroLED - 超高亮度、高对比度、低功耗，几乎没有缺点，但成本高 高端电视、显示墙、AR设备 EPD（墨水屏） - 类似纸张显示，无需背光，耗电低，适合静态内容 电子书、电子价签 按接口分类 接口类型 特点 应用场景 并行接口 数据传输快，但接口引脚多（如RGB接口） 工业控制、高速刷新需求 串行接口 SPI&#x2F;I2C：数据线少，简单易用，传输速度较慢 小尺寸显示屏（OLED、电子纸） MIPI DSI：传输速率高，适合高清显示 智能手机、平板电脑 HDMI&#x2F;DP：支持高分辨率和音频传输 显示器、电视 LVDS 高带宽，抗干扰能力强 笔记本电脑、工业显示 eDP LVDS升级版，支持更高分辨率和更低功耗 笔记本电脑、平板电脑 触摸方式比较电容屏与电阻屏对比 特性 电阻屏 电容屏 触控原理 通过压力使导电层接触产生电阻变化 利用人体电流感应 灵敏度 较低，需用力触控 高，轻触即可 多点触控 不支持 支持 触控工具 支持手指、手套、触控笔等 需导电体（手指或专用触控笔） 耐用性 容易磨损 更耐用，抗划伤 显示效果 光透过率低，显示暗淡 光透过率高，显示明亮 成本 较低 较高 应用场景 工业设备、医疗设备等 智能手机、平板电脑等消费电子设备 总结 电阻屏：成本低、支持精确输入，适合工业或特殊环境。 电容屏：触控灵敏、显示效果好，适合智能设备和消费电子产品。","tags":["硬件基础"]},{"title":"电脑知识基础-固态选购","path":"/2025/01/20/电脑知识基础-固态选购/","content":"前言由于运行虚拟机的电脑磁盘不够大了，需要增加固态。soc的SDK大小较大。由于固态太贵了，决定小黄鱼入手，M2为主 固态 NVME协议的M.2固态 SATA协议的SSD2.5寸固态 选购参数 颗粒类型与颗粒等级 主控 独立缓存 颗粒类型（SLC,MLC,TLC,QLC） M2固态规格22110，2280（多），2260，2242","tags":["电脑基础"]},{"title":"电子基础科普篇-CPU架构","path":"/2025/01/15/电子基础科普篇-CPU架构/","content":"前言本篇针对一些关于CPU知识的扫盲包括但不限于以下内容 CPU的基本构造 CPU的架构 CPU的发展 CPU的性能评判 CPU的基本构造CPU（中央处理器）的基本单元可以分为多个核心模块，这些模块共同完成指令的获取、解码、执行和结果存储等功能。以下是 CPU 的主要基本单元及其功能： 1. 控制单元（Control Unit, CU） 功能： 负责指令的解码和控制信号的生成。 指挥其他单元协调工作，控制数据流和操作步骤。 核心任务： 从内存中取出指令（Fetch）。 解析指令含义（Decode）。 向其他模块发送控制信号（例如启动运算或存储操作）。 2. 运算单元（Arithmetic Logic Unit, ALU） 功能： 执行算术运算（加法、减法等）。 执行逻辑运算（与、或、非、异或等）。 执行比较操作（如大于、小于、等于判断）。 作用： 处理 CPU 中大部分的数据计算任务。 3. 寄存器（Registers） 功能： 提供 CPU 内部快速存储数据的位置，用于存放指令、操作数和中间结果。 种类： 通用寄存器：用于临时存储数据或中间计算结果（如 R1、R2）。 专用寄存器： 程序计数器（PC, Program Counter）：存储下一条指令的地址。 指令寄存器（IR, Instruction Register）：存储当前正在执行的指令。 状态寄存器（Flags Register）：保存运算状态（如进位、溢出、零标志等）。 4. 缓存（Cache） 功能： 临时存储频繁使用的数据和指令，减少从主存（RAM）取数的时间。 层次： L1 Cache：直接嵌入到 CPU 核心中，速度最快，容量最小。 L2 Cache：容量比 L1 大，速度略慢。 L3 Cache：共享缓存，用于多核心 CPU。 5. 总线接口单元（Bus Interface Unit, BIU） 功能： 负责 CPU 与外部设备（如内存、输入输出设备）之间的数据传输。 总线种类： 数据总线：传输数据。 地址总线：指定数据的存储位置。 控制总线：传输控制信号。 6. 解码单元（Decoder） 功能： 将取出的指令翻译为 CPU 能够识别的控制信号。 配合控制单元，确定指令操作类型和目标操作数。 7. 流水线单元（Pipeline Unit） 功能： 将指令的执行过程分成多个阶段（如取指、解码、执行、写回）。 允许多条指令同时在不同阶段处理，提高执行效率。 8. 浮点运算单元（Floating Point Unit, FPU） 功能： 专门负责浮点数运算（如小数的加减乘除）。 重要性： 提高复杂计算（如科学计算、3D 渲染）的速度。 9. 分支预测单元（Branch Predictor） 功能： 预测程序中的分支（如 if-else）走向。 作用： 减少流水线中的停顿，提升 CPU 的执行效率。 10. 内存管理单元（Memory Management Unit, MMU） 功能： 管理 CPU 和内存之间的地址映射。 提供虚拟内存支持，实现地址转换和访问权限控制。 11. 时钟与同步单元 功能： 提供系统时钟信号，控制各个模块的同步操作。 时钟频率： 直接影响 CPU 的运行速度。 12. 多核与线程单元 功能： 每个核心可以独立运行任务，多核 CPU 提供更强大的并行计算能力。 支持超线程（Hyper-Threading）技术，虚拟出更多的逻辑处理单元。 总结CPU 的各个基本单元协同工作，形成一个高效的数据处理和指令执行系统。根据需求的不同，现代 CPU 不仅包含传统的运算和控制模块，还加入了更多专用单元（如 GPU 集成单元、AI 加速单元等）以适应更复杂的应用场景。 CPU的指令集架构常见架构： x86厂商：Intel、AMD特点：CISC（复杂指令集计算机）架构，性能强大，主要用于个人电脑、服务器。应用场景：桌面电脑、服务器、大型计算任务。 ARM厂商：ARM Holdings（架构设计），Qualcomm、Apple 等厂商基于其设计芯片。特点：RISC（精简指令集计算机）架构，低功耗，高效率，广泛用于移动设备。应用场景：智能手机、平板电脑、嵌入式设备、物联网。 RISC-V特点：开源 RISC 架构，可定制，灵活性高，支持硬件和软件开源开发。应用场景：物联网、嵌入式设备、教育和研究领域。 LoongArch龙芯CPU，国产CPU,不太常见（消费级） CPU的发展PC机(x86)的CPU制造厂家,Inter and AMD 【想知道作为电子数字世界大脑的CPU是如何发展至今的吗？【CPU发展史｜仿生之旅】】 https://www.bilibili.com/video/BV1ME421A78n/?share_source=copy_web&amp;vd_source=59d9734fc97a6b9510465651bf85b98c 关键词卡片 纸带图灵 图灵机 图灵完备 指令ABC机 类指令 通常是指计算机架构中与特定类型的指令相关的指令集。类指令可以被分为多个类别，每个类别包含具有相似功能或目的的指令。它们通常与 CPU 指令集架构（ISA）有关，并描述如何在处理器中执行某些操作。 IBM公司战争 真空电子管 军方需求冯诺依曼 五大部件 哈佛存储架构其他架构 集成电路 光刻技术八大逆徒 美国仙童半导体薄膜技术 光蚀刻技术MOS摩尔定律inter … 硅谷沃森 多线程 IBM 指令集架构4001ROM 4002RAM 4003移位寄存器 4004逻辑运算芯片（cpu）8080 8086（x86架构）精简指令集arm(单片机)AMD 32-&gt;642010 RISC-V1985 赛灵思XILINX FPGA CPU的性能评判 超线程与线程分裂技术inter AMD 微架构 IPC","tags":["电子科普"]},{"title":"python的基本语法","path":"/2025/01/14/python的基本语法/","content":"前言花费点时间重新学习一下python语法 使用python语言的目的 爬虫编写 自动化脚本 神经网络 基础语法爬虫爬虫的矛与盾 反爬机制 反反爬机制 robots.txt 渲染方式 HTTP 协议简介HTTP（HyperText Transfer Protocol，超文本传输协议） 是一种用于在 Web 客户端（如浏览器）和服务器 之间通信的应用层协议。它是万维网（World Wide Web）中信息交换的基础，用于传输超文本（HTML）、图片、视频等资源。 1. HTTP 的核心特点 基于请求-响应模型： 客户端发送请求，服务器返回响应。 每次通信包含一个请求和一个响应。 无状态： HTTP 本身不记录每次请求的上下文信息。 可通过 Cookie、Session 或 Token 机制实现状态管理。 灵活性： 支持多种数据格式（如文本、JSON、XML、图片、视频等）。 能通过扩展实现新功能（如 HTTPS 支持加密通信）。 无连接： 每次请求与响应后，客户端和服务器之间的连接会关闭（HTTP&#x2F;1.0）。 HTTP&#x2F;1.1 开始支持持久连接（Keep-Alive）。 2. HTTP 工作流程 客户端向服务器发送一个 HTTP 请求。 服务器处理请求，并返回一个 HTTP 响应。 客户端接收到响应后，呈现内容或进一步处理。 请求示例：1234GET /index.html HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0Accept: text/html 响应示例：12345678HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1234&lt;html&gt;&lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 3. HTTP 请求方法 方法 作用 描述 GET 请求资源 不包含请求体，仅用于获取数据。 POST 提交数据 常用于表单提交、数据上传等操作。 PUT 更新资源 用于上传或替换指定资源。 DELETE 删除资源 请求服务器删除指定资源。 HEAD 获取资源的元信息（无响应体） 用于获取资源的状态或头信息。 OPTIONS 查询服务器支持的请求方法 常用于跨域请求检查。 PATCH 部分更新资源 更新资源的部分内容。 4. HTTP 状态码HTTP 状态码是服务器对客户端请求的响应结果，分为以下五大类： 类别 范围 描述 1xx 100-199 信息性响应（请求已接收，继续处理） 2xx 200-299 成功响应（请求成功处理） 3xx 300-399 重定向（需要进一步操作完成请求） 4xx 400-499 客户端错误（请求有问题） 5xx 500-599 服务器错误（服务器无法处理请求） 常见状态码： 200 OK：请求成功。 301 Moved Permanently：永久重定向。 302 Found：临时重定向。 400 Bad Request：客户端请求无效。 401 Unauthorized：需要认证。 403 Forbidden：服务器拒绝请求。 404 Not Found：请求的资源不存在。 500 Internal Server Error：服务器内部错误。 5. HTTP 的重要概念1. URL（Uniform Resource Locator，统一资源定位符）URL 是资源的地址，结构如下： 1协议://主机名[:端口]/路径[?查询参数][#片段标识符] 示例： 1https://www.example.com:8080/index.html?search=test#section1 2. HTTP Headers（请求头和响应头）Headers 包含请求或响应的元信息，例如内容类型、长度、认证信息等。 常见请求头： Host：目标服务器地址。 User-Agent：客户端信息。 Accept：客户端支持的媒体类型。 Authorization：认证信息。 常见响应头： Content-Type：响应的内容类型。 Content-Length：响应内容的字节数。 Set-Cookie：设置 Cookie。 3. HTTP 和 HTTPS HTTP：明文传输，安全性较低。 HTTPS：通过 SSL&#x2F;TLS 加密，提供数据安全性和完整性。 6. HTTP 协议的版本 版本 特性 HTTP&#x2F;1.0 无状态，无连接，每次请求需建立新连接。 HTTP&#x2F;1.1 支持持久连接（Keep-Alive），头部字段可压缩。 HTTP&#x2F;2 支持多路复用、头部压缩、更高效的资源传输。 HTTP&#x2F;3 基于 QUIC 协议，进一步提升传输性能和安全性。 7. HTTP 的优缺点优点： 简单易用。 灵活支持多种数据格式。 应用广泛，几乎所有 Web 应用都基于 HTTP。 缺点： 无状态：需要额外机制管理会话状态。 安全性：原生 HTTP 无加密，容易被攻击（如窃听、篡改）。 总结HTTP 是现代 Web 通信的基础，简单灵活，但也面临安全和性能问题。随着技术的发展，HTTPS、HTTP&#x2F;2 和 HTTP&#x2F;3 已成为趋势，为用户带来更安全、高效的体验。 get·与·post","tags":["python"]},{"title":"硬件基础实践-USB2.0分线器的制作","path":"/2025/01/13/硬件基础实践-USB2-0分线器的制作/","content":"前言USB2.0的分线器较为简单，主要是以2.0的芯片为核心 USB2.0 HUB芯片常用国产 SL2.1A CH334 和CH335 GL850G(台湾) 基于SL2.1A的USB2.0的设计芯片给的示例图 立创的原理图及其解析 增加额外供电口，但没加反接保护，和防静电等 PCB设计 3D图 外壳及其实物 简单测试（未有标准）","tags":["硬件基础实践"]},{"title":"爬虫练习-网页自动检索18禁网站","path":"/2025/01/08/爬虫练习-网页自动检索18禁网站/","content":"基本思路： 通过查询网(“https://site.ip138.com“) 获取大量域名，域名可能会有需要的网站，爬虫伪装访问网站，获取网页源码，通过字符匹配，判断是否包含18禁内容 注意，目前代码能检索的出来的，说明网站基本未做任何防爬措施，判断安全的并不一定就不是18禁网站（也许这种性质的网站希望爬虫爬到） 文件结构 代码，先运行1_get.py，再2_on.py,检索到的文件会保存到sex.py文件中 1_get.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import requestsfrom bs4 import BeautifulSoupimport timedef fetch_domains(url, request_count=10, interval=5, file_path=&quot;domain_results.txt&quot;): &quot;&quot;&quot; 从指定 URL 获取最新域名信息并追加保存到文件。 :param url: 目标网站 URL :param request_count: 请求次数，None 表示无限循环 :param interval: 请求间隔（秒） :param file_pathe: 结果保存的文件名 &quot;&quot;&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36&quot; &#125; count = 0 while request_count is None or count &lt; request_count: response = requests.get(url, headers=headers) if response.status_code != 200: print(f&quot;请求失败，状态码: &#123;response.status_code&#125;&quot;) time.sleep(interval) continue soup = BeautifulSoup(response.text, &quot;html.parser&quot;) domain_list = [item.text for item in soup.select(&#x27;.result1 .group ul:nth-of-type(1) li a&#x27;)] with open(file_path, &quot;a&quot;) as f: for domain in domain_list: f.write(domain + &quot; &quot;) print(f&quot;最新查询结果已追加到 &#123;file_path&#125;&quot;) count += 1 time.sleep(interval)def remove_duplicates(file_path=&quot;domain_results.txt&quot;): &quot;&quot;&quot; 删除文件中的重复域名，并保持原有顺序。 :param file_path: 要去重的文件路径 &quot;&quot;&quot; try: with open(file_path, &quot;r&quot;) as f: lines = f.readlines() unique_domains = list(dict.fromkeys(line.strip() for line in lines)) # 保持顺序去重 with open(file_path, &quot;w&quot;) as f: for domain in unique_domains: f.write(domain + &quot; &quot;) print(f&quot;重复域名已删除，更新后的数据已保存到 &#123;file_path&#125;&quot;) except FileNotFoundError: print(f&quot;文件 &#123;file_path&#125; 不存在。&quot;)def remove_duplicates_2(file_path=&quot;domain_results.txt&quot;): &quot;&quot;&quot; 删除文件中的重复域名，并保持原有顺序，同时移除无法访问的域名。 :param file_path: 要去重和筛选的文件路径 &quot;&quot;&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) &quot; &quot;AppleWebKit/537.36 (KHTML, like Gecko) Version/14.0 &quot; &quot;Mobile/15E148 Safari/537.36&quot; &#125; try: with open(file_path, &quot;r&quot;) as f: lines = f.readlines() unique_domains = list(dict.fromkeys(line.strip() for line in lines)) # 保持顺序去重 valid_domains = [] for domain in unique_domains: url = f&quot;http://&#123;domain&#125;&quot; try: response = requests.get(url, headers=headers, timeout=10) if response.status_code == 200: valid_domains.append(domain) else: print(f&quot;删除无法访问的域名: &#123;domain&#125;, 状态码: &#123;response.status_code&#125;&quot;) except requests.RequestException: print(f&quot;删除无法访问的域名: &#123;domain&#125;&quot;) with open(file_path, &quot;w&quot;) as f: for domain in valid_domains: f.write(domain + &quot; &quot;) print(f&quot;重复域名已删除，无法访问的域名已移除，更新后的数据已保存到 &#123;file_path&#125;&quot;) except FileNotFoundError: print(f&quot;文件 &#123;file_path&#125; 不存在。&quot;)# 示例调用if __name__ == &quot;__main__&quot;: fetch_domains(&quot;https://site.ip138.com/&quot;, request_count=10, interval=5,file_path=&quot;data/test.txt&quot;) remove_duplicates_2(file_path=&quot;data/test.txt&quot;) 代码，2_on.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import requestsfrom bs4 import BeautifulSoupimport redef is_adult_content(url): &quot;&quot;&quot; 伪装成手机设备访问指定网站，并判断是否包含成人内容。 :param url: 目标网站 URL :return: 是否为成人内容（True/False） &quot;&quot;&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) &quot; &quot;AppleWebKit/537.36 (KHTML, like Gecko) Version/14.0 &quot; &quot;Mobile/15E148 Safari/537.36&quot; &#125; try: response = requests.get(url, headers=headers, timeout=10) if response.status_code != 200: print(f&quot;访问失败: &#123;url&#125;, 状态码: &#123;response.status_code&#125;&quot;) return False response.encoding = response.apparent_encoding soup = BeautifulSoup(response.text, &quot;html.parser&quot;) text_content = soup.get_text().lower() # with open(&quot;data/example.txt&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;) as f: # f.write(text_content) # 关键词列表（可以扩展） adult_keywords = [&quot;porn&quot;, &quot;sex&quot;, &quot;xxx&quot;, &quot;adult&quot;, &quot;erotic&quot;, &quot;nude&quot;, &quot;hentai&quot;, &quot;18+&quot;, &quot;爱情&quot;, &quot;女神&quot;,&quot;线路&quot;,&quot;澳门&quot;,&quot;vip&quot;,&quot;撸&quot;, &quot;麻豆&quot;,&quot;天美&quot;,&quot;精东&quot;,&quot;糖心&quot;,&quot;有码&quot;,&quot;无码&quot;] for keyword in adult_keywords: if keyword in text_content: return True return False except requests.RequestException as e: print(f&quot;请求异常: &#123;url&#125;, 错误: &#123;e&#125;&quot;) return Falsedef check_domains(file_path=&quot;domain_results.txt&quot;): &quot;&quot;&quot; 读取 domain_results.txt，检测其中的域名是否包含成人内容。 :param file_path: 域名列表文件 &quot;&quot;&quot; try: with open(file_path, &quot;r&quot;) as f: domains = [line.strip() for line in f if line.strip()] for domain in domains: full_url = f&quot;http://&#123;domain&#125;&quot; if is_adult_content(full_url): print(f&quot;⚠️ 检测到成人内容: &#123;domain&#125;&quot;) with open(&quot;data/sex.txt&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;) as f: f.write(full_url+ &quot; &quot;) else: print(f&quot;✅ 安全: &#123;domain&#125;&quot;) except FileNotFoundError: print(f&quot;文件 &#123;file_path&#125; 不存在。&quot;)# 运行检测test_file = &quot;data/test.txt&quot;check_domains(test_file)","tags":["爬虫练习"]},{"title":"基于标准库的STM32的开发","path":"/2025/01/06/基于标准库的STM32的开发/","content":"前言总算成功进入STM32的学习之旅。 GPIO这里只介绍GPIO的数字输入与输出，常见有八个函数。引脚默认浮空输入模式 CPIOA,GPIOB,GPIOC，每个16个引脚 PA0-PA15… 有上拉和下拉输入电阻，推挽模式下，PMOS和NMOS都导通，开漏模式只有Nmos导通，开漏模式用于信号或者其他电压的上拉，关闭模式下，PNMOS都关闭 以下是 STM32 标准外设库中几个 GPIO 操作函数的区别和作用： 1. GPIO_SetBits(GPIOx, GPIO_Pin_x) 作用： 将指定引脚的电平设置为 高电平。 实现原理： 通过设置寄存器中的某个位，将引脚输出逻辑高（通常对应 3.3V 或 1.8V，具体取决于芯片电源电压）。 用法：1GPIO_SetBits(GPIOC, GPIO_Pin_13); // 将 PC13 引脚设置为高电平 2. GPIO_ResetBits(GPIOx, GPIO_Pin_x) 作用： 将指定引脚的电平设置为 低电平。 实现原理： 通过清除寄存器中的某个位，将引脚输出逻辑低（通常对应 0V）。 用法：1GPIO_ResetBits(GPIOC, GPIO_Pin_13); // 将 PC13 引脚设置为低电平 3. GPIO_WriteBit(GPIOx, GPIO_Pin_x, BitAction BitVal) 作用： 根据传入的参数 BitVal，设置引脚为高电平或低电平。 参数： Bit_RESET：设置引脚为 低电平。 Bit_SET：设置引脚为 高电平。 实现原理： 在底层实现中，会根据传入的 BitVal 选择性调用 SetBits 或 ResetBits。 用法：12GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); // 设置 PC13 为高电平GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_RESET); // 设置 PC13 为低电平 4. GPIO_Write(GPIOx, uint16_t PortVal) 作用： 一次性设置 GPIO 端口（GPIOx）的所有引脚的电平状态。 直接写入 PortVal，每一位对应一个引脚。 参数： PortVal：16 位数据，其中每一位控制对应引脚的电平。 例如，PortVal = 0x0001 设置 Pin_0 高电平，其他引脚低电平。 用法：12GPIO_Write(GPIOC, 0xFFFF); // 设置 GPIOC 的所有引脚为高电平GPIO_Write(GPIOC, 0x0000); // 设置 GPIOC 的所有引脚为低电平 总结区别： 函数名 功能描述 精细程度 用途 GPIO_SetBits 将某个或多个引脚设置为高电平 控制单个或多个引脚 简单设置某些引脚为高电平 GPIO_ResetBits 将某个或多个引脚设置为低电平 控制单个或多个引脚 简单设置某些引脚为低电平 GPIO_WriteBit 根据传入参数设置单个引脚为高或低电平 控制单个引脚 需要更精确地控制单个引脚的高低电平 GPIO_Write 设置整个 GPIO 端口的所有引脚电平 控制整个端口 同时操作整个端口的所有引脚，适合同时控制多个引脚的状态，如并行数据通信等 使用建议： 如果需要操作单个引脚，推荐使用 GPIO_SetBits、GPIO_ResetBits 或 GPIO_WriteBit。 如果需要同时操作整个端口的引脚，可以使用 GPIO_Write。 注意： 使用 GPIO_Write 时会覆盖整个端口的状态，因此需要慎用。 中断 https://blog.csdn.net/m0_56399733/article/details/134979299 抢占优先级与响应优先级抢占优先级高的可以中断嵌套 外部中断 相同pin脚指PA0与PB1,PC1,都是1,PA0和PA1,作为中断就可以","tags":["STM32"]},{"title":"使用platformio开发stm32标准库","path":"/2025/01/06/使用platformio开发stm32标准库/","content":"前言网上很多教程都不太合适，大多是基于正定原子的库，这里使用的单片机是STM32F103c8t6,烧录器为stlink。默认大家VScode和platformio已经安装好了 开始 name为工程名称，board为板子类型，framework为架构，标准库架构为CMSIS单击finish开始创建，建议开梯子，更快，打开如下 然后我们得删除一些东西，防止定义冲突下图文件全部删除 下图文件system_stm32flxx删除 下图文件删除，vscode使用c++编译器 从官网下载固件包，这里使用3.5版本 将STM32F10x_StdPeriph_Driver复制到src文件下 在src文件下创建main.c文件 将下面.h文件复制到include,.c文件复制到srcSTM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x 进入编译器选择，选择startup_stm32f10x_md，根据实际单片机选择，复制到src下 将下面几个文件.h复制到include,。.c复制到src, 替换即可 结果如下 修改代码 12345678910111213[env:genericSTM32F103C8]platform = ststm32board = genericSTM32F103C8framework = cmsisdebug_tool = stlink ;调试器upload_protocol = stlink ;烧录器build_flags = -I src/STM32F10x_StdPeriph_Driver/inc ;库函数 -D USE_STDPERIPH_DRIVER ;宏定义 -D STM32F10X_MD main写入代码 1234567#include &quot;stm32f10x.h&quot;int main(void)&#123; while(1)&#123; &#125;&#125; 删除这两行代码，”C:&#x2F;Users&#x2F;Lenovo&#x2F;.platformio&#x2F;packages&#x2F;framework-cmsis-stm32f1&#x2F;Include”,这个，删除该文件这个代码 电机左下的对勾，编译","tags":["STM32"]},{"title":"硬件基础篇-pcb规则","path":"/2025/01/03/硬件基础篇-pcb规则/","content":"前言规则只是在有前辈总结，但很多自己没有验证或缺乏验证时使用的一种经验，科学吗？不知道。随着PCB工艺的发展，一些规则是否仍然需要遵从，是否适用，依然是个问题，但规则能够帮助初学者提供一种相对正确的规范，仍然具备其价值。 将包括以下部分，尽可能的做道图文并茂 流程处理 板框处理 元件布局处理 走线处理由于是内容互有穿插，就不二级标题按此划分 关于晶振包地的处理规则 晶振靠近芯片； 晶振电路包地； 起振电容（负载电容）靠近晶振； 晶振下面第二层挖空； 晶振不能靠近板边； 晶振下面所有层不能布线。 是第二层掏掉，第三，第四层地不用掏，双面板底层不用掏","tags":["硬件基础"]},{"title":"硬件进阶篇-阻抗匹配","path":"/2025/01/02/硬件进阶篇-阻抗匹配/","content":"前言阻抗匹配是高速信号的基础，但很显然目前的我对此还是一知半解，所以就单开一章来谈一谈这个问题 什么是阻抗匹配 阻抗(Electrical Impedance)是电路中电阻、电感、电容对交流电的阻碍作用的统称。阻抗常用Z表示，单位是欧姆 Ω，对于一个具体电路，阻抗不是不变的，其数值由交流电的频率、电阻R、电感L、电容C相互作用来决用，随着频率变化而变化。 阻抗匹配(Impedance Matching)是指信号源或传输线与负载之间一种合适的匹配方式，分为低频和高频。因为频率和波长反比，在低频电路中，波长相对于传输线来说很长，传输线可以看成是“短线”，反射可以不考虑。而在高频电路中，波长很短，当信号的波长短得跟传输线长度可以比拟时，反射信号叠加在原信号上将会改变原信号的形状，从而影响信号质量。","tags":["硬件基础"]},{"title":"硬件进阶篇-模数分离","path":"/2024/12/31/硬件进阶篇-模数分离/","content":"模数分离由单点接地与多点接地引出，会在这一章进行具体学习信号线跨接如何通过磁珠连接还需要案例 【模数混合电路的PCB设计分割】 https://www.bilibili.com/video/BV1b4411h7Mu/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6 数字与模拟信号 模拟信号抗干扰能力小，防止数字信号干扰模拟信号，不同模拟之间也会相互干扰，也需隔离 数字地与模拟地的处理 案例分析 红色是数字地，绿色是模拟地，两者分开，通过磁珠&#x2F;0欧电阻相连，也可单点接地信号线不要跨分割，最好用磁珠连接如果是模拟的，区域所有层都是模拟的 负片层与正片层 正片层表示铜箔或焊接掩模图案中 需要保留的部分，即图案显示的地方实际会有铜或焊接掩模存在。负片层表示铜箔或焊接掩模图案中 需要去除的部分，即图案显示的地方实际会被移除","tags":["硬件基础"]},{"title":"硬件进阶篇-层叠结构","path":"/2024/12/26/硬件进阶篇-层叠结构/","content":"前言这是进阶篇的第一篇文章，设计到高速信号，现在基本都要求四层板及其以上了 高速信号的重要方面 叠层设计 阻抗匹配 信号协议 模数分离 模数分离由单点接地与多点接地引出，会在下一章进行具体学习 信号完整性概念：信号在传输过程中能够保持原有形态，准确的到达目标设备。 分析方法 建模和仿真，实际电路测试 电磁仿真和电路仿真 基础知识 时域和频域的信号 周期 上升时间 频谱 带宽 傅里叶变换 阻抗 阻抗对信号完整性的影响（阻抗不连续，地弹，电源轨道塌陷） 构成阻抗的因素（基本的理想元件与实际元件，寄生参数） 传输线（主要） 传输线模型（无损传输线，有损传输线） 传输线特征阻抗（双绞线同轴电缆，微带线，带状线） 阻抗匹配与反射 串扰 损耗与衰减 差分线 三大研究领域 微带线与带状线微带线（一面介质，一面空气）带状线（两面介质） 回流路径 最小阻抗原则 层叠设计基本原则 S(信号层) G(地层，最优参考层) P(电源层，次优参考层) 1.每个信号层要有比较好的参考面2.电源层与地层应耦合在一起3.信号层不要相邻，不要平行走线，防止信号串扰 【PCB_四层六层八层叠层经典设计方案】 https://www.bilibili.com/video/BV1oH4y1V7zA/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6 四层板方案设计首选方案：S1,G,P,S2 六层板方案设计首选方案：S2,G,S1,P,G,S3 方案1，电磁与地平面的耦合不好方案2，TOP与BUTTON层参考不好 八层板方案设计首选方案：S4,G,S1,P,G,S2,G,S3 接地单点接地与多点接地 串联接地会发生信号串扰，并联接地会使接地线过多 混合接地指的不是单点接地和多点接地混合用，混合接地有两种情况，1，用电容把两个地连接起来，在高频时电容相当于导线，也就是多点接地，低频时电容相当于断开，也就是单点接地。2，用电感链接两个地，高频时断开相当于单点接地，低频时短接相当于多点接地，这样才是混合","tags":["硬件基础"]},{"title":"硬件基础篇-标识篇","path":"/2024/12/25/硬件基础篇-标识篇/","content":"前言电路板上常常会有很多标识，那么这些标识都是什么意思呢？ 常见标识 VCC GND VEE 负电压，出现在常用于运算放大器、电机驱动等电路中。 VDD 表示供电电压，特别是对于 MOSFET 或 CMOS 电路来说，VDD 通常是指正电压源。VDD 也可以用于表示其它种类的正电源。 VSS VSS 常用于数字电路中，表示地（地电压）。在 CMOS 电路中，VSS 一般是地，VDD 是正电源。 电路板上常见的标识有很多，通常用于指示电源、信号线、接地等。以下是一些常见标识及其含义： 1. VCC（Voltage Common Collector） 含义：通常表示正电源电压。VCC 是 “Voltage at the Common Collector” 的缩写，常用于集成电路（IC）和其他元器件的电源引脚。VCC 通常与电路板上的正电源连接。 常见电压：5V、3.3V 等。 2. GND（Ground） 含义：表示地（接地）或零电压参考点。在电路中，GND 是电路的共同地，所有的信号和电源都相对于 GND 定义电压。接地可以减少噪声，保证电路正常工作。 3. VDD（Voltage Drain Drain） 含义：表示供电电压，特别是对于 MOSFET 或 CMOS 电路来说，VDD 通常是指正电压源。VDD 也可以用于表示其它种类的正电源。 4. VSS（Voltage Source Source） 含义：VSS 常用于数字电路中，表示地（地电压）。在 CMOS 电路中，VSS 一般是地，VDD 是正电源。 5. VEE 含义：表示负电源电压，常用于运算放大器、电机驱动等电路中。 6. 3.3V、5V、12V 等 含义：这些标识直接表示电路板上的电压值，通常是电源引脚或者输入电源端口。这些标识对应的是不同的电源电压，分别用于供电给不同的元器件，如微控制器、传感器、LED等。 7. A、B、C 等 含义：常用于表示信号线，特别是在模拟信号或差分信号传输中。例如，A&#x2F;B 线可以是差分信号的正负极。C、D 等可能是其他信号通道的标识。 8. SDA &#x2F; SCL 含义：在 I2C 总线通信中，SDA 是数据线（Serial Data），SCL 是时钟线（Serial Clock）。这两个线用于微控制器之间的通信。 9. TX &#x2F; RX 含义：表示串口通信中的发送（TX）和接收（RX）信号。TX 是数据传输线，RX 是数据接收线，通常用于 UART、RS232 或其他串行通信协议。 10. PWM 含义：表示脉宽调制（Pulse Width Modulation）信号。常用于控制电机速度、LED亮度等应用。PWM 信号的频率和占空比决定了控制设备的输出效果。 11. RST（Reset） 含义：表示复位引脚。复位引脚通常用于初始化系统或设备，将其恢复到默认状态。 12. NC（No Connection） 含义：表示该引脚没有连接，也没有实际用途。通常用于封装或设计时的占位。 13. TP（Test Point） 含义：表示测试点。测试点是电路板上为便于调试、测试和测量而特意设计的引脚或位置，通常连接到某些重要的信号线上。 14. F0, F1, F2 等 含义：用于表示滤波器或频率响应标识，常见于电源滤波电路或者其他高频电路。 15. PWR 含义：表示电源或电源输入端。通常用于电源模块或设备的电源输入引脚。 16. LED、LD 含义：表示LED（发光二极管）的位置，LD 通常是指 LED 灯的标识。 17. C、R、L、D 含义： C：电容器（Capacitor） R：电阻器（Resistor） L：电感器（Inductor） D：二极管（Diode） 18. F（Fuse） 含义：表示保险丝。通常用于过电流保护，电路中常常有保险丝标识。 19. Jumper 含义：用于连接电路中两个点的跳线，常见于设置电路选项、开关配置等。 20. V+ &#x2F; V- 含义：分别表示正电压和负电压。常用于表示双极性电源电路中的两个电压极。 总结：这些标识帮助我们理解电路板的设计和功能，确保连接正确、功能正常。每个标识都有特定的意义，理解这些标识对于设计和调试硬件电路非常重要。","tags":["硬件基础"]},{"title":"驱动的备份与安装","path":"/2024/12/23/驱动的备份与安装/","content":"驱动的导出在C盘新建文件夹 以管理员的身份运行powershell 运行代码,文件名为自己的文件夹 1dism /online /export-driver /destination:&quot;c:\\win10leglon&quot; 驱动的安装1.打开设备管理器2.找到带感叹号的设备 点击我的电脑以查找驱动程序选择驱动程序，确认，将会自动更新","tags":["系统折腾"]},{"title":"步进电机","path":"/2024/12/09/步进电机/","content":"步进电机基本原理典型电机 两相42步进电机 四相28BYJ-48步进电机 两相42步进电机 步进角1.8度 四相28BYJ-48步进电机 步进角约为0.0879 步进电机参数 基座号 步距角 相数 保持转矩 额度电流 详细导程和力矩的计算在视频里 【8分钟讲透步进电机的选型参数、流程和计算公式】 https://www.bilibili.com/video/BV17q421A7QK/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6 步进电机驱动及其使用（）","tags":["电机基础"]},{"title":"硬件基础篇-MOS","path":"/2024/11/30/硬件基础篇-MOS/","content":"前言我有预感，这章很重要，比前面几章基础篇都来的重要，MOS的应用及其广泛，驱动电路必不可少，低压领域注定存在，大杀四方。 NMOS与PMOS的基础知识 N沟道增强型管（NPN） N沟道耗尽型管 P沟道增强型管 P沟道耗尽型管 增强型，指沟道从无到有，耗尽型反之 注意方向，GS连在一起 NMOS管的主回路电流方向为D→S，导通条件为VGS有一定的压差，Vgs大于一定的值就会导通，一般为510V（G电位比S电位高）；PMOS管的主回路电流方向为S→D，导通条件为VGS有一定的压差，Vgs小于一定的值就会导通，一般为-5-10V（S电位比G电位高） 等效模型 NMOS可看成电压控制的电阻 MOS的重要参数 封装 Vgsth Rdson （MOS管完全打开时的DS电阻，越小越好） Cgs （GS之间的寄生电容，一般大小与Rdson成反比，影响打开速度） 实际手册（中英文）实际应用开关电路","tags":["硬件基础"]},{"title":"大创小车的底盘控制","path":"/2024/11/25/大创小车的底盘控制/","content":"下位机采用arduino,代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 定义轮子控制引脚#define LEFT_FRONT_PWM 3#define LEFT_FRONT_DIR 4#define RIGHT_FRONT_PWM 5#define RIGHT_FRONT_DIR 6#define LEFT_REAR_PWM 9#define LEFT_REAR_DIR 10#define RIGHT_REAR_PWM 11#define RIGHT_REAR_DIR 12void setup() &#123; // 设置控制引脚为输出模式 pinMode(LEFT_FRONT_PWM, OUTPUT); pinMode(LEFT_FRONT_DIR, OUTPUT); pinMode(RIGHT_FRONT_PWM, OUTPUT); pinMode(RIGHT_FRONT_DIR, OUTPUT); pinMode(LEFT_REAR_PWM, OUTPUT); pinMode(LEFT_REAR_DIR, OUTPUT); pinMode(RIGHT_REAR_PWM, OUTPUT); pinMode(RIGHT_REAR_DIR, OUTPUT); // 初始化串口通信 Serial.begin(9600);&#125;void loop() &#123; if (Serial.available() &gt; 0) &#123; // 读取串口数据 String command = Serial.readStringUntil(&#x27; &#x27;); command.trim(); // 去除多余的空白符 if (command.length() == 5) &#123; // 通信测试命令 if (command == &quot;E0000&quot;) &#123; Serial.println(&quot;999&quot;); // 返回通信正常标志 return; // 不继续处理其他命令 &#125; // 停止所有轮子命令 if (command == &quot;S0000&quot;) &#123; stopAllMotors(); Serial.println(&quot;All motors stopped&quot;); return; // 不继续处理其他命令 &#125; // 解析命令 char wheel = command[0]; // 轮子标识符（A/B/C/D） int direction = command[1] - &#x27;0&#x27;; // 方向（0或1） int speed = command.substring(2).toInt(); // 速度（0-255） // 限幅处理 speed = constrain(speed, 0, 200); // 限制速度在0-200之间 // 根据轮子标识符设置对应电机 switch (wheel) &#123; case &#x27;A&#x27;: // 左前轮 setMotor(LEFT_FRONT_PWM, LEFT_FRONT_DIR, speed, direction); break; case &#x27;B&#x27;: // 右前轮 setMotor(RIGHT_FRONT_PWM, RIGHT_FRONT_DIR, speed, direction); break; case &#x27;C&#x27;: // 左后轮 setMotor(LEFT_REAR_PWM, LEFT_REAR_DIR, speed, direction); break; case &#x27;D&#x27;: // 右后轮 setMotor(RIGHT_REAR_PWM, RIGHT_REAR_DIR, speed, direction); break; default: Serial.println(&quot;Invalid command&quot;); // 错误命令提示 break; &#125; &#125; else &#123; Serial.println(&quot;Command length error&quot;); // 命令长度错误提示 &#125; &#125;&#125;// 设置电机函数void setMotor(int pwmPin, int dirPin, int speed, int direction) &#123; if (pwmPin == RIGHT_FRONT_PWM || pwmPin == RIGHT_REAR_PWM) &#123; direction = !direction; &#125; digitalWrite(dirPin, direction ? HIGH : LOW); analogWrite(pwmPin, speed); // 输出调试信息 Serial.print(&quot;Motor &quot;); Serial.print(pwmPin); Serial.print(&quot; set to speed: &quot;); Serial.print(speed); Serial.print(&quot;, direction: &quot;); Serial.println(direction ? &quot;Forward&quot; : &quot;Backward&quot;);&#125;// 停止所有轮子的函数void stopAllMotors() &#123; analogWrite(LEFT_FRONT_PWM, 0); analogWrite(RIGHT_FRONT_PWM, 0); analogWrite(LEFT_REAR_PWM, 0); analogWrite(RIGHT_REAR_PWM, 0); Serial.println(&quot;Motors stopped&quot;);&#125; 上位机测试遥控代码如下， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import serialimport keyboardimport time# 初始化串口SERIAL_PORT = &quot;COM7&quot; # 根据实际端口修改BAUD_RATE = 9600ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)# 初始化PWM和方向PWM = 30 # 默认速度DIRECTION = &#123; &quot;FORWARD&quot;: 1, &quot;BACKWARD&quot;: 0&#125;def send_command(wheel, direction, speed): &quot;&quot;&quot; 向下位机发送控制命令。 :param wheel: 轮子标识符 (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;) :param direction: 方向 (0 或 1) :param speed: 速度 (0-255) &quot;&quot;&quot; command = f&quot;&#123;wheel&#125;&#123;direction&#125;&#123;speed:03d&#125;&quot; ser.write((command + &quot; &quot;).encode()) print(f&quot;Sent: &#123;command&#125;&quot;)def stop_all_motors(): &quot;&quot;&quot;发送停止所有轮子的命令。&quot;&quot;&quot; ser.write(&quot;S0000 &quot;.encode()) print(&quot;Sent: S0000 (Stop all motors)&quot;)def control_car(): &quot;&quot;&quot; 通过键盘控制小车。 W: 前进 S: 后退 A: 左转 D: 右转 Q: 停止 &quot;&quot;&quot; global PWM try: print(&quot;Use W/A/S/D to control the car, Q to stop, +/- to adjust speed.&quot;) while True: if keyboard.is_pressed(&quot;w&quot;): # 前进 send_command(&quot;A&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 左前轮 send_command(&quot;B&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 右前轮 send_command(&quot;C&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 左后轮 send_command(&quot;D&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 右后轮 elif keyboard.is_pressed(&quot;s&quot;): # 后退 send_command(&quot;A&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 左前轮 send_command(&quot;B&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 右前轮 send_command(&quot;C&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 左后轮 send_command(&quot;D&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 右后轮 elif keyboard.is_pressed(&quot;a&quot;): # 左转 send_command(&quot;A&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 左前轮 send_command(&quot;B&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 右前轮 send_command(&quot;C&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 左后轮 send_command(&quot;D&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 右后轮 elif keyboard.is_pressed(&quot;d&quot;): # 右转 send_command(&quot;A&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 左前轮 send_command(&quot;B&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 右前轮 send_command(&quot;C&quot;, DIRECTION[&quot;FORWARD&quot;], PWM) # 左后轮 send_command(&quot;D&quot;, DIRECTION[&quot;BACKWARD&quot;], PWM) # 右后轮 elif keyboard.is_pressed(&quot;q&quot;): # 停止 stop_all_motors() time.sleep(0.2) elif keyboard.is_pressed(&quot;+&quot;): # 增加速度 PWM = min(255, PWM + 10) print(f&quot;Speed increased to: &#123;PWM&#125;&quot;) time.sleep(0.2) elif keyboard.is_pressed(&quot;-&quot;): # 减小速度 PWM = max(0, PWM - 10) print(f&quot;Speed decreased to: &#123;PWM&#125;&quot;) time.sleep(0.2) time.sleep(0.1) # 防止过度占用 CPU except KeyboardInterrupt: print(&quot;Program terminated.&quot;) stop_all_motors()if __name__ == &quot;__main__&quot;: control_car()","tags":["大创"]},{"title":"通讯篇-基于CH340的USB转TTL的研究","path":"/2024/11/20/通讯篇-基于CH340的USB转TTL的研究/","content":"前言在通讯设计中，USB转TTL是基础，CH340是使用较多的USB转TTL芯片，所以采用这个来介绍。 CH340的介绍CH340C和CH340B内置时钟 数据手册https://atta.szlcsc.com/upload/public/pdf/source/20220223/82A45E4FF89B3EDCAD50B354450A7EF4.pdf研制公司https://www.wch.cn/ CH340C&#x2F;N&#x2F;K&#x2F;E 及CH340B内置时钟，无需外部晶振，CH340B还内置EEPROM用于配置序列号等 具体介绍看中文手册 CH340转RS485 原理图设计如下使用CH340B，在外接5V电源是，3.3V需要100nf的退耦电容。pcb设计如下","tags":["通讯"]},{"title":"硬件基础篇-电阻电容电感","path":"/2024/11/17/硬件基础篇-电阻电容电感/","content":"前言虽然是电气专业，但学的东西仅限于考试那几天，似乎从来没有了解过电路的基础三大元件，所以单开一篇来说说这个。 电阻电感 电容","tags":["硬件基础"]},{"title":"微机原理与接口技术","path":"/2024/11/06/微机原理与接口技术/","content":"前言距离第一次接触51单片机已有两年之久，当时跟着江科大的视频学了两个星期，完成了一些基本操作，随后就不怎么接触了，而关于微机的底层和通讯在之后的时间里，一直都是零散的学习，刚好借助此次课程的机会，记录一下自己的微机的学习。只记录重要知识点，配合教材使用。 课程概述教材使用王晓萍的微机原理与接口技术教材分为3个部分进行教学 微控制器原理 微机接口技术 微机系统设计 微机概述微机两大分支 通用计算机（PC） 嵌入式计算机（MCU） 硬件结构知识点讲解基本结构 输入输出设备 存储器 控制器与运算器 存储结构分类 存算一体（哈佛结构） 存算分开（冯诺依曼结构） 0851硬件资源 CPU RAM(128B数据存储器) ROM(4K程序存储器) 4个8位IO口 2个16位定时器&#x2F;计数器 中断系统（5个中断源，2个优先级） 1个全双工串行口 SFR(21个特殊功能寄存器) 0851功能特点记忆点 内部RAM,256B（2^8）,地址为00H~FFH 外部RAM，最大64KB（2^16），地址0000H~FFFFH 内部ROM,4~64K,以8K为例(2^13) 外部ROM,最大64K，地址0000H~FFFFH 指令系统，复杂指令，CISC，111条。 0851功能引脚 RST 需要两个机器周期的高电平 EA 内部外部ROM片选，EA&#x3D;0,只内，EA&#x3D;1，在ROM大于FFH时转外部 ALE 低八位地址锁存允许信号输出端，有效时输出高脉冲 PSEN 与外部ROM的OE相连，外部ROM选通输出端 0851引脚功能示意图0851拓展外部ROM示意图指令系统 PC（程序计数器，16位） IR(指令寄存器，8位，存放当前指令的操作码) ID（指令译码器，） 指令执行过程 取指令 分析指令 执行指令 单片机的周期 时钟周期 $1&#x2F;f_{osc}$ 状态周期 $S &#x3D; 2&#x2F;f_{osc}$ 机器周期 $T_{M} &#x3D; 12&#x2F;f_{osc}$ 指令周期 执行一条指令所需要的时间。(单周期，双周期，四周期) 单片机的复位复位是微控制器的初始化操作 上电复位（冷启动） 按键复位（热启动） 复位后，表现为SFR的复位状态。 PC的值为0000H 堆栈指针SP的值为07H 四个IO锁存器输出为FFH，为准双向口模式的输入模式 其舍所有的SFR的有效值均为零。 注意：由于RAM数据在掉电后丢失，上电复位RAM数据为随机数，按键复位，内部RAM数据没有影响 文稿复位：复位是微控制器的初始化操作。单片机的复位有两种，上电复位（冷启动）和按键复位（热启动）。下面是上电和按键复位的电路图。上电复位时，需要要求高电平维持十毫秒以上，下面是上电复位RTS引脚的波形按键复位时，在按下按键后，电容放电，然后电源对电容进行充电，充电会形成一个类似于上电复位的波形，需要要求超过24个时钟周期的高电平，也就是两个机器周期的高电平，即可完成复位。复位后，表现为SFR(特殊功能寄存器)的复位状态。 PC的值为0000H 堆栈指针SP的值为07H 四个IO锁存器输出为FFH，为准双向口模式的输入模式 其舍所有的SFR的有效值均为零。 注意：由于RAM数据在掉电后丢失，上电复位RAM数据为随机数，按键复位，内部RAM数据没有影响 微控制器的工作模式微控制器的工作方式文稿：微控制器共有三种工作方式，低功耗工作方式，程序执行方式和复位方式。其中，低功耗工作方式（省电方式）又分为休闲方式和掉电方式。程序执行方式是微控制器的基本工作方式。复位方式，复位是微控制器的初始化操作，复位后，SFR内容恢复初始值，CPU重新开始运行低功耗方式又分为休闲方式和掉电方式。低功耗方式有电源控制寄存器PCON的IDL位和PD位控制。默认该两位为零，当pd为一的时候，进入掉电方式， Idl为一的时候，进入休闲方式，两者都为一的时候，进入掉电方式。 休闲方式(ID)时，内部时钟电路正常工作，CPU停止工作，中断，串行口定时器继续工作。可通过复位或者中断终止休闲方式。在休闲期间，中端触发后，IDL请0，退出休闲方式掉电方式（PD）时，内部时钟不工作，所有功能单元停止工作。只能通过复位退出。 指令111条指令寻址方式 立即寻址（MOV A, #68H） 直接寻址(MOV A,68H ;将68H单元格的数据传送到A) 寄存器寻址（MOV A,Rn） 寄存器间接寻址（MOV A,@Rn） 变址寻址 相对寻址 位寻址 伪指令用于帮助开发者更好地管理程序的结构和数据。这些指令本身并不会直接转换为机器代码，而是为汇编器提供信息或执行某些特定功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531. ORG （起始地址）用于指定代码或数据的起始地址。例如：asm复制代码ORG 0000H ; 从地址 0x0000 开始存储程序2. DB （定义字节数据）用于定义字节数据，常用于存储常量或初始化数据。例如：asm复制代码DATA1: DB 0AH ; 定义一个常量 0x0A3. DW （定义字数据）用于定义双字节数据（16 位）。例如：asm复制代码DATA2: DW 1234H ; 定义一个 16 位的常量 0x12344. EQU （定义符号常量）为某个值分配一个符号名称，类似于 C 中的宏定义。例如：asm复制代码MYCONST EQU 05H ; 定义一个常量 MYCONST，其值为 0x05MOV A, MYCONST ; 将 0x05 加载到 A 寄存器5. END （程序结束）用于指示汇编器程序的结束。例如：asm复制代码END ; 汇编结束6. BIT （位地址赋值）位寻址区在 8051 的 RAM 中占用地址范围 20H ~ 2FH，共 16 字节name BIT addressname：符号名称，用于标识位变量。address：位地址（范围是 00H 到 7FH）7. DS （定义存储空间）分配一段未初始化的内存，用于数据存储。例如：asm复制代码BUFFER: DS 10 ; 分配 10 个字节的存储空间 寻址方式 立即数寻址：操作数是指令中直接给出的常数值。例：MOV A, #10（将 10 直接送入 A 寄存器）。 直接寻址：操作数是内存地址，通过该地址访问数据。例：MOV A, 30H（将 0x30 地址的数据送入 A 寄存器）。 寄存器寻址：操作数是寄存器的内容。例：MOV A, R0（将 R0 寄存器的值送入 A 寄存器）。 寄存器间接寻址：操作数的地址由寄存器指向。例：MOV A, @R0（R0 寄存器的内容作为地址，从该地址读取数据送入 A 寄存器）。 8051 单片机中有 4 组工作寄存器组，每组包含 8 个寄存器 (R0 至 R7)。因此，8051 单片机总共有 32 个工作寄存器。 变址寻址：地址由基地址和偏移量（即变址）计算得到。例：MOV A, @R0+DPTR（DPTR 和 R0 的内容相加作为地址，从该地址读取数据）。 相对寻址：地址是相对于当前指令地址的偏移量。例：SJMP LABEL（跳转到当前地址偏移 LABEL 的位置）。 位寻址：操作数是内存中单个位，直接操作某一位。例：SETB 30H.0（将 0x30 地址的第 0 位设为 1）。 寻址方式和寻址空间中断通信传输方式分类 串行通信 数据传输速度快。 需要更多的传输线。 适合短距离通信。 距离增长时，位数增多时，会提高硬件成本，降低通信成功率 并行通信 线路简单，成本低 适合长距离通信 传输速度慢 按时钟线分类 异步通信 同步通信 按传送方向分类 单工 半双工 双工 异步串行通信例：UART、RS-232、RS-485 帧格式 起始位 数据位 低位在前，高位在后 奇偶校验位 这是一个用于错误检测的位，可以是无校验(None)、奇校验(Odd)、偶校验(Even)、标记校验(Mark)或空位校验(Space)。 确保数据帧与校验位的1个数为奇数为奇校验，为偶数，偶校验 停止位 常用的帧格式为：1位起始位+8位数据位（一个字节）+无校验位+1位停止位 即一帧10个bit 波特率对于串口通信，波特率代表每秒传输的bit的数量。如常用的9600波特率代表了一秒钟可以传输9600个bit的信息。即信号宽度为0.104ms 校验方式 字节的奇偶校验 数据块的累加和校验 数据块的循环冗余校验CRC 把数据块看成二进制数，用特定数除以它，取余数 UART键盘工作方式 编程扫描方式 定时扫描方式 中断扫描方式 独立键盘 矩阵式键盘 行扫描式 线路反转法 代码分析点亮LED123456789101112; 点亮 LED 的汇编程序; 假设 LED 连接到 P1.0，低电平点亮ORG 0000H ; 程序起始地址为 0START: MOV P1, #0FEH ; 初始化 P1，P1.0 输出低电平，其他引脚输出高电平 ; P1 = 1111 1110 (FEH)，即 P1.0 = 0 (点亮 LED)HERE: SJMP HERE ; 无限循环，保持 LED 点亮END ; 程序结束 延时 单循环 注意：当X为0时，实际是256，R0是8位寄存器（同R1,R2,R3）;0&lt;&#x3D;R0&lt;&#x3D;256 双重循环 亮灯，一闪一闪 123456789101112131415161718192021222324\tORG 10H ; 程序起始地址\tMOV P1, #00H ; 将 P1 端口的所有位设置为 0 START: ; 主程序开始 SETB P1.0 ; 置P1.0高电平，LED点亮 LCALL DELAY ; 调用延时程序 CLR P1.0 ; 置P1.0低电平，LED熄灭 LCALL DELAY ; 调用延时程序 AJMP START ; 跳转到START，实现循环DELAY: ; 延时子程序 MOV R7, #250 ; 外层循环计数器初始化，R7 = 250D1: MOV R6, #250 ; 内层循环计数器初始化，R6 = 250D2: DJNZ R6, D2 ; 内层循环：R6倒数，直到为0 DJNZ R7, D1 ; 外层循环：R7倒数，直到为0 RET ; 延时完成，返回主程序END ; 程序结束DJNZ 指令：递减寄存器 R7 的值，如果不为0，跳转到标号 D1RET 返回调用 LCALL DELAY 的位置AJMP\t无条件跳转\t短跳转指令，适用于小程序。 按键控制LED亮灭 1234567891011121314151617ORG 0000H ; 程序起始地址CLR P1.0 ; 清除 P1.0，设置 P1.0 为低电平（LED熄灭）START: ; 主程序开始 SETB P0.0 ; 设置 P0.0 为高电平（使能触发条件） JB P0.0, LIG ; 如果 P0.0 为高电平（1），跳转到 LIG 标签处（LED熄灭） SETB P1.0 ; 否则设置 P1.0 为高电平（LED点亮） SJMP START ; 跳回 START，形成循环LIG: ; LIG 标签，LED 熄灭部分 CLR P1.0 ; 清除 P1.0，设置 P1.0 为低电平（LED熄灭） SJMP START ; 跳回 START，形成循环END ; 程序结束;JB P0.0, LIG：检查 P0.0 引脚的电平。如果 P0.0 为高电平（1），则跳转到 LIG 标签，否则继续执行下一条指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ORG 0000H ; 程序起始地址CLR P1.0 ; 清除 P1.0，设置 P1.0 为低电平（LED熄灭）CLR P1.1 ; 清除 P1.1，设置 P1.1 为低电平（LED熄灭）CLR P1.2 ; 清除 P1.2，设置 P1.2 为低电平（LED熄灭）START: ; 主程序开始 SETB P0.0 ; 设置 P0.0 为高电平（开关启用） SETB P0.1 ; 设置 P0.1 为高电平（开关启用） SETB P0.2 ; 设置 P0.2 为高电平（开关启用） ; 控制 P1.0 LED JB P0.0, LIGO ; 如果 P0.0 为高电平（1），跳转到 LIGO（LED熄灭） SETB P1.0 ; 否则设置 P1.0 为高电平（LED亮） SJMP START ; 跳回 START，形成循环LIGO: CLR P1.0 ; 清除 P1.0，设置 P1.0 为低电平（LED熄灭）next1: ; 检查 P0.1 控制 P1.1 LED JB P0.1, LIG1 ; 如果 P0.1 为高电平（1），跳转到 LIG1（LED熄灭） SETB P1.1 ; 否则设置 P1.1 为高电平（LED亮） SJMP next2 ; 跳到 next2，继续下一步LIG1: CLR P1.1 ; 清除 P1.1，设置 P1.1 为低电平（LED熄灭）next2: ; 检查 P0.2 控制 P1.2 LED JB P0.2, LIG2 ; 如果 P0.2 为高电平（1），跳转到 LIG2（LED熄灭） SETB P1.2 ; 否则设置 P1.2 为高电平（LED亮） SJMP next3 ; 跳到 next3，继续下一步LIG2: CLR P1.2 ; 清除 P1.2，设置 P1.2 为低电平（LED熄灭）next3: ; 检查 P0.3 控制 P1.3 LED JB P0.3, LIG3 ; 如果 P0.3 为高电平（1），跳转到 LIG3（LED熄灭） SETB P1.3 ; 否则设置 P1.3 为高电平（LED亮） SJMP next4 ; 跳到 next4，继续下一步next4: ; 检查 P0.4 控制 P1.4 LED JB P0.4, LIG4 ; 如果 P0.4 为高电平（1），跳转到 LIG4（LED熄灭） SETB P1.4 ; 否则设置 P1.4 为高电平（LED亮） SJMP START ; 跳回 START，形成循环LIG3: CLR P1.3 ; 清除 P1.3，设置 P1.3 为低电平（LED熄灭）LIG4: CLR P1.4 ; 清除 P1.4，设置 P1.4 为低电平（LED熄灭）SJMP START ; 跳回 START，形成循环END ; 程序结束 1234567891011121314151617181920212223;1. 仔细体会本段仿真效果，再删除延时脚本程序编译之后，你看看会有什么效果？;2. 你将会深刻理解LED产生闪烁的原因，分析为什么会闪烁？;3. 延时脚本程序的延时长短效果比较。;4. 本例为软件防抖，硬件防抖可参见李群芳编的《单片机原理、接口及应用--嵌入式系统技术基础》中的P87页。ORG 0000HABC: MOV P0, #0FFH ;高四位的LED全灭，低四位开关输入线送1 MOV A, P0 ;读P0口引脚开关状态并送A SWAP A ;低四位开关状态转换到高四位 ANL A, #0F0H ;保留高四位 MOV P0, A ;从P0口输出 LCALL DELAY SJMP ABC ;循环DELAY: MOV R6, #20 ;原始代码中R6，R7的值若太小，则会有余辉鬼辉效果 DL2: MOV R7, #7DH DL1: NOP NOP DJNZ R7, DL1 DJNZ R6, DL2 RETEND","tags":["课程"]},{"title":"arduino点亮36 RGB LEDs","path":"/2024/11/06/arduino点亮36-RGB-LEDs/","content":"1234567891011121314151617181920#include &lt;Adafruit_NeoPixel.h&gt;#define LED_PIN 4 // LED数据输入连接到Arduino引脚4#define LED_COUNT 36 // LED数量为36Adafruit_NeoPixel strip = Adafruit_NeoPixel(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);void setup() &#123; strip.begin(); // 初始化LED条 strip.show(); // 确保所有LED最初是关闭状态&#125;void loop() &#123; for (int i = 0; i &lt; LED_COUNT; i++) &#123; strip.setPixelColor(i, strip.Color(255, 0, 0)); // 设置所有LED为红色 strip.show(); // 显示颜色变化 delay(100); // 等待100毫秒 &#125;&#125; 实验现象： 下面是淘宝商家给的例程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/* SparkFun WS2812 Breakout Board Example SparkFun Electronics date: July 25, 2013 license: GNU GENERAL PUBLIC LICENSE Requires the Adafruit NeoPixel library. It&#x27;s awesome, go get it. https://github.com/adafruit/Adafruit_NeoPixel This simple example code runs three sets of animations on a group of WS2812 breakout boards. The more boards you link up, the better these animations will look. For help linking WS2812 breakouts, checkout our hookup guide: https://learn.sparkfun.com/tutorials/ws2812-breakout-hookup-guide Before uploading the code, make sure you adjust the two defines at the top of this sketch: PIN and LED_COUNT. Pin should be the Arduino pin you&#x27;ve got connected to the first pixel&#x27;s DIN pin. By default it&#x27;s set to Arduino pin 4. LED_COUNT should be the number of breakout boards you have linked up.*/#include &lt;Adafruit_NeoPixel.h&gt;#include &quot;WS2812_Definitions.h&quot;#define PIN 4#define LED_COUNT 36// Create an instance of the Adafruit_NeoPixel class called &quot;leds&quot;.// That&#x27;ll be what we refer to from here on...Adafruit_NeoPixel leds = Adafruit_NeoPixel(LED_COUNT, PIN, NEO_GRB + NEO_KHZ800);void setup()&#123; leds.begin(); // Call this to start up the LED strip. clearLEDs(); // This function, defined below, turns all LEDs off... leds.show(); // ...but the LEDs don&#x27;t actually update until you call this.&#125;void loop()&#123; // Ride the Rainbow Road for (int i=0; i&lt;LED_COUNT*10; i++) &#123; rainbow(i); delay(100); // Delay between rainbow slides &#125; // Indigo cylon // Do a cylon (larson scanner) cycle 10 times for (int i=0; i&lt;10; i++) &#123; // cylon function: first param is color, second is time (in ms) between cycles cylon(INDIGO, 500); // Indigo cylon eye! &#125; // A light shower of spring green rain // This will run the cascade from top-&gt;bottom 20 times for (int i=0; i&lt;20; i++) &#123; // First parameter is the color, second is direction, third is ms between falls cascade(MEDIUMSPRINGGREEN, TOP_DOWN, 100); &#125;&#125;// Implements a little larson &quot;cylon&quot; sanner.// This&#x27;ll run one full cycle, down one way and back the othervoid cylon(unsigned long color, byte wait)&#123; // weight determines how much lighter the outer &quot;eye&quot; colors are const byte weight = 4; // It&#x27;ll be easier to decrement each of these colors individually // so we&#x27;ll split them out of the 24-bit color value byte red = (color &amp; 0xFF0000) &gt;&gt; 16; byte green = (color &amp; 0x00FF00) &gt;&gt; 8; byte blue = (color &amp; 0x0000FF); // Start at closest LED, and move to the outside for (int i=0; i&lt;=LED_COUNT-1; i++) &#123; clearLEDs(); leds.setPixelColor(i, red, green, blue); // Set the bright middle eye // Now set two eyes to each side to get progressively dimmer for (int j=1; j&lt;3; j++) &#123; if (i-j &gt;= 0) leds.setPixelColor(i-j, red/(weight*j), green/(weight*j), blue/(weight*j)); if (i-j &lt;= LED_COUNT) leds.setPixelColor(i+j, red/(weight*j), green/(weight*j), blue/(weight*j)); &#125; leds.show(); // Turn the LEDs on delay(wait); // Delay for visibility &#125; // Now we go back to where we came. Do the same thing. for (int i=LED_COUNT-2; i&gt;=1; i--) &#123; clearLEDs(); leds.setPixelColor(i, red, green, blue); for (int j=1; j&lt;3; j++) &#123; if (i-j &gt;= 0) leds.setPixelColor(i-j, red/(weight*j), green/(weight*j), blue/(weight*j)); if (i-j &lt;= LED_COUNT) leds.setPixelColor(i+j, red/(weight*j), green/(weight*j), blue/(weight*j)); &#125; leds.show(); delay(wait); &#125;&#125;// Cascades a single direction. One time.void cascade(unsigned long color, byte direction, byte wait)&#123; if (direction == TOP_DOWN) &#123; for (int i=0; i&lt;LED_COUNT; i++) &#123; clearLEDs(); // Turn off all LEDs leds.setPixelColor(i, color); // Set just this one leds.show(); delay(wait); &#125; &#125; else &#123; for (int i=LED_COUNT-1; i&gt;=0; i--) &#123; clearLEDs(); leds.setPixelColor(i, color); leds.show(); delay(wait); &#125; &#125;&#125;// Sets all LEDs to off, but DOES NOT update the display;// call leds.show() to actually turn them off after this.void clearLEDs()&#123; for (int i=0; i&lt;LED_COUNT; i++) &#123; leds.setPixelColor(i, 0); &#125;&#125;// Prints a rainbow on the ENTIRE LED strip.// The rainbow begins at a specified position. // ROY G BIV!void rainbow(byte startPosition) &#123; // Need to scale our rainbow. We want a variety of colors, even if there // are just 10 or so pixels. int rainbowScale = 192 / LED_COUNT; // Next we setup each pixel with the right color for (int i=0; i&lt;LED_COUNT; i++) &#123; // There are 192 total colors we can get out of the rainbowOrder function. // It&#x27;ll return a color between red-&gt;orange-&gt;green-&gt;...-&gt;violet for 0-191. leds.setPixelColor(i, rainbowOrder((rainbowScale * (i + startPosition)) % 192)); &#125; // Finally, actually turn the LEDs on: leds.show();&#125;// Input a value 0 to 191 to get a color value.// The colors are a transition red-&gt;yellow-&gt;green-&gt;aqua-&gt;blue-&gt;fuchsia-&gt;red...// Adapted from Wheel function in the Adafruit_NeoPixel library example sketchuint32_t rainbowOrder(byte position) &#123; // 6 total zones of color change: if (position &lt; 31) // Red -&gt; Yellow (Red = FF, blue = 0, green goes 00-FF) &#123; return leds.Color(0xFF, position * 8, 0); &#125; else if (position &lt; 63) // Yellow -&gt; Green (Green = FF, blue = 0, red goes FF-&gt;00) &#123; position -= 31; return leds.Color(0xFF - position * 8, 0xFF, 0); &#125; else if (position &lt; 95) // Green-&gt;Aqua (Green = FF, red = 0, blue goes 00-&gt;FF) &#123; position -= 63; return leds.Color(0, 0xFF, position * 8); &#125; else if (position &lt; 127) // Aqua-&gt;Blue (Blue = FF, red = 0, green goes FF-&gt;00) &#123; position -= 95; return leds.Color(0, 0xFF - position * 8, 0xFF); &#125; else if (position &lt; 159) // Blue-&gt;Fuchsia (Blue = FF, green = 0, red goes 00-&gt;FF) &#123; position -= 127; return leds.Color(position * 8, 0, 0xFF); &#125; else //160 &lt;position&lt; 191 Fuchsia-&gt;Red (Red = FF, green = 0, blue goes FF-&gt;00) &#123; position -= 159; return leds.Color(0xFF, 0x00, 0xFF - position * 8); &#125;&#125; 头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* Bunches of definitions for the WS2812 Breakout Board example code */ // These are for the cascade function#define TOP_DOWN 0#define DOWN_TOP 1/* A world of colors to set your LED to Standard HTML Color Codes sorted by Hex Value to see the colors in action, check out: http://www.w3schools.com/html/html_colorvalues.asp */ #define BLACK 0x000000#define NAVY 0x000080#define DARKBLUE 0x00008B#define MEDIUMBLUE 0x0000CD#define BLUE 0x0000FF#define DARKGREEN 0x006400#define GREEN 0x008000#define TEAL 0x008080#define DARKCYAN 0x008B8B#define DEEPSKYBLUE 0x00BFFF#define DARKTURQUOISE 0x00CED1#define MEDIUMSPRINGGREEN\t0x00FA9A#define LIME 0x00FF00#define SPRINGGREEN 0x00FF7F#define AQUA 0x00FFFF#define CYAN 0x00FFFF#define MIDNIGHTBLUE 0x191970#define DODGERBLUE 0x1E90FF#define LIGHTSEAGREEN 0x20B2AA#define FORESTGREEN 0x228B22#define SEAGREEN 0x2E8B57#define DARKSLATEGRAY 0x2F4F4F#define LIMEGREEN 0x32CD32#define MEDIUMSEAGREEN 0x3CB371#define TURQUOISE 0x40E0D0#define ROYALBLUE 0x4169E1#define STEELBLUE 0x4682B4#define DARKSLATEBLUE 0x483D8B#define MEDIUMTURQUOISE 0x48D1CC#define INDIGO 0x4B0082#define DARKOLIVEGREEN 0x556B2F#define CADETBLUE 0x5F9EA0#define CORNFLOWERBLUE 0x6495ED#define MEDIUMAQUAMARINE\t0x66CDAA#define DIMGRAY 0x696969#define SLATEBLUE 0x6A5ACD#define OLIVEDRAB 0x6B8E23#define SLATEGRAY 0x708090#define LIGHTSLATEGRAY 0x778899#define MEDIUMSLATEBLUE 0x7B68EE#define LAWNGREEN 0x7CFC00#define CHARTREUSE 0x7FFF00#define AQUAMARINE 0x7FFFD4#define MAROON 0x800000#define PURPLE 0x800080#define OLIVE 0x808000#define GRAY 0x808080#define SKYBLUE 0x87CEEB#define LIGHTSKYBLUE 0x87CEFA#define BLUEVIOLET 0x8A2BE2#define DARKRED 0x8B0000#define DARKMAGENTA 0x8B008B#define SADDLEBROWN 0x8B4513#define DARKSEAGREEN 0x8FBC8F#define LIGHTGREEN 0x90EE90#define MEDIUMPURPLE 0x9370DB#define DARKVIOLET 0x9400D3#define PALEGREEN 0x98FB98#define DARKORCHID 0x9932CC#define YELLOWGREEN 0x9ACD32#define SIENNA 0xA0522D#define BROWN 0xA52A2A#define DARKGRAY 0xA9A9A9#define LIGHTBLUE 0xADD8E6#define GREENYELLOW 0xADFF2F#define PALETURQUOISE 0xAFEEEE#define LIGHTSTEELBLUE 0xB0C4DE#define POWDERBLUE 0xB0E0E6#define FIREBRICK 0xB22222#define DARKGOLDENROD 0xB8860B#define MEDIUMORCHID 0xBA55D3#define ROSYBROWN 0xBC8F8F#define DARKKHAKI 0xBDB76B#define SILVER 0xC0C0C0#define MEDIUMVIOLETRED 0xC71585#define INDIANRED 0xCD5C5C#define PERU 0xCD853F#define CHOCOLATE 0xD2691E#define TAN 0xD2B48C#define LIGHTGRAY 0xD3D3D3#define THISTLE 0xD8BFD8#define ORCHID 0xDA70D6#define GOLDENROD 0xDAA520#define PALEVIOLETRED 0xDB7093#define CRIMSON 0xDC143C#define GAINSBORO 0xDCDCDC#define PLUM 0xDDA0DD#define BURLYWOOD 0xDEB887#define LIGHTCYAN 0xE0FFFF#define LAVENDER 0xE6E6FA#define DARKSALMON 0xE9967A#define VIOLET 0xEE82EE#define PALEGOLDENROD 0xEEE8AA#define LIGHTCORAL 0xF08080#define KHAKI 0xF0E68C#define ALICEBLUE 0xF0F8FF#define HONEYDEW 0xF0FFF0#define AZURE 0xF0FFFF#define SANDYBROWN 0xF4A460#define WHEAT 0xF5DEB3#define BEIGE 0xF5F5DC#define WHITESMOKE 0xF5F5F5#define MINTCREAM 0xF5FFFA#define GHOSTWHITE 0xF8F8FF#define SALMON 0xFA8072#define ANTIQUEWHITE 0xFAEBD7#define LINEN 0xFAF0E6#define LIGHTGOLDENRODYELLOW\t0xFAFAD2#define OLDLACE 0xFDF5E6#define RED 0xFF0000#define FUCHSIA 0xFF00FF#define MAGENTA 0xFF00FF#define DEEPPINK 0xFF1493#define ORANGERED 0xFF4500#define TOMATO 0xFF6347#define HOTPINK 0xFF69B4#define CORAL 0xFF7F50#define DARKORANGE 0xFF8C00#define LIGHTSALMON 0xFFA07A#define ORANGE 0xFFA500#define LIGHTPINK 0xFFB6C1#define PINK 0xFFC0CB#define GOLD 0xFFD700#define PEACHPUFF 0xFFDAB9#define NAVAJOWHITE 0xFFDEAD#define MOCCASIN 0xFFE4B5#define BISQUE 0xFFE4C4#define MISTYROSE 0xFFE4E1#define BLANCHEDALMOND 0xFFEBCD#define PAPAYAWHIP 0xFFEFD5#define LAVENDERBLUSH 0xFFF0F5#define SEASHELL 0xFFF5EE#define CORNSILK 0xFFF8DC#define LEMONCHIFFON 0xFFFACD#define FLORALWHITE 0xFFFAF0#define SNOW 0xFFFAFA#define YELLOW 0xFFFF00#define LIGHTYELLOW 0xFFFFE0#define IVORY 0xFFFFF0#define WHITE 0xFFFFFF","tags":["arduino"]},{"title":"硬件基础篇-常见运算放大器","path":"/2024/11/04/硬件基础篇-常见运算放大器/","content":"前言由于设计一个霍尔线径检测模块，使用双49E霍尔，直接单片机模拟IO口读取，发现由于线径变化小，IO口读取的模拟值差值也小，分辨率低。需要加一个差分放大电路，于是决定复习一下运放的内容。主要关注的是运放的使用和仿真。运放的作用，对信号做加减，微积分，放大操作。 运放基本结构 当Up大于Un,输出主要有两个应用场景，比较器与放大器基本原理，虚短与虚断 仿真测试 疑问，为什么输出的不是5V？而是3.3V，改变5V，发现Vout&#x3D;VCC-1.6V 实际测试了SOP-8的LMV358IDR芯片，输出5V. 12345678910在型号 LMV358IDR 中，IDR 代表的是封装和封装形式的后缀信息。具体解释如下：I：表示温度等级。I 通常代表 工业级温度范围，一般为 -40°C 至 +85°C。相比之下，商业级产品的温度范围通常是 0°C 至 70°C。D：表示封装类型。D 通常指 SOIC-8 封装（Small Outline Integrated Circuit，8引脚的小外形集成电路），是一种常见的表面贴装封装，适用于SMT（表面贴装技术）生产。R：表示封装卷带（Reel），也就是出厂包装方式。R 表示该芯片是通过 卷带包装 出厂，通常用于自动化生产线，便于机器自动拾取芯片。总结LMV358IDR 是 LMV358 的一个版本，具有 SOIC-8 封装，工业温度范围，且采用卷带包装，适合表面贴装生产。 补充，名词解释 VCC (Voltage Common Collector): 一般指正电源电压，通常用于表示NPN型晶体管电路的正电压。在数字电路和集成电路（如CMOS、TTL逻辑）中，VCC通常指电源正极。 VDD (Voltage Drain Drain): 主要用于MOSFET和CMOS电路中，表示电源正极（例如CMOS电路中的+5V或+3.3V）。对于数字集成电路，VDD也指正电源电压，与VCC类似。 VSS (Voltage Source Source): 一般指电源的负极或接地端，通常与VDD一起使用。在MOSFET和CMOS电路中，VSS通常是电源地或负电压的标识。 VEE (Voltage Emitter Emitter): 主要用于PNP型晶体管电路，通常指电源的负电压。在一些模拟电路和运算放大器电路中，VEE也用于表示负电源。 VBAT (Voltage Battery): 表示电池电压，通常用于电池供电的设备中。在一些便携式或低功耗设备中，VBAT标识的是电池输入电压。 虚短虚断 虚断：输入阻抗无穷大，即电流为0 虚短: 当给运放引入负反馈时，Un&#x3D;Up 电流反馈运放的输入阻抗并不大，不满足虚断，负反馈才存在虚短","tags":["硬件基础"]},{"title":"基于simplefoc 实现一个无刷电机操作另一个无刷电机转动","path":"/2024/10/23/基于simplefoc-实现一个无刷电机操作另一个无刷电机转动/","content":"基于simplefoc 实现一个无刷电机操作另一个无刷电机转动 基本框架 主机代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * Torque control example using voltage control loop. * * Most of the low-end BLDC driver boards doesn&#x27;t have current measurement therefore SimpleFOC offers * you a way to control motor torque by setting the voltage to the motor instead hte current. * * This makes the BLDC motor effectively a DC motor, and you can use it in a same way. *///力矩闭环#include &lt;SimpleFOC.h&gt;// magnetic sensor instance - SPI// MagneticSensorSPI sensor = MagneticSensorSPI(AS5147_SPI, 10);// magnetic sensor instance - I2CMagneticSensorI2C sensor = MagneticSensorI2C(AS5600_I2C);// magnetic sensor instance - analog output// MagneticSensorAnalog sensor = MagneticSensorAnalog(A1, 14, 1020);// BLDC motor &amp; driver instanceBLDCMotor motor = BLDCMotor(7);BLDCDriver3PWM driver = BLDCDriver3PWM(9, 5, 6, 8);// Stepper motor &amp; driver instance//StepperMotor motor = StepperMotor(50);//StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6, 8);// voltage set point variablefloat target_voltage = 0;// instantiate the commanderCommander command = Commander(Serial);void doTarget(char* cmd) &#123; command.scalar(&amp;target_voltage, cmd); &#125;void setup() &#123; // use monitoring with serial Serial.begin(115200); // enable more verbose output for debugging // comment out if not needed SimpleFOCDebug::enable(&amp;Serial); // initialise magnetic sensor hardware sensor.init(); // link the motor to the sensor motor.linkSensor(&amp;sensor); // power supply voltage driver.voltage_power_supply = 12; driver.init(); motor.linkDriver(&amp;driver); // aligning voltage motor.voltage_sensor_align = 5; // choose FOC modulation (optional) motor.foc_modulation = FOCModulationType::SpaceVectorPWM; // set motion control loop to be used motor.controller = MotionControlType::torque; // comment out if not needed motor.useMonitoring(Serial); // initialize motor motor.init(); // align sensor and start FOC motor.initFOC(); // add target command T command.add(&#x27;T&#x27;, doTarget, &quot;target voltage&quot;); Serial.println(F(&quot;Motor ready.&quot;)); Serial.println(F(&quot;Set the target voltage using serial terminal:&quot;)); _delay(1000);&#125;void loop() &#123; // main FOC algorithm function // the faster you run this function the better // Arduino UNO loop ~1kHz // Bluepill loop ~10kHz motor.loopFOC(); // Motion control function // velocity, position or voltage (defined in motor.controller) // this function can be run at much lower frequency than loopFOC() function // You can also use motor.move() and set the motor.target in the code motor.move(target_voltage); float angle_in_radians = sensor.getAngle(); Serial.println(&quot;T&quot;+String(angle_in_radians)); // user communication command.run();&#125; 从机代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * * Position/angle motion control example * Steps: * 1) Configure the motor and magnetic sensor * 2) Run the code * 3) Set the target angle (in radians) from serial terminal * */#include &lt;SimpleFOC.h&gt;// magnetic sensor instance - SPI// MagneticSensorSPI sensor = MagneticSensorSPI(AS5147_SPI, 10);//magnetic sensor instance - MagneticSensorI2CMagneticSensorI2C sensor = MagneticSensorI2C(AS5600_I2C);// magnetic sensor instance - analog output// MagneticSensorAnalog sensor = MagneticSensorAnalog(A1, 14, 1020);// BLDC motor &amp; driver instanceBLDCMotor motor = BLDCMotor(11);BLDCDriver3PWM driver = BLDCDriver3PWM(9, 5, 6, 8);// Stepper motor &amp; driver instance//StepperMotor motor = StepperMotor(50);//StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6, 8);// angle set point variablefloat target_angle = 0;// instantiate the commanderCommander command = Commander(Serial);void doTarget(char* cmd) &#123; command.scalar(&amp;target_angle, cmd); &#125;void setup() &#123; // use monitoring with serial Serial.begin(115200); // enable more verbose output for debugging // comment out if not needed SimpleFOCDebug::enable(&amp;Serial); // initialise magnetic sensor hardware sensor.init(); // link the motor to the sensor motor.linkSensor(&amp;sensor); // driver config // power supply voltage [V] driver.voltage_power_supply = 12; driver.init(); // link the motor and the driver motor.linkDriver(&amp;driver); // choose FOC modulation (optional) motor.foc_modulation = FOCModulationType::SpaceVectorPWM; // set motion control loop to be used motor.controller = MotionControlType::angle; // contoller configuration // default parameters in defaults.h // velocity PI controller parameters motor.PID_velocity.P = 0.15f; motor.PID_velocity.I = 0; motor.PID_velocity.D = 0; // maximal voltage to be set to the motor motor.voltage_limit = 6; // velocity low pass filtering time constant // the lower the less filtered motor.LPF_velocity.Tf = 0.03f; // angle P controller motor.P_angle.P = 20; // maximal velocity of the position control motor.velocity_limit = 20; // comment out if not needed motor.useMonitoring(Serial); // initialize motor motor.init(); // align sensor and start FOC motor.initFOC(); // add target command T command.add(&#x27;T&#x27;, doTarget, &quot;target angle&quot;); Serial.println(F(&quot;Motor ready.&quot;)); Serial.println(F(&quot;Set the target angle using serial terminal:&quot;)); _delay(1000);&#125;void loop() &#123; // main FOC algorithm function // the faster you run this function the better // Arduino UNO loop ~1kHz // Bluepill loop ~10kHz motor.loopFOC(); // Motion control function // velocity, position or voltage (defined in motor.controller) // this function can be run at much lower frequency than loopFOC() function // You can also use motor.move() and set the motor.target in the code motor.move(target_angle); float angle_in_radians = sensor.getAngle(); Serial.println(angle_in_radians); // function intended to be used with serial plotter to monitor motor variables // significantly slowing the execution down!!!! // motor.monitor(); // user communication command.run();&#125; 接线有点烂，暂时就先就这样了","tags":["无刷电机"]},{"title":"USB3.0拓展坞设计","path":"/2024/10/22/USB3-0拓展坞设计/","content":"前言感觉自己天天开新坑却不填，想做一个USB3.0的拓展坞，单纯的集线器并不难，想加一些功能，有网口读取，SD卡，TF卡功能，视频传输，ST-link下载，串口，USB转CAN口。Ok，主要是想通过这个项目了解一下各种协议及其在硬件上的规定，作为练习。尽可能采用四层板。 USB3.0硬件设计规范 usb3.0六根信号线 D+ D- RX+ RX- TX+ TX- D+与D-是兼容USB2.0的信号线，剩下四根是高速线，并且同组内可交叉连线注意ESD，选择可适配3.0的ESD(还是有点没太理解)TX端即host端要加一个100nf的耦合电容，靠近连接器端 阻抗控制： 建议USB3.0的差分阻抗控制90Ω误差10%，USB2.0差分阻抗控制90Ω误差10%。 时延控制： 建议USB3.0差分对内需等长设计，误差小于5mil。USB2.0等长误差控制小于10mil。 隔直电容： 建议选取0402以下封装电容，容值官方SPEC要求75nF-265nF之间，布局时靠近端子放置。 对内交叉： USB3.0 的P&#x2F;N如果走线上有交差，可以将差分对的P&#x2F;N交换，USB3允许P&#x2F;N反转。 参考链接 接口一览https://blog.csdn.net/Mark_md/article/details/114578359"},{"title":"USB to can的学习与踩坑","path":"/2024/10/20/USB-to-can的学习与踩坑/","content":"前言一切的开始从一个项目说起，3D打印机的项目需要用到工具板，采用CAN通讯，由于不理解，决定学习一下CAN通讯，并由U_TO_C模块做起。 开源项目的学习 https://oshwhub.com/hvan/usb_can项目地址 打板后，存在问题，该种型号的排阻在淘宝上难以买到，0402封装比较难焊接。原理图部分还是比较简单 不知道是什么原因，完全焊接上后无法使用，需要去掉，注意事项写在下面了 接头间距为sh1.0，没有的得提前买，建议一边接头，另一边杜邦线2.54mm母头 焊接好的成品如图 后面有时间对其改造一下 固件烧录这里我采用ST-LINK对其烧录，固件PCAN-USB。固件及后续上位机放到了github的仓库里烧录时，ST-LINK电源使用3.3V,录个视频，如下 驱动安装分为LINUX与windows系统，这里仅介绍windows系统驱动及其上位机安装，linux后续有时间再议。这里采用Pcan-view驱动百度搜PCAN的windows驱动 解压后安装 上位机使用及其演示两台USB-to-can实现互发 对发成功则成功完成项目 https://github.com/liwuyou/USB-TO-CAN-.git","tags":["通讯","值得一提的文章"]},{"title":"无线蓝牙鼠标的拆解","path":"/2024/10/17/无线蓝牙鼠标的拆解/","content":"之前在淘宝上买了个蓝牙鼠标，最近电池不耐用了，就拆解一下 PCB板如图，反面和正面 1是FCT3065-XY（无线鼠标传感器IC），上面丝印为FCT3065-XY，D23443BN2是红光LED3是电源管理芯片，丝印LTH74是无线通讯芯片,通过旁边的天线发送信号，丝印BYKC68MS,M16 AAD9 AJ,BY2307-BP34(,为换行)5是16000晶振6是3.0V的LDO，丝印65Z5 https://developers.goodix.com/zh/bbs/blog_detail/bebdd04ccdfc4f7682ab27a8e77a14ad","tags":["拆解"]},{"title":"无刷电机","path":"/2024/10/16/无刷电机/","content":"电机的内容十分重要，用处大大的，之前一直只会使用驱动板对电机进行相关控制，也没有总结和相关算法的学习，这样不好，决定新开一篇用于记录无刷电机的学习。foc 磁场定向控制技术 注意通过FOC控制的云台电机和通过电调控制的动力电机一般是不通用的 无刷电调这儿制作还是挺简单的，这里使用开源的PCB， 用了三个n沟道MOS和三个P沟道MOS，P沟道MOS采用三极管驱动。R1是上拉电阻并兼有限流功能，R2是基极串联电阻 三极管由发射极、基极和集电极组成，其中基极是控制三极管导通和截止的引脚。 在实际电路中，为了稳定三极管的工作状态，通常会在基极引脚串联一个电阻。 这个电阻被称为基极串联电阻，其作用是限制基极电流，确保三极管正常工作。 供电接口选用：XT30PW-M固件烧写接口：GH125-S04DCA-00 单片机固件在参考的链接里找话说电调里到底写了啥，这里只有HEX文件，咋也不知道，后续再看。话说逐飞科技也开源了基于STC32的电调，后续再看。 基于arduino的开源项目 【开源Arduino无刷电调制作】 https://www.bilibili.com/video/BV1PS4y1P7AS/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6这个部分就更贴切我对无刷电机的想象，将驱动部分和控制部分分开。 BLDC与PMSM无刷直流电机（Brushless DC motor, BLDCM）定义一般有两种：一种定义认为只有梯形波&#x2F;方波无刷直流电机才可以被称为无刷直流电机，而正弦波无刷电机则被称为永磁同步电机（permanent magnet synchronous motor, PMSM） KV值：转速&#x2F;V，意思为输入电压每增加 1 伏特，无刷电机空转转速增加的转速值。比如说，标称值为 1000KV 的外转子无刷电机，在 11 伏的电压条件下，最大空载转速即为：11× &#x3D; 1000 11000rpm（rpm 的含义是：转&#x2F;分钟）。 径向磁铁与轴向磁铁编码器磁编码器霍尔编码器电流采集电路与电压采集电路https://blog.csdn.net/yck1716/article/details/135967890 参考 【没有专业术语！新手小白也能看懂的FOC科普】 https://www.bilibili.com/video/BV1XvtNeaE54/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6无刷电调PN双层 v2https://oshwhub.com/maker-lee/luo-li-wu-shua-dian-diao-2020-ban-pn-shuang-ceng-v1_copy无刷电调固件https://www.aliyundrive.com/s/yW373tpkXLm","tags":["电机"]},{"title":"专业版立创EDA如何将pcb复制到另一个PCB中？","path":"/2024/10/16/专业版立创EDA如何将pcb复制到另一个PCB中？/","content":"如题所示，下面有两块板 工艺边板是由其他文件克隆而来，我想在需要将工艺边板加到三和一小板中，如何操作？在工艺边板中框选待复制对象，按CTRL+C 然后再该pcb文件中按CTRL+V 在工艺边PCB视窗中不要左键确定，也不要右键取消，点击三和一小板，来到该板子 CTRL+V 复制 左键点击该PCB视窗，确定","tags":["EDA"]},{"title":"硬件基础篇-常见封装工艺","path":"/2024/10/14/硬件基础篇-常见封装工艺/","content":"DIP封装 SOP封装 QFP封装 QFN封装 BGA封装 LGA封装 PGA封装 常见封装 DIP封装 SOP封装 QFP封装 QFN封装 BGA封装 LGA封装 inter CPU PGA封装 AMD CPU 【7种常见的芯片封装形式，你了解几种？】 https://www.bilibili.com/video/BV1kT421a7mS/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["硬件基础"]},{"title":"常见通讯协议","path":"/2024/10/14/常见通讯协议/","content":"USB通讯 物理接口 3.0是高速线，有设计规范 如何识别USB接口电路的速度呢？ 低速接口设计 高速&#x2F;全速接口设计 从机的上拉电阻在D-线上为低速，在D+线上为高速。高速和全速通过硬件区分 USB2.0接口电路 补充知识，共模电感，能够抑制共模信号，用于电源和信号的EMI电路中 TVS和ESD二极管的区别TVS,瞬态抑制，ESD,防静电 USB3.0接口设计 重学 ESD器件选择双向负载电容，USB2.0小于2PF,USB3.0小于0.2PF CAN通讯Controller Area Network半双工通信总线can收发芯片 差分信号(差模信号) 电压差为0为逻辑1。有利于抗干扰和减少噪声，需要双线输入，传输距离长 数据结构和传输协议 两个设备同时发送信息，以哪个设备信息优先呢？ 要看11位的识别码，识别码中不同的以最先出现逻辑0优先。 【趋近于完美的通讯 CAN总线！4分钟看懂！】 https://www.bilibili.com/video/BV14k4y187e6/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【CAN接口电路设计】 https://www.bilibili.com/video/BV1FT411g77P/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6 SPI通讯芯片与芯片的（一主多从） 四条信号线 ss(片选信号线，大多数低电平时片选有效) SCK(时钟信号线) MOSI(发送信号线) MISO(接受信号线) 【深入理解SPi通讯协议，5分钟看懂！】 https://www.bilibili.com/video/BV1F54y1M7e7/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["单片机"]},{"title":"3D打印耗材直径的检测方案","path":"/2024/10/13/3D打印耗材直径的检测方案/","content":"本文主要讨论3D打印耗材直径的检测，前期所有的数据将由单片机呈现，后期将考虑加入klipper固件。目前主流的方案有两种，一种是线性CCD检测，一种是基于霍尔检测。 霍尔检测 采用俩个49E 12345678910111213141516171819202122232425262728293031323334353637383940414243void setup() &#123; // 初始化引脚和串口 pinMode(A0, INPUT); pinMode(A1, INPUT); Serial.begin(115200); // 设置波特率为115200&#125;int mi15 = 118; // 对应1.5mm的数值int mi20 = 138; // 对应2.0mm的数值void loop() &#123; int sum = 0; int count = 8; // 需要的循环次数 for (int i = 0; i &lt; count; i++) &#123; int a = analogRead(A0); int b = analogRead(A1); sum += (a - b); // 累加差值 delay(5); // 每次读取之间的延时，防止数据过于密集 &#125; int average = sum / count; // 计算平均值 if (average &lt; 90) &#123; // 如果平均值小于90，打印&quot;none&quot; Serial.println(&quot;none&quot;); &#125; else if (average &gt; 160) &#123; // 如果平均值大于160，打印&quot;out&quot; Serial.println(&quot;out&quot;); &#125; else &#123; // 当平均值在90到160之间，线性插值计算毫米值 float mmValue = 0; if (average &gt;= mi15 &amp;&amp; average &lt;= mi20) &#123; // 如果平均值小于或等于 mi15，则按1.5mm处理 mmValue = 1.5 + (float(average - mi15) / (mi20 - mi15)) * (2.0 - 1.5); &#125; Serial.print(&quot;毫米值: &quot;); Serial.println(mmValue); // 打印毫米值 &#125;&#125; 目前存在问题，变化幅度小，分辨率低 霍尔检测修正增加差分放大，放大4.7倍，OUT引脚读取 测试代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define READ_COUNT 5 // 连续读取次数// 接线：A0接OUT,A2接IN-,A3接IN+// 定义模拟值对应的毫米数const float VALUE_0_0MM = 222.0; // 0.0mm 对应的模拟值const float VALUE_1_5MM = 382.0; // 1.5mm 对应的模拟值const float VALUE_2_0MM = 440.0; // 2.0mm 对应的模拟值void setup() &#123; Serial.begin(9600); // 初始化串口通讯&#125;void loop() &#123; // 读取模拟值 float analogValueA0 = readAverage(A0); float mmValueA0 = calculateMM(analogValueA0); float analogValueA1 = readAverage(A2); float mmValueA1 = calculateMM(analogValueA1); float analogValueA2 = readAverage(A3); float mmValueA2 = calculateMM(analogValueA2); // 打印结果 Serial.print(&quot;A0 - Analog: &quot;); Serial.print(analogValueA0); Serial.print(&quot; mm: &quot;); Serial.println(mmValueA0); Serial.print(&quot;A2 - Analog: &quot;); Serial.print(analogValueA1); Serial.print(&quot; mm: &quot;); Serial.println(mmValueA1); Serial.print(&quot;A3 - Analog: &quot;); Serial.print(analogValueA2); Serial.print(&quot; mm: &quot;); Serial.println(mmValueA2); delay(100); // 延迟100毫秒&#125;// 读取指定模拟引脚的平均值float readAverage(int pin) &#123; long sum = 0; // 用于累加读取值 for (int i = 0; i &lt; READ_COUNT; i++) &#123; sum += analogRead(pin); delay(10); // 读取间隔，避免读取过快 &#125; return sum / (float)READ_COUNT; // 返回平均值&#125;// 根据模拟值计算毫米数（线性变化公式）float calculateMM(float analogValue) &#123; // 检查模拟值范围，确保线性插值正常工作 if (analogValue &lt;= VALUE_0_0MM) return 0.0; // 小于等于 0.0mm if (analogValue &gt;= VALUE_2_0MM) return 2.0; // 大于等于 2.0mm // 使用分段线性插值计算 if (analogValue &lt;= VALUE_1_5MM) &#123; // 范围 [0.0mm, 1.5mm] return (analogValue - VALUE_0_0MM) * (1.5 - 0.0) / (VALUE_1_5MM - VALUE_0_0MM); &#125; else &#123; // 范围 [1.5mm, 2.0mm] return 1.5 + (analogValue - VALUE_1_5MM) * (2.0 - 1.5) / (VALUE_2_0MM - VALUE_1_5MM); &#125;&#125; 线性CCD检测CCD的基本原理","tags":["项目"]},{"title":"电机与拖动","path":"/2024/10/06/电机与拖动/","content":"基本概念 电机及其分类 所有物质都具有导磁能力，只是强弱不同 习题 铁磁性材料的性质 习题 总结","tags":["课程"]},{"title":"硬件基础篇-二极管","path":"/2024/10/06/硬件基础篇-二极管/","content":"总体介绍 封装各不相同 常见分类 普通二极管 恒流二极管 肖特基二极管 快恢复二极管 TVS 齐纳二极管（稳压二极管） 发光二极管 光电二极管 变容二极管 双向触发二极管 开关二极管 肖特基二极管和快恢复二极管的反向恢复时间都较短，肖特基10ns，快恢复二极管的反向恢复时间要长于肖特基二极管，但是，肖特基二极管的反向耐压低常规二极管的正向压降在0.7V,发光二极管在2-3V之间 开关二极管和TVS是什么？ 普通二极管（常规二极管） K为阴极，A为阳极 二极管的作用 防反接 钳位 限幅 检波 整流 续流 倍压 逻辑门 倍压需要交流电，下图是二极管倍压电路，输入交流，输出直流 雪崩击穿与齐纳击穿及热击穿参数 封装 正向导通电压 结电容 反向击穿电压 平均电流&#x2F;峰值电流（100mA左右） 浪涌电流 正向压降 反向电流漏电流 反向恢复时间 浪涌电流，电容电感等初始充电时，产生的较大电流，时间1ns左右，下图中的前段时浪涌电流，后段峰值部分被称成为峰值电流。 齐纳二极管重要参数 标称稳定电压$V_{z}$ 额度工作电流$I_{zt}$ 最小稳定工作电流$I_{zk}$ 最大稳定工作电流$I_{zm}$ 最大耗散功率$P_{zm}$ 动态电阻（越小，稳压越好） 温度系数 R1是限流电阻，R2是负载。 不如做道题，电压小于反向击穿电压时，齐纳管是截至状态。 TVS与齐纳二极管的区别 TVS有单向和双向的区分，稳压管都是单向的； TVS通流比较大，20A都算正常，稳压管通流较小； TVS常放置在接口引脚处，稳压管放在板内信号或电源上； TVS响应时间很快，可达ps级，稳压管很少将相应时间； TVS管用于瞬态电压保护，稳压管对漏极和源极进行箝位保护。 应用 稳压二极管不允许并联，但可以串联（正反向） 过压保护 稳压输出 肖特基二极管 应用，双电源切换这里要压降低，反向恢复速度快 参考文献 【稳压二极管的关键参数】 https://www.bilibili.com/video/BV1WiHveQEhN/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["硬件基础"]},{"title":"硬件基础篇-电池篇","path":"/2024/10/03/硬件基础篇-电池篇/","content":"这里只对我目前使用或接触的电池进行介绍，并不全面与准确 电池的分类 锂电池 铅蓄电池 干电池 这里的分类并不全面，只针对我接触的电池，其中锂电池是重点 干电池是我们家用常见的电池，5号电池与7号电池，以及小圆薄片电池铅蓄电池常用于电瓶，也称为铅酸电池，比锂电池更安全，而且便宜。但是重又大。 锂电池 注意，淘宝上很多锂电池的电芯是18650 钴酸锂电池常用于手机平板，三元锂电池是使用最广泛的一种电池，磷酸电池常用于电动车和户外储能，但不耐低温，锰酸锂电池价格便宜，用于快消平，充电宝等 航模电池由于无人机和智能车捣鼓的比较多，这里就介绍一下航模电池。接头常用型号XT30,XT60,T型插头, DC插头 具体淘宝搜索查看 平衡头，检测电压。可用BB响检测电压 电池参数 电芯 电压 容量 最大放电电流 充电倍率 以下图为例 上图展示的是一个航模电池的主视图和侧视图。由侧视图可以看出有三块电芯，即3S电池，3s表示3块电池串联，1p表示1块电池变量，1p省略。一般一块电芯额度电压为3.7V,最大电压4.2V,则上图的3S电池额定电压为11.1V,最大充电到电池电压为12.6V，满电。1100mAh 表示充满电后，电压为额定电压，放电电流1100mA的情况下，可以放电1小时，即电池的容量，W&#x3D;mAhV，总做工为容量乘以电压。30C为其放电倍率，表示在最大工作放电电流为1100mA30，即33A.charge为充电，该图充电倍率未注明该电芯为软包电池 报废电池处理盒子加水，放入适量食用盐，将待报废电池置入盒体，将盒子放置到阳台等卡阔通风处，静置两天，直至电池接口处不再冒出气泡，有铜绿出现开始 两天后 参考资料 【如何低成本 自制穿越机固定翼用 高性能航模电池 电池组装教学】 https://www.bilibili.com/video/BV1Qg4y1C7E3/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【用废旧电池，小伙制作出耐用的铅酸电瓶，让你的电器更持久！】 https://www.bilibili.com/video/BV1cM4m1X7CS/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【锂电池种类千千万，你知道他们的区别吗？】 https://www.bilibili.com/video/BV1Q24y1w7Su/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【航模电池，需要知道这些！【我的第一架遥控飞机】第四集】 https://www.bilibili.com/video/BV1M7411C7gi/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["硬件基础"]},{"title":"硬件设计研究","path":"/2024/09/26/硬件设计研究/","content":"硬件工程师基本分类 板卡规范，CPCI&#x2F;PCle&#x2F;VPX 电阻1英寸&#x3D;25.4mm需找一个电阻的数据手册封装分类，阻值辨识，电气特性， 分类 厚膜电阻和薄膜电阻的区别 选型参数 阻值 精度 额定功率 额定电压、最高工作电压 温度系数"},{"title":"Arduino uno 开发","path":"/2024/09/05/Arduino-uno-开发/","content":"前言写下此文字时，是24年6月10日，我刚刚结束24年6月1,2日的中国机器人及人工智能大赛的北京市省赛和6号的模电考试，省赛是线下比赛，第一天调试不顺，第二天比赛也是匆匆忙忙，十分混乱。比完后内心感慨，思绪良久。七八号左右出成绩，幸运的是，二队省一，一队三队省二，基本上都可以进国赛。虽然十五号四级，但内心有一种强烈的欲望，想要对自己进行整理，生理上的，心理上的。我开始对我的技术栈进行整理，决定从最简单的auduino开始，这也是我写下本文的初衷，对知识进行整理。本文大概分为四个部分，第一部分，arduino基础知识学习，第二部分，外设的使用，第三部分，电机的驱动，第四部分，实战。第三部分按理应放在第二部分，但个人认为电机驱动部分相对重要，就单列一部分了。我将遵循简约，准确的原则开始编写本文。本文并不针对初学者，需要一些C语言知识，电学知识作为前置知识，本文不介绍此部分。本文使用了chat，加速本文的开发。 第一章\tArduino uno初识1.1\tArduino简介Arduino 旗下系类有很多，其中用途广泛的有四种，Arduino UNO，Arduino mega 2560,Arduino nano,Arduino uno wifi. 顺序从左到右对应。Arduino UNO为通用型号，mega 2560引脚多，功能更强大，Arduino nano,板子小巧，质量轻，体积小，Arduino UNO wifi,多了个wifi功能，建议别用，直接用esp32.本文主要针对的是arduino uno进行开发介绍。中文网站如下 https://arduino.nxez.com/ 1.2\tArduino 引脚功能介绍 引脚分为5个区，区域如下 1区为引脚供电区，-\tIORES,输入输出参考电压-\tRESET,复位引脚，默认输出为1，下拉即可复位。-\t3.3V和5V是供电引脚，uno可通过USB输入电源,此时，3.3V和5V可对外供电，也可通过3.3V和5V对单片机进行供电，不使用usb供电-\tGND,地线-\tVin,外部电源为开发板供电 2区为模拟口引脚区(analog)ADC表示模拟到数字转换器。 ADC是用于将模拟信号转换为数字信号的电子电路。模拟信号的这种数字表示允许处理器（其是数字设备）测量模拟信号并在其操作中使用它。 Arduino引脚A0-A5能够读取模拟电压。在Arduino上，ADC具有10位分辨率，这意味着它可以通过1,024个数字电平表示模拟电压。 ADC将电压转换成微处理器可以理解的位。模拟引脚只能模拟输入，不能模拟输出。3区为ICSP插头接口区 4区为同3区，部分板子无此区域5区为数字引脚区(digital)Arduino Uno的引脚0-13用作数字输入&#x2F;输出引脚。其中，引脚13连接到板载的LED灯；引脚3、5、6、9、10、11具有PWM功能 以下是 Arduino Uno 的一些关键硬件规格：•\t微控制器：ATmega328P•\t工作电压：5V•\t输入电压（推荐）：7-12V•\t输入电压（限制）：6-20V•\t数字I&#x2F;O引脚：14（其中6个提供PWM输出）•\t模拟输入引脚：6•\t每个I&#x2F;O引脚的直流电流：20 mA•\t3.3V引脚的直流电流：50 mA•\t闪存：32 KB（ATmega328P），其中0.5 KB用于引导加载程序•\tSRAM：2 KB（ATmega328P）•\tEEPROM：1 KB（ATmega328P）•\t时钟速度：16 MHz 1.3\tArduino 供电与取电 Arduion UNO 的供电方式有四种1.\tUSB接口供电（5V）2.\t外部电源接口供电，直流电源电压必须为7V ~ 12V3.\tVin供电引脚供电，供电电压7~12V4.\t5V引脚5V供电。 注意通过VIN引脚供电，有一定可能性造成降压芯片烧毁，所以，如果电源12V，走外部电源接口供电，如果电源5V，走5V引脚供电。 3.3V无法通过3.3V引脚供电，会造成单片机工作异常。 大功率用电模块不要走单片机的引脚供电，一方面，供电不足，另一方面，可能造成烧毁或异常。 1.4\tArduino 引脚设置打开Arduino的开发IDE,插上arduino,使用USB接口,另一端接入电脑，选择端口和开发板。IDE的安装和端口选择及中文语言选择自行百度，这里略过。IDE如下。 Setup(){}函数为初始化函数，会在arduino开机时执行一次。Loop(){}函数为循环函数，主程序会在这里循环执行。 我们在这里学习数字和模拟引脚的设置。 1.4.1数字引脚数字引脚即可以输入也可以输出。该类引脚有两种状态，高电平(1)与低电平(0)，高低电平的确定由参考电压(AREF)确定。每个数字I&#x2F;O口（input,输入，output，输出）可提供最高40mA的电流和5V的电压。数字I&#x2F;O口定义函数。 pinMode(pin,mode) pinMode()函数为数字引脚定义函数，第一个参数pin,为引脚标号，即要设置那个引脚，范围为0-13，即数字引脚区。Mode有三种模式，INPUT(输入)，INPUT_PULLUP(带上拉电阻输入)，OUTPUT(输出)。 digitalWrite(pin,mode); 设置引脚输出状态后，可用digitalWrite函数设置引脚置为0还是1，不设置的话默认为LOW,低电平。第一个参数为引脚标号，第二个参数为状态，LOW或者HIGH; digitalRead(pin); digitalRead(pin)该函数为读取引脚状态，返回值为int型。结果为HIGH,LOW。注意：在进行读取引脚操作前，需先对引脚输入模式进行定义 1.4.2模拟引脚使用模拟引脚时，在模拟方面只能模拟输入无法模拟输出。 int b&#x3D;analogRead(A0); A0为模拟口的一个引脚，可替换为A0，A1- A5;返回值为0-1023一个数字，模拟引脚内置10位A&#x2F;D转换器，能将0~5V的电压转换为0-1023的数值，读取精度为5V&#x2F;210即，每单位4.9mV.模拟口也可作为数字引脚使用。使用如下 pinMode(A0,OUTPUT); digitalWrite(A0,HIGH); A0A5也可用14-19表示。1.4.2PWM引脚在数字引脚上，我们可以观察到有的数字引脚旁边带号，这说明此引脚具有PWM输出的功能。如何使用这些引脚输出PWM波呢？首先，这些引脚是数字引脚区，应先设置引脚输出状态，再设置PWM波的占空比。 pinMode(3,OUTPUT); analogWrite(3,100); 通过anglogWrite(pin,Value);设置占空比，占空比范围为0-255。PWM波不是模拟输出，arduino的PWM波输出频率较低，一千Hz以内，后续再详细介绍PWM. 1.5\tArduino串口通讯通过USB线将板子和计算机连接，可实现串口通讯，UNO的硬件串口资源仅有一个，一个串口资源，仅支持1对1，板子与计算机通讯时不要使用其他模块占用此通道，否则可能造成串口传输乱码，或者下载失败。本小节仅讨论计算机与板子的串口操作，串口的其他操作后续内容后面章节补充 1.5.1串口初始化使用 Serial.begin(baudRate) 函数来初始化串口通信，参数 baudRate 是波特率（数据传输速率），常见值是 9600, 115200 。初始化内容一般放在setup函数里。如下。 123void setup() &#123; Serial.begin(9600); // 初始化串口通信，波特率为9600&#125; 1.5.2发送数据• Serial.print(data)：发送数据，但不换行。• Serial.println(data)：发送数据并换行。可用串口接收器接受。 1.5.3接受数据• Serial.available()：返回串口缓冲区中的字节数。• Serial.read()：读取串口缓冲区中的一个字节，返回值为 -1 表示没有数据可读。• Serial.readString()：读取串口缓冲区中的字符串，直到超时（需要 Serial.setTimeout() 配合）。• Serial.readStringUntil(char terminator)：读取串口缓冲区中的字符串，直到遇到终止符（如换行符）。Serial.setTimeout(500); &#x2F;&#x2F; 设置超时为500毫秒 1.5.4串口综合12345678910111213141516void setup() &#123; Serial.begin(9600); // 初始化串口，波特率为9600 Serial.setTimeout(1000); // 设置读取操作的超时时间为5秒，可注释 Serial.println(&quot;Enter a string (timeout 5 seconds):&quot;); //提示用户输入字符串&#125;void loop() &#123; // 检查是否有数据可读 if (Serial.available() &gt; 0) &#123; String receivedString = Serial.readString(); // 读取串口缓冲区中的字符串 Serial.print(&quot;You entered: &quot;); Serial.println(receivedString); // 打印接收到的字符串 &#125; delay(500); // 延迟500毫秒&#125; 操作时，要注意程序运行在uno上，主体是单片机而不是计算机。 1.6\tArduino AREF与IOREF的使用部分arduino的板子的IOREF引脚会该成5V供电引脚 ,查阅原理图，IOREF被锁死。 AREF在mega328中，有六个模拟输入引脚，这些模拟输入引脚简单的说测量的是输入的电压值然后用 0~ 1023来表示电压的大小，当然，这个值有一个范围，通常来说是0~5V，查阅UNO的规格书可以知道UNO是具有10位的ADC。 10位ADC以为着什么呢？以为着它能将0 ~ 5 V的电压分成1024份（2^10），算出来即为4.882mV的测量精度，举个例子就是0V的时候测量结果为0，5V为1023，3V约为615，但是有一种情况就是你输入的电压最大是3.3V，测量出来的最大值也就是675，这个时候你或许会想到map，确实这不失为一个好办法。 但是AREF提供了另一个更好的解决办法，即在AREF接入一个最大模拟输入量作为参考值（比如上面所说的3V3），这样不仅能直接读到1023，更为重要的是精度提高，用3V3作为AREF的时候精度是多少？？ 3.3&#x2F;1023 &#x3D;&#x3D;3.223mV，测量精度提高了。 使用外部电源注意事项：-\t确保外部参考电压在 0 到 Vcc 之间，对于 5V Arduino 板，电压应在 0 到 5V 之间。-\t外部参考电压不应超过 Vcc，否则可能会损坏 Arduino 板。-\t使用一个稳定的电压源作为外部参考电压。如果外部参考电压不稳定，ADC 的精度会受到影响。-\t如果已经连接了外部参考电压，不要在代码中使用 analogReference(DEFAULT); 或 analogReference(INTERNAL);。这样可能会引起冲突和不正确的读数。 123456789void setup() &#123; Serial.begin(115200); analogReference(EXTERNAL); // 使用外部参考电压&#125; void loop() &#123; int a = analogRead(A0); Serial.println(a); &#125; 1.7\tArduino 上拉电阻上拉电阻是什么？在I&#x2F;O口模式设置中，输入模式有两种，INPUT和INPUT_PULLUP,这两者有什么区别吗？本节将解答上面的问题。输入模式的引脚相当于电压表的探头，如果测得电压比基准电压高，则为1，比基准电压低为0；首先我们要了解一个概念，引脚悬空，即当某个引脚处于输入模式时，而该引脚什么也没有接的情况称之为引脚悬空。灵魂画手上线，如下图。 引脚悬空会有什么问题呢？会造成读取的引脚状态不对，此时是高电平还是低电平呢？无法确定。 123456789101112void setup() &#123; Serial.begin(115200); pinMode(2,INPUT);&#125;void loop() &#123; delay(50); int a =digitalRead(2); Serial.println(a);&#125; 打印结果如下，特别是将手指捏在悬空引脚尤为明显。 而将引脚模式设置为输入上拉后，输出不飘了，为1. pinMode(2,INPUT_PULLUP); Arduino内部的上拉电阻为20K欧，一般上拉电阻为10K欧 此时引脚不接东西时，测的电压为VCC,即高电平，上拉电阻阻值较大，能够限流，防止大电流灌入引脚。当引脚接GND时，此时pin测的电压为GND的电压，为低电平。不使用单片机的内置上拉电阻，自行在输入引脚外接一个阻值大小合适电阻是相同的效果。上拉电阻稳定输入引脚状态，克服了引脚悬空带来的引脚测量值不准的问题。 1.8\tArduino 定时器资源Arduino Uno 基于 ATmega328P 微控制器，该微控制器包含三个硬件定时器资源：Timer0、Timer1 和 Timer2。每个定时器有不同的特性和用途，具体如下： Timer0类型：8位定时器用途：主要用于 Arduino 内部计时功能，例如 millis() 和 delay() 函数。它可以生成中断，用于更新系统时间。尽量不要更改这个定时器。PWM 引脚：5和 6（对应 Arduino 引脚）Timer1类型：16位定时器用途：由于其较高的分辨率，Timer1 常用于需要精确时间控制的任务，例如 Servo 库。它也可以生成高精度的 PWM 信号。PWM 引脚：9 和 10（对应 Arduino 引脚）Timer2类型：8位定时器用途：通常用于生成较低频率的 PWM 信号或执行其他定时任务。其频率设置比较灵活，适用于音频生成等应用。PWM 引脚：3 和 11（对应 Arduino 引脚） 中断频率（Hz）&#x3D;（Arduino时钟速度16MHz）&#x2F;（预分频器*（比较匹配寄存器+ 1）) WGM02、WGM01、WGM00：这三个位用于选择相位校正（phase correct）模式、快速（Fast）模式或CTC模式。相位校正模式：计数器在达到最大值（255）后开始减小，形成一个三角形波形。快速模式：计数器达到最大值后归零，形成锯齿波形。CTC模式：计数器在达到OCR0A（比较寄存器A）后归零，形成可变的锯齿波形。CS02、CS01、CS00：用于控制预分频系数，即将系统时钟分频得到计时器时钟。分频系数1：无分频。分频系数8：系统时钟除以8。比较寄存器A、B：除了设置定时器外，还有两个寄存器用于控制PWM比较值，从而控制占空比。COM0A1、COM0A0、COM0B1、COM0B0：用于设置PWM输出引脚的电平。COM0A1&#x2F;COM0B1、COM0A0&#x2F;COM0B0为1、1时，当OCR比较寄存器小于计数器值时引脚输出0，大于计数器值时输出1。COM0A1&#x2F;COM0B1、COM0A0&#x2F;COM0B0为1、0时，当OCR比较寄存器小于计数器值时引脚输出1，大于计数器值时输出0。CTC模式下，COM0A1&#x2F;COM0B1、COM0A0&#x2F;COM0B0为0、1时，每当计数器溢出，引脚输出取反。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int toggle0, toggle1, toggle2;void setup() &#123; cli(); // 关闭全局中断 // 设置定时器0为10kHz(100us) TCCR0A = 0; // 将整个TCCR0A寄存器设置为0 TCCR0B = 0; // 将整个TCCR0B寄存器设置为0 TCNT0 = 0; // 将计数器值初始化为0 // 设置计数器为10kHz，即100us OCR0A = 24; // 比较匹配寄存器 = [16,000,000Hz /（预分频器 * 所需中断频率）] - 1 // 比较匹配寄存器 = 24, 中断间隔 = 100us 即中断频率10kHz TCCR0A |= (1 &lt;&lt; WGM01); // 打开CTC模式 TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00); // 设置CS01位为1，CS00位为1(64倍预分频) TIMSK0 |= (1 &lt;&lt; OCIE0A); // 启用定时器比较中断 // 设置定时器1为1kHz TCCR1A = 0; // 将整个TCCR1A寄存器设置为0 TCCR1B = 0; // 将整个TCCR1B寄存器设置为0 TCNT1 = 0; // 将计数器值初始化为0 // 设置计数器为1kHz，即1ms OCR1A = 1999; // = (16*10^6)/(1000*8) - 1 (must be &lt;65536) TCCR1B |= (1 &lt;&lt; WGM12); // 打开CTC模式 TCCR1B |= (1 &lt;&lt; CS11); // 设置CS11位为1(8倍预分频) TIMSK1 |= (1 &lt;&lt; OCIE1A); // 启用定时器比较中断 // 设置定时器2为8kHz TCCR2A = 0; // 将整个TCCR2A寄存器设置为0 TCCR2B = 0; // 将整个TCCR2B寄存器设置为0 TCNT2 = 0; // 将计数器值初始化为0 // 设置计数器为8kHz OCR2A = 249; // = (16*10^6) / (8000*8) - 1 (must be &lt;256) TCCR2A |= (1 &lt;&lt; WGM21); // 打开CTC模式 TCCR2B |= (1 &lt;&lt; CS21); // 设置CS21位为1(8倍预分频) TIMSK2 |= (1 &lt;&lt; OCIE2A); // 启用定时器比较中断 sei(); // 打开全局中断&#125;// 中断0服务函数ISR(TIMER0_COMPA_vect) &#123; // timer0中断，产生频率为10kHz / 2 = 5kHz的脉冲波 if (toggle0) &#123; digitalWrite(8, HIGH); toggle0 = 0; &#125; else &#123; digitalWrite(8, LOW); toggle0 = 1; &#125;&#125;// 中断1服务函数ISR(TIMER1_COMPA_vect) &#123; // timer1中断，产生频率为2Hz / 2 = 1Hz的脉冲波 if (toggle1 &gt;= 500) &#123; digitalWrite(13, HIGH); &#125; if (toggle1 &lt;= 500) &#123; digitalWrite(13, LOW); &#125; toggle1 += 1; if (toggle1 &gt;= 1000) &#123; toggle1 = 0; &#125;&#125;// 中断2服务函数ISR(TIMER2_COMPA_vect) &#123; // timer2中断，产生频率为8kHz / 2 = 4kHz的脉冲波 if (toggle2) &#123; digitalWrite(9, HIGH); toggle2 = 0; &#125; else &#123; digitalWrite(9, LOW); toggle2 = 1; &#125;&#125;// 主循环函数void loop() &#123;&#125; 1.9\t其他板间通讯。如果想对板子进行更细致的操作，建议更换STM32,或者其他单片机。 第二章\t常用模块的使用2.1 红外对光管的检测 应用场合： 1.电度表脉冲数据采样 2.传真机碎纸机纸张检测 3.障碍检测 4.黑白线检测 DO 为数字输出口AO为模拟输出口可5V或3.3V供电。 中间的螺旋可以调节探测的距离。当红外接收器接受到信号时，开光指示灯亮起。DO为低电平，检测这个端口的值，即可知道探测状态。 测试5V供电，DO引脚接3号，AO接A0 12345678910111213void setup() &#123; pinMode(3,INPUT_PULLUP);//使用三号数字引脚探测DO Serial.begin(115200); // 初始化串口，波特率为115200&#125;void loop() &#123; // put your main code here, to run repeatedly: int a = digitalRead(3); //变量a接受数字值 int b = analogRead(A0); //变量b接受模拟值 Serial.println(a); Serial.println(b); delay(100);&#125; 当开关灯亮时，一个模拟值，一个数字值。串口显示器显示如下 2.2光敏&#x2F;热敏传感器的检测 这里以光敏传感器为例，热敏检查代码相同。应用场景1.\t暗室监测2.\t熄屏亮灯此类传感器与红外检查方法基本类似，将检测的模拟值，根据实际情况转化为实际量，温度，光照等。 接线：DO接数字引脚2，AO接模拟引脚A0。原理，这两个相当于电阻，电阻值随环境变化而变化。 12345678910111213void setup() &#123; pinMode(2,INPUT_PULLUP); Serial.begin(115200);&#125;void loop() &#123; int a = digitalRead(2); int b = analogRead(A0); Serial.print(&quot;a=&quot;); Serial.println(a); Serial.print(&quot;b=&quot;); Serial.println(b); &#125; 读到的模拟量需根据光敏电阻的参数转化为具体的亮度。 2.3超声波传感器 应用场合：1.机器人避障和导航2.距离测量3.接近测量4.智能垃圾桶 可3.3V或者5V输入 HC-SR04超声波测距模块可提供2cm-60cm的非接触式距离感测功能，测距精度可达高到3mm；模块包括超声波发射器、接收器与控制电路。超声波测距模块——触发信号后发射超声波，当超声波投射到物体而反射回来时，模块输出——回响信号，以触发信号和回响信号间的时间差，来判定物体的距离。使用首先要安装NewPing 库。注意，该库会调用定时器2资源。网上的很多关于超声波模块的教程，不使用定时器，并且使用delay(),会挤占主进程。 12345678910111213141516171819202122232425262728#include &quot;NewPing.h&quot; #define TRIGGER_PIN 2 //引脚定义#define ECHO_PIN 3#define MAX_DISTANCE 60 //设置最大距离NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); float duration, distance; int iterations = 5; //求平均的次数 void setup() &#123; Serial.begin (115200);&#125; void loop() &#123; duration = sonar.ping_median(iterations); //多次测量时间求平均值 distance = (duration / 2) * 0.0343; //将测量的时间转换成距离 Serial.print(&quot;Distance = &quot;); if (distance &gt;= MAX_DISTANCE || distance &lt;= 2) &#123; Serial.println(&quot;Out of range&quot;); &#125; else &#123; Serial.print(distance); Serial.println(&quot; cm&quot;); &#125;&#125; 经测试，结果如下 注意，当靠的太近时，距离不准，会增加。本代码对数据只进行求平均处理，可用其他方法进行滤波。减小误差。 2.4 4PIN-OLED 小屏幕的驱动 应用场景：1.\t显示输出2.\t多级菜单3.\t表情显示 可3.3V或者5V输入，一般使用有多重库函数，这里使用u8g2库SCL接A5,SDA接A4，示例如下 使用：首先要安装u8g2库，该库可以驱动4pin,0.96寸OLED小屏幕 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;U8g2lib.h&gt; //u8g2库#define SCL A5 //引脚定义，可替换为数字引脚#define SDA A4U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0,SCL,SDA); //配置构造函数 int a=66; //定义变量a=66void setup() &#123; u8g2.begin(); //启动u8g2驱动程序 u8g2.clearBuffer(); //清空显示屏缓存&#125;void loop() &#123; face(); //调用函数，显示图案 delay(1000); //持续一秒钟 heart(); //调用函数，显示英文字母和图案 delay(1000); //持续一秒钟 letter(a); //调用函数，显示中文和变量 delay(1000); //持续一秒钟&#125;void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; void heart()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.setFont(u8g2_font_open_iconic_human_2x_t); // 设置字体 u8g2.drawGlyph(58,30,66); // 画心，符号左下角坐标为（58,36），符号编号为66 u8g2.setFont(u8g2_font_unifont_t_chinese2); //设置字体 u8g2.drawUTF8(58+20,30,&quot;ZFY&quot;); //显示英文，左下角位置坐标为（78，30） u8g2.drawUTF8(58-14-16,30,&quot;JHR&quot;); //显示英文，左下角位置坐标为（28，30） u8g2.sendBuffer(); // 加载以上内容&#125; void letter(int a)&#123; u8g2.clearBuffer(); //清空显示屏缓存 //int8_t a=u8g2.getMaxCharHeight(); //获取最大高度 //int8_t b=u8g2.getMaxCharWidth(); //获取最大宽度 u8g2.setFont(u8g2_font_unifont_t_chinese2); //设置字体 u8g2.drawUTF8(20,17,&quot;智能检测系统&quot;); //显示文字，左下角位置坐标为（20，17） u8g2.drawUTF8(50,34,&quot;：&quot;); //显示:，左下角坐标为（50,34） u8g2.drawUTF8(0,34,&quot;位移为:&quot;); u8g2.setCursor(64,34); //设置将要打印变量的左下角坐标 u8g2.drawUTF8(0,34,&quot;位移为:&quot;); u8g2.print(a); //打印变量a u8g2.sendBuffer(); // 加载以上内容 &#125; 屏幕显示还有ISP协议的，这种一般为7PIN，这里只介绍相对简单，接线少，使用I2C协议的4pin,0.96寸OLED屏幕。 2.5温湿度传感器 使用DHT11，温湿度传感器还有其他类型DHT22等应用场景1.\t温湿度检测2.\t小闹钟配件 引脚正对着自己，从左至右。 使用，安装库Adafruit Unified Sensor及DHT-sensor-library两个库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 需要以下 Arduino 库：// - DHT 传感器库：https://github.com/adafruit/DHT-sensor-library// - Adafruit 统一传感器库：https://github.com/adafruit/Adafruit_Sensor#include &quot;DHT.h&quot;#define DHTPIN 2 // 连接到 DHT 传感器的数字引脚// Feather HUZZAH ESP8266 注意：使用引脚 3, 4, 5, 12, 13 或 14 --// 引脚 15 也可以使用，但在上传程序时必须断开 DHT 连接。// 取消注释你正在使用的传感器类型！#define DHTTYPE DHT11 // DHT 11//#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321//#define DHTTYPE DHT21 // DHT 21 (AM2301)// 将传感器的引脚 1（左边的）连接到 +5V// 注意：如果使用 3.3V 逻辑电平的板子（如 Arduino Due），将引脚 1 连接到 3.3V 而不是 5V！// 将传感器的引脚 2 连接到 DHTPIN// 将传感器的引脚 3（右边的）连接到 GND（如果传感器有 3 个引脚）// 将传感器的引脚 4（右边的）连接到 GND，并且引脚 3 空置（如果传感器有 4 个引脚）// 将一个 10K 电阻从传感器的引脚 2（数据）连接到引脚 1（电源）// 初始化 DHT 传感器。// 注意：旧版本的库有一个可选的第三参数来调整较快处理器的时序。// 现在不再需要这个参数，因为当前的 DHT 读取算法会自适应较快的处理器。DHT dht(DHTPIN, DHTTYPE);void setup() &#123; Serial.begin(9600); Serial.println(F(&quot;DHTxx test!&quot;)); dht.begin();&#125;void loop() &#123; // Wait a few seconds between measurements. delay(2000); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds &#x27;old&#x27; (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht.readTemperature(true); // 检查是否有读取失败并提前退出（以便重试） if (isnan(h) || isnan(t) || isnan(f)) &#123; Serial.println(F(&quot;Failed to read from DHT sensor!&quot;)); return; &#125; // Compute heat index in Fahrenheit (the default) float hif = dht.computeHeatIndex(f, h); // Compute heat index in Celsius (isFahreheit = false) float hic = dht.computeHeatIndex(t, h, false); Serial.print(F(&quot;Humidity: &quot;)); Serial.print(h); Serial.print(F(&quot;% Temperature: &quot;)); Serial.print(t); Serial.print(F(&quot;°C &quot;)); Serial.print(f); Serial.print(F(&quot;°F Heat index: &quot;)); Serial.print(hic); Serial.print(F(&quot;°C &quot;)); Serial.print(hif); Serial.println(F(&quot;°F&quot;));&#125; 2.6HW504摇杆的使用 引脚说明GND 地5V 电源5VSW 按键（数字量）VRX X轴 （模拟量）VRY Y轴 （模拟量）1.输入电压范围：直流3.3V 至 5V。2.输出信号：模块特设二路模拟输出和一路数字输出接口，输出值分别对应（X，Y）双轴偏移量，其类型为模拟量；按键表示用户是否在Z轴上按下，其类型为数字开关量VRx，VRy （X、Y轴）为模拟输入信号，连接到模拟IO口A0A7。VRx，VRy 的值：从 0 ~ 1023 分别代表 左右，上~下。中间值为512。SW （Z轴）是数字输入信号，连接到数字端口，并启用上拉电阻。SW 的值：1代表未按下，0代表按下。实验这里VRx接A0，VRy接A1，SW接D6 12345678910111213141516171819int value = 0;void setup()&#123; pinMode(6, INPUT_PULLUP); Serial.begin(115200);&#125; void loop()&#123; value = analogRead(A0); Serial.print(&quot;X:&quot;); Serial.print(value, DEC); value = analogRead(A1); Serial.print(&quot; | Y:&quot;); Serial.print(value, DEC); value = digitalRead(6); Serial.print(&quot; | Z: &quot;); Serial.println(value, DEC); delay(100);&#125; 2.7WIFI模块的使用这里我们使用的是4Pin的ESP8266模块,这里只做简单的介绍，具体可后面学习ESP32.ESP8266模块内置TCP&#x2F;IP协议，能够实现串口与WIFI之间的转换。该模块有三种工作WIFI模式，STA,AP,STA+AP.STA,客户端模式，可连接其他WIFI,手机等设施实现对设备的远程连接。AP，接入点模式，模块作为WIFi热点。STA+AP,混合模式。 123456789101112131415161718#include&lt;SoftwareSerial.h&gt;#define rxPin 2#define txPin 3SoftwareSerial ESP8266(rxPin,txPin);void setup() &#123; // put your setup code here, to run once: Serial.begin(115200); ESP8266.begin(115200);&#125;void loop() &#123; // put your main code here, to run repeatedly: if(ESP8266.available()) Serial.write(ESP8266.read()); else if(Serial.available()) ESP8266.write(Serial.read());&#125; 测试，在串口里输入AT,会返回OK; 2.8\t其他Arduino uno的模块还有蓝牙模块等，不过感觉有些鸡肋，使用uno的板子搭配这些模块，不如直接买esp32.所以一些无线通讯的模块就不介绍了。Arduino的外设很丰富，这里就不多介绍了。 第三章\t电机的驱动3.1PWM波的认识PWM（Pulse Width Modulation，脉宽调制）是一种用于模拟信号和功率控制的技术，通过改变脉冲的宽度来调节信号的平均电压或功率.PWM 信号在一定周期内以高电平和低电平交替出现，通过改变高电平的持续时间（占空比）来实现对输出电压或功率的调节。应用场景有电机控制，LED调光，电源转换和通信等。 PWM的重要参数有，-\t频率（Frequency）：频率的选择取决于具体应用。例如，电机控制通常使用几千赫兹的频率，而 LED 调光可能使用几百赫兹到几千赫兹。-\t占空比（Duty Cycle）：占空比是指高电平时间相对于一个周期的比例，通常用百分比表示-\t分辨率（Resolution）：分辨率是指占空比可调节的最小步进，通常与控制器的位数有关。例如，8 位分辨率的 PWM 控制器可以将占空比调整到 256 个不同的级别。-\t电压幅度（Voltage Amplitude）：PWM 信号的高电平和低电平的电压值。高电平通常是电源电压（如 5V 或 3.3V），低电平通常是 0V。 一般而言，要特别注意频率，频率过低，在驱动电机时可能出现异常，电机哮鸣。一般电机是需要较高频率的PWM信号控制.单片机的PWM一般作为信号使用，驱动一些小功率LED时，可作为电源使用。 3.2 PWM波驱动小功率直流电机我们在前面学习到，UNO的数字引脚上有几个特定引脚可以输出PWM波，分别为3,5,6,9,10,11.但是这种方式 PWM 信号的频率是固定的默认值，引脚上的 PWM 信号频率约为490 Hz，在 Uno板上，引脚5和6的频率约为980Hz。 123456789# define analogPin 3 // 引脚命名void setup()&#123; pinMode(analogPin,OUTPUT);&#125;void loop()&#123; analogWrite(analogPin,100); // 输出PWM，占空比为 100/255&#125; 通过这种方法产生的PWM波频率过低，在驱动电机时可能出现异常。因此需要输出更高频率的PWM信号。此时，小功率的直流电机一端接GND,一端接3号引脚也是可以驱动的，通过调节占空比即可调节速率。为了使PWM的发生不占用主进程，这里使用定时器来操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 通过一个除数来分频给定的 PWM 引脚频率。 * 生成的频率等于基频除以给定的除数： * – 基频： * o 引脚 3、9、10 和 11 的基频是 31250 Hz。 * o 引脚 5 和 6 的基频是 62500 Hz。 * – 除数： * o 引脚 5、6、9 和 10 可用的除数有：1、8、64、256 和 1024。 * o 引脚 3 和 11 可用的除数有：1、8、32、64、128、256 和 1024。 * PWM 频率成对关联。如果一对中的一个改变，另一个也会改变以匹配： * – 引脚 5 和 6 在定时器0上成对 * – 引脚 9 和 10 在定时器1上成对 * – 引脚 3 和 11 在定时器2上成对 * * 请注意，此函数会对其他使用定时器的内容产生副作用： * – 改变引脚 3、5、6 或 11 可能会导致 delay() 和 millis() 函数停止工作。其他与定时相关的函数也可能受到影响。 * – 改变引脚 9 或 10 会导致 Servo 库无法正常工作。 * * 感谢 Arduino 论坛的 macegr 提供的 PWM 频率除数文档。他的帖子可以在以下链接查看： * http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1235060559/0#4 */void setup() &#123;// Set pin 6’s PWM frequency to 62500 Hz (62500/1 = 62500)// Note that the base frequency for pins 5 and 6 is 62500 Hz setPwmFrequency(6, 1); analogWrite(6,124);&#125;void loop() &#123;&#125;void setPwmFrequency(int pin, int divisor) &#123; byte mode; if(pin == 5 || pin == 6 || pin == 9 || pin == 10) &#123; switch(divisor) &#123; case 1: mode = 0x01; break; case 8: mode = 0x02; break; case 64: mode = 0x03; break; case 256: mode = 0x04; break; case 1024: mode = 0x05; break; default: return; &#125; if(pin == 5 || pin == 6) &#123; TCCR0B = TCCR0B &amp; 0b11111000 | mode; &#125; else &#123; TCCR1B = TCCR1B &amp; 0b11111000 | mode; &#125; &#125; else if(pin == 3 || pin == 11) &#123; switch(divisor) &#123; case 1: mode = 0x01; break; case 8: mode = 0x02; break; case 32: mode = 0x03; break; case 64: mode = 0x04; break; case 128: mode = 0x05; break; case 256: mode = 0x06; break; case 1024: mode = 0x07; break; default: return; &#125; TCCR2B = TCCR2B &amp; 0b11111000 | mode; &#125;&#125; 示波器测量频率为62.5KHZ,改变下面的124,改变占空比，占空比0-255。 analogWrite(6,124); 3.3\tL298N的使用与双路电机驱动 供电方式：-\t7-12V电源走VCC供电，电源上的跳线帽连接，5v的位置不用接电源，该位置可输出一个5v，可用于给单片机供电。-\t当输入电压大于12v时，需要拔掉电源旁的跳线帽，5V端需要接入5v的电压，GND还是接GND-\t接入5V电源， L298N的12V和5V都接5V供电。 注意：GND不但要接驱动电源的GND，一定要从这里再引出一根GND和单片机或者系统的GND相连,使电压有参考电平 控制引脚 IN1 &amp; IN2 电机驱动器A的输入引脚，控制电机A转动及旋转角度 IN1输入高电平HIGH，IN2输入低电平LOW，对应电机A正转 IN1输入低电平LOW，IN2输入高电平HIGH，对应电机A反转 IN1、IN2同时输入高电平HIGH或低电平LOW，对应电机A停止转动 调速就是改变IN1、IN2高电平的占空比（需插上ENA处跳帽） IN3 &amp; IN4 电机驱动器B的输入引脚，控制电机B转动及旋转角度 IN3输入高电平HIGH，IN4输入低电平LOW，对应电机B正转 IN3输入低电平LOW，IN4输入高电平HIGH，对应电机B反转 IN3、IN4同时输入高电平HIGH或低电平LOW，对应电机B停止转动调速就是改变IN3、IN4高电平的占空比（需插上ENB处跳帽） 控制有两种方式，以一边电机为例：1.\tENA,引脚通过跳帽线与+5V连接，IN1悬空或接GND,IN2输入PWM信号。2.\tENA拔掉跳帽线，输入PWM信号，IN1接1，IN2接0。改变IN1与IN2的值就可以停止或正反转。 3.4舵机的驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 12345678910111213141516171819202122232425262728293031323334353637/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 3.5 其他还有无刷电机，步进电机，arduino驱动这些电机设备时，一般不直接驱动，中间都会连接一个驱动模块，上文的L298N就是一种驱动模块。 第四章\t成品制作4.1可以制作哪些？如何制作？个人DIY时，除了学习单片机外，还需要学习PCB焊接和3D打印的一些知识，并且熟悉一些常见的DIY材料，丙烯颜料，环氧树脂等，以及钳子，等常见工具的使用。当然最最最重要的是热爱。基于UNO，我们可以做出很多有意思的作 品，小时钟，个性灯等，在开源社区有很多有意思的作品，可以自行搜索。","tags":["arduino","值得一提的文章"]},{"title":"无聊的盒子-二代","path":"/2024/09/04/无聊的盒子-二代/","content":"前言小的练习项目，熟悉pcb制版和solidwoks技能总体框架 硬件 PCB 3D建模 软件 arduino PCB绘制包括两块板，拓展板和核心板。核心板淘宝买，这里做拓展板实现功能有 充电 供电 引脚引出","tags":["PCB"]},{"title":"室外组二代车上手记录","path":"/2024/08/06/室外组二代车上手记录/","content":"碎碎念8月5号拿到室外组二代新车，人有点麻，一方面比赛日期临近，而且二队还没有车。新车上手后，发现问题很多，首先是密码登不上去，车的所有USB端口都被占满，而且昇腾310的板没有内置wifi,300块的树莓派都有wifi,他没有，而且系统是Ubuntu22(魔改版，单内核)的，只有这个版本的镜像，这导致无法在原生环境跑ros1,赛事方给出的解决方法是在root用户在跑linux容器，容器为ubuntu20,在此跑ros，然后通过与用户ubuntu20的电脑使用ros的主从机和ssh连接实现远程部分可视化操作我的评价是，脑残，傻逼操作，垃圾昇腾上位机板卡没wifi，支持的镜像也少，官网查询板卡资料，还带锁，各种注册，还要序列号申请，垃圾板卡，狗都不用。工控机都比他强碎碎念结束，不管这么说，比赛还是要继续的。 vim常见命令及操作首先，关闭大写锁定，切换为英语小写模式 基础操作 进入文件 vim 文件名，文件不存在会创建文件 按a或i进入编辑模式，此时左下方显示 –INSERT–，o新增加一行，进入编辑模式 输入文本，后按Ese退出编辑模式，输入:,进入命令行模式 q为不保存退出，wq为保存退出 shift+i，在此行最前面加内容，shift+a，在此行最后面就内容 普通模式输入gg，光标回到起头，输入shift+g，光标回到最后 配置 小插曲，突然发现图床用不了了，检查发现系统时间用问题，更新一下就可以了，时间问题是因为双系统切换导致的，具体原因不明 输入 vim –version 打开其中的$HOME&#x2F;.vimrcVim $HOME&#x2F;.vimrc 增加set numbervim显示行号 进阶操作 gg-到第一行 shift + g 最后一行 yy-复制当前行 dd-删除当前行 u-撤销前次操作 .重复前次操作 &#x2F; 搜索 :&#x2F;%s&#x2F;原单词&#x2F;新单词&#x2F;g zip常见操作 zip的安装，打开终端输入下面两行,安装 zip 和 unzip 12sudo apt updatesudo apt install zip unzip 基本创建 12345zip archive_name.zip file1 file2# 这个命令将 file1 和 file2 压缩到一个名为 archive_name.zip 的ZIP文件中zip -r archive_name.zip directory_name# 使用 -r 选项可以递归地将整个目录（包括其子目录和文件）压缩到ZIP文件中。 解压ZIP文件 12345678unzip archive_name.zip# 这个命令将 archive_name.zip 文件中的所有内容解压到当前目录。unzip archive_name.zip -d destination_directory# 使用 -d 选项可以将ZIP文件的内容解压到指定的目录 destination_directory 中。unzip -o archive_name.zip# 使用 -o 选项将覆盖现有的文件。 linux系统操作命令行12345678910111213141516171819202122232425262728293031323334# 过于基本的就略过了mkdir directory_name创建目录rm -r directory_name删除非空目录cp source_file destination_file复制文件或目录mv source_file destination_file移动文件或目录mv old_name new_name重命名文件chmod -R 777 /path/to/directory赋予文件夹下所有文件777权限ps显示当前用户的进程top实时显示系统进程uname -a显示系统信息free -h显示内存使用情况du -sh [目录]显示指定目录的磁盘使用情况 与功能包安装及下载相关12345678910111213141516171819首先检查网路，并且检查时间的准确性ping baidu.comsudo apt-get update更新包列表sudo apt-get install [包名]安装软件包sudo apt-get remove [包名]卸载软件包sudo apt update更新源sudo apt install ros-版本-库名ros相关包安装，版本有noetic,等 ros车设置新车实录 警告1，所有的端口定义与官方给的教程并不相同，而且雷达端口在车辆启动后拔插会导致该端口丢失。所以开机后不要尝试拔插雷达口，所有USB接口已用小标签标注 警告2,由于升腾的板卡没有WiFi模块，所以通过拓展坞插上网口，连接有网的路由器后，还需要拔掉车载路由器与板卡的网线，否则没有网 警告3,小车的ROS相关进程需要在固定IP下才能运行，该固定IP是由车载路由器固定，也就是说在通过网卡联网时，ROS相关程序会报错，找不到IP之类的，秉持有用就不折腾的原则，ROS关于IP的配置文件就不更改了，后来者自行调整。 室外组上手 镜像 前期准备打开车和电脑从机，电脑链接下车wifi 终端链接，密码Mind@123打开VScode，远程链接小车主机 建图将车放在出发区，位置要记住 在终端出运行 python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;map_wj.py 运行前打开底盘，运行后，底盘控制小车建图，建完图后，在键盘控制的终端里按g保存地图 打点建完图后，vscode重开一个终端 python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;run_way_point_click.py 运行后输入1或2回车，打开从机的rviz，挂载rviz.rviz 如何挂载rviz,点击file，点击rencent config,选择rviz.rviz,如果你是第一次打开，点击open config 在rviz（已经放在代码文件下）文件夹中找到rviz.rviz 点击2D Nav Goal开始打点，打完点后，再次点击2D Nav Goal，使点位与最后一个重合，终端窗口显示，保存成功。 如果选择的是1，可以点击PUBlish Point ，点击空白处，显示之前打的点位，点击publish Point,点击要更改的点，点击 红绿灯与斑马线停车点位修改修改start_light_post ，white_go，while_back 开跑将车放在起始点，运行 python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;wj_run.py打开rviz，配置文件选择acml_rviz.rviz在python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;wj_run.py代码下的终端回车，车辆开跑。 速度更改vp_min 跑的不好的话，更改点位，再次跑 代码讲解代码分为3个部分，建图，打点，启动代码程序总结构 建图代码map_wj.py 文件map_wj.py，这个代码是建图文件总得启动代码，主要启动两个roslaunch节点和一个python文件。其中使用subprocess库可以方便在该文件在命令行窗口启动其他窗口，subprocess是非阻塞，打开后和在命令行窗口运行的本程序失去关系，无法通过关闭命令行窗口的方式关闭其打开的其他程序，所以需要使用ps aux | grep ros | xargs -n 1 kill -9 关闭其打开的其他程序，主要是ros程序。在建图方面主要做的工作是将多个命令集成到一个python文件中，方便操作。 123456789101112131415161718192021222324import subprocessimport timeimport os# ps aux | grep ros | xargs -n 1 kill -9# 杀死所有ros相关的终端# stdout=subprocess.DEVNULL 和 stderr=subprocess.DEVNULL 会将标准输出和标准错误重定向到 DEVNULL，这意味着它们不会被打印到终端。# 启动 Run_car.launch，不打印输出subprocess.Popen(&quot;roslaunch racecar Run_car.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;Run_car.launch已执行&quot;)time.sleep(3)# 启动 Run_gmapping.launch，不打印输出subprocess.Popen(&quot;roslaunch racecar Run_gmapping_wy.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;Run_gmapping已执行&quot;)time.sleep(3)# 启动 python 脚本，打印输出，按g保存文件，小写！cmd = &quot;python3 /racecar/src/auto_car/scripts/racecar_teleop.py&quot;os.system(cmd)# subprocess是非阻塞的，os.system(cmd)是阻塞的 Run_gmapping_wy.py Run_gmapping_wy.py这个是gmapping建图的配置文件，可以通过这个文件改变建图的大小，分辨率，雷达有效范围等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;!-- &lt;arg name=&quot;use_rviz&quot; default=&quot;true&quot; /&gt; --&gt; &lt;!-- ODOMETRY --&gt; &lt;!--rf2o_Laser_Odometry--&gt; &lt;include file=&quot;$(find racecar)/launch/includes/rf2o.launch.xml&quot; /&gt; &lt;!-- wheel odometry --&gt; &lt;include file=&quot;$(find encoder_driver)/launch/wheel_odom.launch&quot;/&gt; &lt;!-- Robot_Localization --&gt; &lt;node pkg=&quot;robot_localization&quot; type=&quot;ekf_localization_node&quot; name=&quot;ekf_se&quot; clear_params=&quot;true&quot;&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find racecar)/param/ekf_params.yaml&quot; /&gt; &lt;/node&gt; &lt;!-- gmapping --&gt; &lt;node pkg=&quot;gmapping&quot; type=&quot;slam_gmapping&quot; name=&quot;slam_gmapping&quot; output=&quot;screen&quot;&gt; &lt;remap from=&quot;scan&quot; to=&quot;scan&quot;/&gt; &lt;param name=&quot;map_update_interval&quot; value=&quot;2&quot;/&gt; &lt;param name=&quot;maxUrange&quot; value=&quot;4&quot;/&gt; &lt;param name=&quot;sigma&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;kernelSize&quot; value=&quot;1&quot;/&gt; &lt;param name=&quot;lstep&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;astep&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;iterations&quot; value=&quot;5&quot;/&gt; &lt;param name=&quot;lsigma&quot; value=&quot;0.075&quot;/&gt; &lt;param name=&quot;ogain&quot; value=&quot;3.0&quot;/&gt; &lt;param name=&quot;lskip&quot; value=&quot;0&quot;/&gt; &lt;param name=&quot;srr&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;srt&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;str&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;stt&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;linearUpdate&quot; value=&quot;0.10&quot;/&gt; &lt;param name=&quot;angularUpdate&quot; value=&quot;0.25&quot;/&gt; &lt;param name=&quot;temporalUpdate&quot; value=&quot;1.0&quot;/&gt; &lt;param name=&quot;resampleThreshold&quot; value=&quot;0.25&quot;/&gt; &lt;param name=&quot;particles&quot; value=&quot;30&quot;/&gt; &lt;param name=&quot;xmin&quot; value=&quot;-50.0&quot;/&gt; &lt;param name=&quot;ymin&quot; value=&quot;-50.0&quot;/&gt; &lt;param name=&quot;xmax&quot; value=&quot;50.0&quot;/&gt; &lt;param name=&quot;ymax&quot; value=&quot;50.0&quot;/&gt; &lt;param name=&quot;delta&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;llsamplerange&quot; value=&quot;0.01&quot;/&gt; &lt;param name=&quot;llsamplestep&quot; value=&quot;0.01&quot;/&gt; &lt;param name=&quot;lasamplerange&quot; value=&quot;0.005&quot;/&gt; &lt;param name=&quot;lasamplestep&quot; value=&quot;0.005&quot;/&gt; &lt;param name=&quot;odom_frame&quot; value=&quot;odom&quot;/&gt; &lt;param name=&quot;base_frame&quot; value=&quot;base_footprint&quot;/&gt; &lt;/node&gt; &lt;!-- Rviz --&gt; &lt;!-- &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find racecar)/rviz/gmapping.rviz&quot; if=&quot;$(arg use_rviz)&quot;/&gt; --&gt;&lt;/launch&gt; Run_car.launch这个代码是底盘控制代码，开启这个代码能够开启上位机ros对下位机发送速度指令,下车速度话题名为car&#x2F;cmd_vel，其他话题运行该launch文件后，使用rostopic list 查看 racecar_teleop.py这是一个键盘控制小车移动的代码，具体操作键见具体代码在官方代码里补充了一个按g，保存地图到指定位置的代码行 1234elif key == &#x27;g&#x27; : cmd = &quot;rosrun map_server map_saver -f /racecar/src/auto_car/rengong&quot; os.system(cmd) break 打点 run_way_point_click.py，该程序实现的功能是通过订阅rviz发布的点位将其储存到配置文件中，启动实跑时，将点位发布出去，实现导航 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import osimport rospyfrom geometry_msgs.msg import PointStamped, PoseStampedfrom nav_msgs.msg import Pathfrom scipy.interpolate import splprep, splevimport numpy as npimport jsonfrom visualization_msgs.msg import Marker, MarkerArrayimport timeimport subprocessprint(&quot;是否加载历史json文件: 1.是 2.否，丢弃旧数据 请输入数字1或2：&quot;)data = []clicked_point = -1number = input()if number == &quot;1&quot;: with open(&#x27;/racecar/src/auto_car/scripts/waypoint.json&#x27;,&quot;r&quot;) as f: data = json.load(f)[&quot;waypoint&quot;] f.close()# os.system(f&quot;gnome-terminal -e &#x27;bash -c \\&quot;roslaunch /home/racecar/car_2024_rengong/src/auto_go/launch/path_click.launch; exec bash\\&quot;&#x27;&quot;)subprocess.Popen(&quot;roslaunch /racecar/src/auto_car/launch/path_click.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)rospy.sleep(3)rospy.init_node(&#x27;way_point_click&#x27;, anonymous=True)# 在rviz里显示箭头def show_arrow(): global clicked_point,data marker_array = MarkerArray() for i,d in enumerate(data): marker = Marker() marker.header.frame_id = &quot;map&quot; marker.type = marker.ARROW marker.action = marker.ADD marker.ns = &quot;marker&quot; marker.scale.x = 0.5 marker.scale.y = 0.1 marker.scale.z = 0.1 marker.color.a = 1.0 marker.color.r = 0.0 marker.color.g = 1.0 marker.color.b = 0.0 if i==clicked_point: marker.color.r = 1.0 marker.color.g = 0.0 marker.color.b = 0.0 marker.pose.position.x = d[0] marker.pose.position.y = d[1] marker.pose.position.z = 0.0 marker.pose.orientation.w = d[2] marker.pose.orientation.x = d[3] marker.pose.orientation.y = d[4] marker.pose.orientation.z = d[5] marker_array.markers.append(marker) id = 0 for m in marker_array.markers: m.id = id id += 1 marker_pub.publish(marker_array)def click_goal_callback(msg): global data, clicked_point if clicked_point==-1: if len(data)&gt;0 and (msg.pose.position.x-data[-1][0])**2 + (msg.pose.position.y-data[-1][1])**2 &lt; 0.1: # 保存数据 with open(&#x27;/racecar/src/auto_car/scripts/waypoint.json&#x27;,&quot;w&quot;) as f: json.dump(&#123;&quot;waypoint&quot;:data&#125;,f) f.close() print(&quot;保存成功&quot;) return data.append([msg.pose.position.x,msg.pose.position.y,msg.pose.orientation.w,msg.pose.orientation.x,msg.pose.orientation.y,msg.pose.orientation.z]) else: data[clicked_point][0] = msg.pose.position.x data[clicked_point][1] = msg.pose.position.y data[clicked_point][2] = msg.pose.orientation.w data[clicked_point][3] = msg.pose.orientation.x data[clicked_point][4] = msg.pose.orientation.y data[clicked_point][5] = msg.pose.orientation.z clicked_point = -1 show_arrow()def clicked_callback(msg): # 寻找最近的点 global data, clicked_point x = msg.point.x y = msg.point.y if len(data) == 0: return min_dis = 100000 min_index = 0 for i in range(len(data)): dis = (x-data[i][0])**2 + (y-data[i][1])**2 if dis &lt; min_dis: min_dis = dis min_index = i if min_dis&lt;0.1: clicked_point = min_index else: clicked_point = -1 show_arrow() marker_pub = rospy.Publisher(&quot;/my_marker&quot;, MarkerArray, queue_size=5)rospy.Subscriber(&quot;/move_base_simple/goal&quot;, PoseStamped, click_goal_callback)rospy.Subscriber(&quot;clicked_point&quot;, PointStamped, clicked_callback)show_arrow()# 订阅move_base_sarospy.spin() 启动wj_run.py 启动脚本，集成了底盘launch文件，导航launch文件，控制主程序wj_go_hh.py 1234567891011121314import subprocessimport timeimport ossubprocess.Popen(&quot;roslaunch racecar Run_car.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;Run_car.launch已执行&quot;)time.sleep(3)subprocess.Popen(&quot;roslaunch racecar amcl_nav_wy.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;amcl_nav_wy.launch已执行&quot;)time.sleep(2)# 启动 python 脚本cmd = &quot;python3 /racecar/src/auto_car/scripts/wj_go_hh.py&quot;os.system(cmd) amcl_nav_wy.launch Run_car.launch文件上面已经介绍过了，这里就不介绍了，acml_nav_wy.launch文件是导航控制文件该文件同级目录下还有一个文件acml_nav.launch，是官方原文件，这里对他进行了修改，主要在move_base进行修改，由于实际上局部路径规划并没有用到，这里就将其注释掉了，其中，该文件，调用了acml，controller也会介绍param name&#x3D;”base_global_planner” value&#x3D;”navfn&#x2F;NavfnROS”&#x2F;该文件中使用的全局路径规划器为NavfnROS,而不是GlobalPlanner，由于时间较短没有测试两者区别。这里的controller控制器代替了局部路径规划器的功能。这里介绍一下导航控制代码的总体思路。wj_run.py脚本会启动底盘节点，导航节点，wj_go_hh.py文件。wj_go_hh.py会读取之前打点的参数文件，按先后顺序发布，导航节点会调用全局路径规划器，计算出此时位置倒目标点的路径，由node pkg&#x3D;”racecar” type&#x3D;”car_controller_new” respawn&#x3D;”false” name&#x3D;”car_controller” output&#x3D;”screen运行的car_controller_new.cpp文件负责发布car&#x2F;cmd_vel速度与舵机话题控制下位机实现底盘运动。这个代码后面会介绍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;arg name=&quot;use_rviz&quot; default=&quot;flase&quot; /&gt; &lt;!-- for amcl --&gt; &lt;arg name=&quot;init_x&quot; default=&quot;0.0&quot; /&gt; &lt;arg name=&quot;init_y&quot; default=&quot;0.0&quot; /&gt; &lt;arg name=&quot;init_a&quot; default=&quot;0.0&quot; /&gt; &lt;!-- Map server --&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;map_to_odom&quot; args=&quot;0.0 0.0 0.0 0 0 0.0 /map /odom 1000&quot;/&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser&quot; args=&quot;0.0 0.0 0.0 0 0 0.0 /base_link /laser 1000&quot;/&gt; &lt;node name=&quot;map_server&quot; pkg=&quot;map_server&quot; type=&quot;map_server&quot; args=&quot;$(find auto_car)/rengong.yaml&quot;/&gt; &lt;!-- ODOMETRY --&gt; &lt;!--rf2o_Laser_Odometry--&gt; &lt;include file=&quot;$(find racecar)/launch/includes/rf2o.launch.xml&quot; /&gt; &lt;!-- wheel odometry --&gt; &lt;include file=&quot;$(find encoder_driver)/launch/wheel_odom.launch&quot;/&gt; &lt;!-- Robot_Localization --&gt; &lt;node pkg=&quot;robot_localization&quot; type=&quot;ekf_localization_node&quot; name=&quot;ekf_se&quot; clear_params=&quot;true&quot;&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find racecar)/param/ekf_params.yaml&quot; /&gt; &lt;/node&gt; &lt;!-- Localization --&gt; &lt;!-- AMCL --&gt; &lt;include file=&quot;$(find racecar)/launch/includes/amcl.launch.xml&quot;&gt; &lt;arg name=&quot;init_x&quot; value=&quot;$(arg init_x)&quot;/&gt; &lt;arg name=&quot;init_y&quot; value=&quot;$(arg init_y)&quot;/&gt; &lt;arg name=&quot;init_a&quot; value=&quot;$(arg init_a)&quot;/&gt; &lt;/include&gt; &lt;!-- Navstack --&gt; &lt;node pkg=&quot;move_base&quot; type=&quot;move_base&quot; respawn=&quot;false&quot; name=&quot;move_base&quot;&gt; &lt;!-- local planner --&gt; &lt;!-- &lt;param name=&quot;base_global_planner&quot; value=&quot;global_planner/GlobalPlanner&quot;/&gt; --&gt; &lt;param name=&quot;base_global_planner&quot; value=&quot;navfn/NavfnROS&quot;/&gt; &lt;!--param name=&quot;base_local_planner&quot; value=&quot;dwa_local_planner/DWAPlannerROS&quot;/--&gt; &lt;!--rosparam file=&quot;$(find racecar)/param/dwa_local_planner_params.yaml&quot; command=&quot;load&quot;/--&gt; &lt;!-- costmap layers --&gt; &lt;!-- rosparam file=&quot;$(find racecar)/param/local_costmap_params.yaml&quot; command=&quot;load&quot;/--&gt; &lt;rosparam file=&quot;$(find racecar)/param/global_costmap_params.yaml&quot; command=&quot;load&quot;/&gt; &lt;!-- move_base params --&gt; &lt;rosparam file=&quot;$(find racecar)/param/base_global_planner_params.yaml&quot; command=&quot;load&quot;/&gt; &lt;rosparam file=&quot;$(find racecar)/param/move_base_params.yaml&quot; command=&quot;load&quot;/&gt; &lt;remap from=&quot;/odom&quot; to=&quot;/odometry/filtered&quot;/&gt; &lt;/node&gt; &lt;node pkg=&quot;racecar&quot; type=&quot;car_controller_new&quot; respawn=&quot;false&quot; name=&quot;car_controller&quot; output=&quot;screen&quot;&gt; &lt;param name=&quot;Vcmd&quot; value=&quot;2.0&quot; /&gt; &lt;!--speed of car m/s --&gt; &lt;!-- ESC --&gt; &lt;param name=&quot;baseSpeed&quot; value=&quot;60&quot;/&gt; &lt;param name=&quot;baseAngle&quot; value=&quot;0.0&quot;/&gt; &lt;param name=&quot;Angle_gain_p&quot; value=&quot;-5.0&quot;/&gt; &lt;param name=&quot;Angle_gain_d&quot; value=&quot;-0.0&quot;/&gt; &lt;param name=&quot;Lfw&quot; value=&quot;1.5&quot;/&gt; &lt;param name=&quot;vp_max_base&quot; value=&quot;80&quot;/&gt; &lt;param name=&quot;vp_min&quot; value=&quot;50&quot;/&gt; &lt;/node&gt; &lt;!-- Rviz --&gt; &lt;!-- &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=:&quot;rviz&quot; args=&quot;-d $(find racecar)/rviz/amcl.rviz&quot; if=&quot;$(arg use_rviz)&quot; /&gt; --&gt;&lt;/launch&gt; amcl.launch.xml src\\racecar\\launch\\includes\\amcl.launch.xml该文件是acml配置文件其中param name&#x3D;”tf_broadcast” value&#x3D;”false”&#x2F;该参数表示是否将计算的位姿发布到全局，这里我选择了false,由于之前的一代车雷达位姿计算不准，导致位姿乱跳，二代车位姿尚可，但未测试。在位姿计算准确的情况下，可以防止车辆跑的过程中雷达扫到的图和与建的图不重合，有较大偏差。其他参数chat搜索。自行添加注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;arg name=&quot;init_x&quot; default=&quot;0&quot; /&gt; &lt;arg name=&quot;init_y&quot; default=&quot;0&quot; /&gt; &lt;arg name=&quot;init_a&quot; default=&quot;0&quot; /&gt; &lt;node pkg=&quot;amcl&quot; type=&quot;amcl&quot; name=&quot;amcl&quot; output=&quot;screen&quot;&gt; &lt;!-- Publish scans from best pose at a max of 10 Hz --&gt; &lt;param name=&quot;transform_tolerance&quot; value=&quot;1.0&quot; /&gt; &lt;param name=&quot;gui_publish_rate&quot; value=&quot;10.0&quot;/&gt; &lt;param name=&quot;laser_max_beams&quot; value=&quot;10&quot;/&gt; &lt;param name=&quot;min_particles&quot; value=&quot;100&quot;/&gt; &lt;param name=&quot;max_particles&quot; value=&quot;5000&quot;/&gt; &lt;param name=&quot;kld_err&quot; value=&quot;0.01&quot;/&gt; &lt;param name=&quot;kld_z&quot; value=&quot;0.99&quot;/&gt; &lt;!-- translation std dev, m --&gt; &lt;param name=&quot;odom_alpha1&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha2&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha3&quot; value=&quot;0.8&quot;/&gt; &lt;param name=&quot;odom_alpha4&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;laser_z_hit&quot; value=&quot;0.5&quot;/&gt; &lt;param name=&quot;laser_z_short&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_max&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_rand&quot; value=&quot;0.5&quot;/&gt; &lt;param name=&quot;laser_sigma_hit&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;laser_lambda_short&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;laser_model_type&quot; value=&quot;likelihood_field&quot;/&gt; &lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt; &lt;param name=&quot;laser_likelihood_max_dist&quot; value=&quot;4.0&quot;/&gt; &lt;param name=&quot;update_min_d&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;update_min_a&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;resample_interval&quot; value=&quot;2&quot;/&gt; &lt;!--//在重采样前需要的滤波更新的次数,默认2--&gt; &lt;param name=&quot;transform_tolerance&quot; value=&quot;0.2&quot;/&gt; &lt;!--tf变换发布推迟的时间--&gt; &lt;param name=&quot;recovery_alpha_slow&quot; value=&quot;0.0&quot;/&gt; &lt;!-- 慢速速的平均权重滤波的指数衰减频率，用作决定什么时候通过增加随机位姿来recover，默认0（disable）--&gt; &lt;param name=&quot;recovery_alpha_fast&quot; value=&quot;0.0&quot;/&gt; &lt;!-- 快速的平均权重滤波的指数衰减频率，用作决定什么时候通过增加随机位姿来recover，默认0（disable），可能0.001是一个不错的值--&gt; &lt;param name=&quot;use_map_topic&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;first_map_only&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;tf_broadcast&quot; value=&quot;false&quot;/&gt; &lt;param name=&quot;odom_frame_id&quot; value=&quot;odom&quot;/&gt; &lt;param name=&quot;global_frame_id&quot; value=&quot;map&quot;/&gt; &lt;param name=&quot;base_frame_id&quot; value=&quot;base_footprint&quot;/&gt; &lt;param name=&quot;odom_model_type&quot; value=&quot;diff&quot;/&gt; &lt;param name=&quot;initial_pose_x&quot; value=&quot;$(arg init_x)&quot;/&gt; &lt;param name=&quot;initial_pose_y&quot; value=&quot;$(arg init_y)&quot;/&gt; &lt;param name=&quot;initial_pose_a&quot; value=&quot;$(arg init_a)&quot;/&gt; &lt;param name=&quot;initial_cov_xx&quot; value=&quot;0.25&quot; /&gt; &lt;param name=&quot;initial_cov_yy&quot; value=&quot;0.25&quot; /&gt; &lt;param name=&quot;initial_cov_aa&quot; value=&quot;0.2&quot; /&gt; &lt;/node&gt;&lt;/launch&gt; amcl.launch.xml src\\racecar\\src\\car_controller_new.cpp代码很长，这里就不放了，自行下载源代码查看。这个代码很重要，我将其中的舵机限幅改大了，并注释掉了到达目标点后，发布速度为0，舵机打角为0的部分，实际上发布的节点是car&#x2F;cmd_vel,舵机打角0度，向右偏到最大，90才是正中，修复到达目标点后计算并突然左打角的BUG. wj_go_hh.py src\\auto_car\\scripts\\wj_go_hh.py控制主程序思路读取打点的配置文件，发布目标点，检测自身位置，当目标点与自身位姿小于参数Distance_min（单位m）时,发布下一个目标点停车思路，这里并没有实际检测红绿灯和斑马线，而是采用定点的方式，首先将参数start_light_post ，white_go ，while_back 写入，横纵坐标，写入后程序会检测打点配置文件中哪些目标点与这些停车点距离最近，在发布到这个目标点时，先停车一段时间后，在出发，停车采用发布&#x2F;light话题，car_controller_new节点接受到后就会停车。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254import rospyfrom geometry_msgs.msg import Twistfrom geometry_msgs.msg import PoseWithCovarianceStampedimport mathimport numpy as npfrom wj_pid import PIDimport jsonimport timefrom nav_msgs.msg import Odometryfrom std_msgs.msg import String, Float64from move_base_msgs.msg import MoveBaseActionResultfrom actionlib_msgs.msg import GoalStatusArrayfrom geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped# 参数配置，# 角度从车右方逆时针旋转Angle_min = 50.0 #右拐最大角Angle_max = 130.0 #左拐最大角Angle_mid = 90.0 #中间值Speed_max = 1700My_Speed = 1630now_Goal=[0,0,0,1]Distance_min = 1.0is_start_light = 1 #是否开启红绿灯定点？light_index = 0 light_flag = 0is_white = 1 #是开启斑马线定点？white_go_index = 0while_back_index = 0white_flag = 0is_rest = 0 #开启定点纠偏rest_index = 0rest_post = [6.18,-1.40]rest_flag = 0# 参数修改start_light_post = [[8.39,-0.1],[10.8,-0.4],[12.6,-0.2],[7.25,-1.87],[10,-2],[12.3,-1.9]]white_go = [3.0, -0.5]while_back = [3.5,-1.1]def find_closest_point(start_light_post, post): &#x27;&#x27;&#x27; my_list格式为[[a,b],[c,d],[e,f]...] my_post格式为[a,b] 该函数会返回my_list距离my_post最近的坐标的下标 &#x27;&#x27;&#x27; # 提取每个点的 x 和 y 坐标 points = np.array(start_light_post)[:, :2] # 计算每个点与post的距离 distances = np.sqrt((points[:, 0] - post[0])**2 + (points[:, 1] - post[1])**2) # 返回距离最小的点的下标 return np.argmin(distances)def send_goal(to_Goal, map_frame): goal_msg = PoseStamped() goal_msg.header.stamp = rospy.Time.now() goal_msg.header.frame_id = &#x27;map&#x27; # 坐标系应与目标点一致，通常是地图坐标系 goal_msg.pose.position.x = to_Goal[0] # 替换为目标点的 x 坐标 goal_msg.pose.position.y = to_Goal[1] # 替换为目标点的 y 坐标 goal_msg.pose.position.z = 0.0 # 替换为目标点的 z 坐标 # 设置目标点的姿态，通常不需要设置 goal_msg.pose.orientation.x = 0.0 goal_msg.pose.orientation.y = 0.0 goal_msg.pose.orientation.z = to_Goal[3] goal_msg.pose.orientation.w = to_Goal[2] # 发布目标点 goal_publisher.publish(goal_msg) rospy.loginfo(&quot;Goal sent!&quot;) class go_to: def __init__(self): self.pose_amcl = rospy.Subscriber(&#x27;/odometry/filtered&#x27;,Odometry,self.amcl_pose_callback,queue_size=1) # self.pose_amcl = rospy.Subscriber(&quot;/amcl_pose&quot;, PoseWithCovarianceStamped, self.amcl_pose_callback, queue_size=10) self.now_position = [0,0,0,1] def amcl_pose_callback(self, data): position = data.pose.pose.position orientation = data.pose.pose.orientation self.now_position = [round(position.x, 3), round(position.y, 3), round(orientation.z, 3), round(orientation.w, 3)] class controll: def __init__(self,Angle_min,Angle_max,Angle_mid,Speed_max,My_Speed): self.pub_speed = rospy.Publisher(&#x27;/car/cmd_vel&#x27;, Twist, queue_size=1) self.Angle_min=Angle_min self.Angle_max=Angle_max self.Angle_mid=Angle_mid self.Speed_max=Speed_max self.My_Speed=My_Speed self.pid = PID(Kp=1.2, Ki=0, Kd=0, setpoint=0) self.pub_stop = rospy.Publisher(&#x27;/light&#x27;, String, queue_size=1) def go_goal(self,To_Goal,Now_Goal): &#x27;&#x27;&#x27; To_Goal表示目标点，为一个列表，内有4个数据，依次为，位置x,位置y,方向z,方向w Now_Goal表示当前位置 &#x27;&#x27;&#x27; vector_point=[To_Goal[0]-Now_Goal[0],To_Goal[1]-Now_Goal[1],0] print(&quot;vector_point&quot;+str(vector_point)) ang = quaternion_to_euler(Now_Goal[2], Now_Goal[3]) print(&quot;ang&quot;+str(ang)) ang = ang*math.pi/180 print(&quot;ang&quot;+str(ang)) vector_angle = [round(math.cos(ang), 3),round(math.sin(ang), 3),0] print(&quot;vector_angle&quot;+str(vector_angle)) final_ang = angle_between_vectors(vector_angle, vector_point) return final_ang def angle_control(self,angle_1): angle_2 = self.Angle_mid + self.pid.update(angle_1) print(&quot;angle_2&quot;, angle_2) # 舵机限幅 if angle_2 &lt; self.Angle_min: return self.Angle_min elif angle_2 &gt; self.Angle_max: return self.Angle_max else: return angle_2 def publish_velocity(self, linear_x, angular_z): twist = Twist() twist.linear.x = linear_x twist.linear.y = 0 twist.linear.z = 0 twist.angular.z = angular_z twist.angular.x = 0 twist.angular.y = 0 self.pub_speed.publish(twist)def work1(): rospy.spin() # print(&quot;to_Goal&quot;,to_Goal) # print(&quot;now_Goal&quot;,go_to_obj.now_position) if __name__ == &quot;__main__&quot;: with open(&#x27;/racecar/src/auto_car/scripts/waypoint.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f) f.close() index_point=0 waypoint = data[&quot;waypoint&quot;] print(waypoint) point_len = len(waypoint) print(&quot;go?&quot;) www = 5 aaa=input() start_time = time.time() if is_start_light == 1: # 开启定点 light_index = find_closest_point(waypoint, start_light_post[int(www)]) print(&quot;最经点的下标为：&quot; + str(light_index)) white_go_index = find_closest_point(waypoint,white_go) while_back_index = find_closest_point(waypoint,while_back) rest_index = find_closest_point(waypoint,rest_post) rospy.init_node(&quot;wj_go&quot;, anonymous=True) go_to_obj = go_to() control = controll(Angle_min,Angle_max,Angle_mid,Speed_max,My_Speed) goal_publisher = rospy.Publisher(&#x27;/move_base_simple/goal&#x27;, PoseStamped, queue_size=10) map_frame = rospy.get_param(&#x27;~map_frame&#x27;, &#x27;map&#x27; ) time.sleep(1) # t1 = Thread(target=work1) # t1.start() to_Goal = [waypoint[index_point][0],waypoint[index_point][1],waypoint[index_point][2],waypoint[index_point][5]] send_goal(to_Goal,map_frame) while True: now_Goal = go_to_obj.now_position distance = np.sqrt((to_Goal[0]-now_Goal[0])**2+(to_Goal[1]-now_Goal[1])**2) if (distance &lt;= Distance_min and index_point &lt;= point_len-1): if index_point == point_len -1 : pass print(&quot;over&quot;) finish_time = time.time() print(finish_time-start_time) while True: control.publish_velocity(1200,90) index_point = index_point + 1 if index_point == rest_index and is_rest == 1 and rest_flag == 0: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) rest_flag = 1 if index_point == light_index and is_start_light==1 and light_flag == 0: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) light_flag = 1 if index_point == white_go_index and is_white ==1 and white_flag == 0: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) white_flag = 1 if index_point == while_back_index and is_white ==1 and white_flag == 1: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) white_flag = 2 to_Goal = [waypoint[index_point][0],waypoint[index_point][1],waypoint[index_point][2],waypoint[index_point][5]] send_goal(to_Goal,map_frame) 改进代码介绍完毕，下面介绍一下改进的思路。 由于主程序是一个一个点发布的，每次导航只是专注于此时的目标点，导致路径不平滑，有时由于拐的太大，在下一个目标点，无法回正到正确的轨迹，可尝试对打点的参数文件做平滑处理 controller_new.cpp文件中还有bug没修改，并且这个控制器不好用，可以自己写一个 可以关闭controller，启用局部路径规划，衔接局部路径规划和底盘的代码 赛后结果及其感悟三个队，国一，国二，国三，结果还行，没崩。","tags":["ros","竞赛","值得一提的文章"]},{"title":"批量文件重命名脚本","path":"/2024/08/05/批量文件重命名脚本/","content":"实现重命名特定后缀文件，批量增加特定前缀 123456789101112131415161718192021222324252627282930import osdef batch_rename(folder_path, file_extension, prefix): # 检查文件夹是否存在 if not os.path.exists(folder_path): print(f&quot;文件夹 &#123;folder_path&#125; 不存在&quot;) return # 获取文件夹中的所有文件 files = os.listdir(folder_path) for filename in files: # 检查文件的后缀是否匹配 if filename.endswith(file_extension): # 构造新的文件名 new_name = prefix + filename # 获取旧文件的完整路径 old_file = os.path.join(folder_path, filename) # 获取新文件的完整路径 new_file = os.path.join(folder_path, new_name) # 重命名文件 os.rename(old_file, new_file) print(f&quot;已将 &#123;old_file&#125; 重命名为 &#123;new_file&#125;&quot;)# 示例调用folder_path = &#x27;/path/to/your/folder&#x27;file_extension = &#x27;.txt&#x27;prefix = &#x27;prefix_&#x27;batch_rename(folder_path, file_extension, prefix)","tags":["脚本"]},{"title":"verilog_base_study","path":"/2024/08/05/verilog-base-study/","content":"verilog 模块结构 verilog基本框架 实例、 进行实例化对象，以二选一选择器和D触发器为例，涉及到always和assign 模块说明部分 模块说明部分的涉及及其注意事项 assign语句 进入assign语句，注意事项，必须&#x3D;,且wire类型 assign操作 基本运算符号及其类型 always语句 always表示总是如此，@表示等待，赋值目标必须为reg类型目标条件有两种，边沿触发和电平触发 assign与always的区别 begib end 的使用 相当于括号，always如果有多条赋值语句，必须用begin end 将其包裹 阻塞赋值与非阻塞赋值 时序电路常使用非阻塞&lt;&#x3D;赋值 举例 底层模块 例化时采用.x(x)形式进行例化，即命名法格式 门原语调用 基本用不到 verilog数据类型 wire reg input，inout信号必须为net形，output随意 数字表示格式 if语句 case语句 case endcase 语言描述风格 下面这种用的最多 其他规则","tags":["verilog"]},{"title":"电力电子技术","path":"/2024/08/03/电力电子技术/","content":"电力电子技术概念信息电子技术与电力电子技术 两大分支 电力电子器件的制造技术 变流技术 电力变化的四大类 电力电子技术与信息电子的区分 电力电子技术与自动化 电力电子技术的发展史 1957年美国通用电气公司研制了世界上第一个晶闸管，标志着电力电子技术的诞生 电力电子技术的应用 习题 直流电DC,Direct Current;交流电AC,Alternating Current 总结 电力电子器件概述基本概念 特征★ 电力电子器件的损耗 电力电子器件的系统组成 电力电子器件的分类 不可通过控制电路控制电力电子器件的开通的是不可控器件，可以通过控制电路控制电力电子器件的开通，但不可通过控制电路控制电力电子器件的关断的是半控型器件，即可开通又可关断的是全控型器件。 习题 A不是最重要的，D,需要散热器，但不讲究散热设计，当然，个人更倾向与ABCD全选 总结 不可控器件-电力二极管基本结构 电力二极管具有电导调制效应，电流小时，阻值大，电流大时阻值小 工作原理 先发生电击穿，后发生热击穿 基本特性 主要参数 有点没懂，得重学，这个参数最重要 种类 恢复时间越来越短 习题 总结 半控型器件-晶闸管★ 前面还有些内容要补上 晶闸管正常工作特性总结 晶闸管导通时，看作导线 基本特性 主要参数 维持电流是从通态到断态，擎住电流是从断态到通态 派生器件 习题 总结 晶闸管是电力电子器件最重要的器件 全控型器件-GTO(门级可关断晶闸管)是晶闸管的派生器件 结构 基本工作原理 GTO与普通晶闸管的区别★ GTO的动态特性 前面的得复习了，没太懂 主要参数 给GTO通的电流不能超过最大可关断阳极电流，否则无法关闭。电流关断增益小是其主要的缺点 习题 总结 全控型器件-GTR(电力晶体管) 采用达林顿接法的意义，有效增大电流增益 基本特性 主要参数 具有二次击穿 习题 总结 全控型器件-MOS(电力场效应晶体管)特点 结构与原理 基本特性 正温度系数，温度升高，阻值升高 该元件，静态特性重要于动态特性 习题 全控型器件-IGBT(绝缘栅双极晶体管) 基本特性 主要参数 习题 总结 整流电路 本章重学吧，没听懂 单相可控整流电路 单相半波可控整流电路 单相桥式整流电路 三相可控整流电路 三相半波可控整流电路 三相桥式整流电路 单相半波可控整流电路电阻负载 晶闸管的导通条件变压器的作用$u_{d}$与$i_{d}$是输出电压与输出电流,R为输出负载 移项范围和平均值的计算重要触发延迟角，导通角a的移相范围即为正相导通角的范围 带阻感负载 直流磁化现象，是由双向不对称或只单相导致的触发延迟角，导通角续流二极管的作用是抑制$u_{d}&#x3D;0$,此时假设L很大 练习 单相桥式整流电路 $i_{2}$是对称分布，不会发生直流磁化现象 注意有效值与平均值的写法 带阻感负载 每一行晶闸管的导通角都是180度，与控制角无关 带反电动势时的工作情况 习题 三相半波整流电路 控制角的起点 此时a为0度 a等于30度 出现断续现象 最大反相电压与最大正相电压 阻感负载 直流磁化，单相半波和三相半波 习题 三相桥式全控整流电路 自然换相点 什么是宽脉冲，什么是双脉冲 a为0度的波形图 a为30度 a为60度 a为90度 阻感负载 a为0度 a为30度 a为90度 习题 变压器漏感对整流电路的影响 卡住了，得练习 换流方式 基本原理 换流方式 习题 总结 电压型逆变电路 三大特点 单相电压型逆变电路单相半桥逆变电路 单相全桥逆变电路 全桥逆变电路有两种调压方式，1，改变$U_{d}$，2，移相调压 三相电压型逆变电路 三相电压型逆变电路的特点 练习 电流型逆变电路 主要特点 单相电流型逆变电路 三相电流型逆变电路 PWM控制技术 理论基础，面积等效原理 三相电压型PWM逆变器 练习 总结 软开关技术","tags":["课程"]},{"title":"无聊的盒子制作","path":"/2024/06/23/无聊的盒子制作/","content":"前言一开始想把这个当成一个开源项目来做，然后发现想要超越网上现有的开源项目，还是需要费一番功夫，至少不是花一两天就能完成的。目前的项目其实还不是很完善，甚至部分打印件需要用小刀进行修正，遂本次制作仅自娱自乐，作为自己的练习项目。文件仓库如下 https://github.com/liwuyou/box.git arduino代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 无聊的盒子//使用mg90s舵机#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象int close_pos = 110; // 该变量用与存储舵机能够关闭钮子开关的角度int home_pos = 20; // 回正角度int pin_on = 2;void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制 myservo.write(home_pos); pinMode(pin_on,INPUT_PULLUP); randomSeed(analogRead(0));//随机数种子&#125; void case_1()&#123; // 快进快出 myservo.write(close_pos); delay(300); myservo.write(home_pos); delay(300); &#125;void case_2()&#123; //中速 delay(500); myservo.write(close_pos); delay(500); myservo.write(home_pos); delay(1000); &#125;void case_3()&#123; //低速 delay(500); myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(1000); &#125;void case_4()&#123; //疲惫 int pos; for(pos = home_pos; pos&lt;=close_pos-20; pos+=1) &#123; myservo.write(pos); delay(30); &#125; myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(500);&#125;void case_5()&#123; //生气 int pos; for(pos = home_pos; pos&lt;=close_pos-20; pos+=1) &#123; myservo.write(pos); delay(10); &#125; for(pos = close_pos-20; pos&gt;=home_pos+30; pos-=1) &#123; myservo.write(pos); delay(10); &#125; myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(500);&#125;void loop() &#123; int randNumber = random(5); if(digitalRead(2)==0)&#123; switch(randNumber)&#123; case 0:case_1();break; case 1:case_2();break; case 2:case_3();break; case 3:case_4();break; case 4:case_5();break; &#125; &#125;&#125;","tags":["arduino"]},{"title":"台式电脑组装DIY指南","path":"/2024/05/23/台式电脑组装DIY指南/","content":"前言该篇主要针对台式电脑一些基础知识的扫盲工作。 电脑基础硬件 快速链接CPU天梯图 https://topic.expreview.com/CPU/ 显卡天梯图 https://topic.expreview.com/GPU/ 其他1、内存条套条牌子不一样没事，蓝条，绿条，黑条也没事。但是频率要一样，不一样只能按照低的那个走2、io挡版上，如果你有核显接主板，有独显也尽量接主板，没有核显再接独显3、笔记本和台式机命名稍微有点不一样，比如intel中U是低压，H是高压但是不超频3、显卡前面数字是代数，后面是叠马甲，比如1080就比1650强点（玄学警告04、PCI-e这玩意功能很多，各种网卡、蓝牙等都能差，但是这种东西插的时候插低档次的条，高档次还是留给显卡比较好，PCI-e4虽然很牛逼，但是受到选择不一样结果相趋甚远5、SATA接口并不是区分也有固态，m.2就只有固态了。m.2由于电子原理上导致运行效率高，但是固态硬盘数据丢了几乎恢复不了。机械硬盘的电磁强弱，比较好恢复数据（多备份才是王道）6、SATA不能单独供电。m.2虽然固态硬盘虽然大部分都是这个接口，但是长短有不一样的，也是型号区别，记得甄别7、CPU三级缓存是虚的，你猜它为什么不说1、2级缓存，1、2级大家做的都一样。3级有区别但是意义不大8、内存确实是断电无，但是根据设置不同，可以操作超频，也可以把系统本身装进内存（相信我爽到起飞）9、intel很多系列芯片虽然不能超频但是可以睿频，就是智能忽高忽低。超频需要在BIOS设置，设置好频率和电压的关系，好好考虑散热压不压得住10、南桥芯片组很重要，掌管电脑除了显卡、CPU之外鼠标、键盘等小玩意11、装机有的时候真的要大力出奇迹12、装机版最麻烦的不是上面说的那些，而是理线13、台式机一般不自带蓝牙、WIFI需要自己购买14、不要装xp，xp只能用4G内存15、双通道内存条要错开装，13、24这样16、m.2有的情况和pcie供用带宽，注意看主板说明书17、新手不推荐水冷。风冷血滴子手剧痛18、硅脂是为了填补cpu盖板表面和散热器直接的缝隙，别涂在针脚 上，硅脂一般酷冷至尊效果好点吧，论克卖的，好的硅脂、正确手法真的猛压住了温度19、水冷不是没有风扇，只是导热和循环变成水，但是也不是自来水。同价位风冷好20、风冷水冷都有热管，里面是热胀冷缩，相变冷凝的原理，如果有瑕疵就废了21、风扇内外别装反22、cpu分成盒装和散片，盒装就intel、AMD直接卖给个人消费者分，自带散热器（垃圾玩意，挤铝下压工艺，被动散热效果极差，但是政府机关买的台式机一般都这个）。散片也叫流片，是Intel、amd卖给dell、惠普等OTA厂商后，他们基于某些原因又倒卖的，品质完全一样，只是没有散热器赠送，质保也不一样23、要装机的话选个长螺丝刀，散热器的弹簧螺丝角度很刁钻24、机箱不是必须的，拿鞋盒当机箱也行 CPU主要参数 频率 基频 睿频 超频 核心 架构 缓存 厂家 intel（celeron,pentium,core,xeon） AMD（速龙，线程撕裂者，RYZen） 其他 正式版（盒装，散片） ES版（不显版，正显版QS） 购买需检查CPU上的小电容是否脱落，特别防拆贴在电容上的 intel第一代处理器会省掉1 洋垃圾系类E3,E5 E5E5 2666V3第一位数字表示可同时工作的CPU第二位数字表示主板对应针脚，4为1356针，6为2011针V1,V2 使用x79平台V3,V4 使用X99平台 显卡CPU 线程少，逻辑能力强GPU 线程多，逻辑能力弱 显卡的分类 集成显卡 核心显卡 独立显卡集成显卡是将显卡集成在主板上，使得显卡和主板融为一体，但它会占用系统内存，可能会对电脑性能产生一定影响。 核显则是集成在 CPU 里的图形处理单元，与CPU融为一体，它依托CPU强大的运算能力和智能能效调节设计，进一步加强了图像处理的效率。 厂家 英伟达 AMD 公版卡和非公板卡 常见矿卡 RX580 GTX1660s RX5600XT RX5700XT RTX2080s 性能指标 流处理器数量（画师数量） 处理器架构（画师水平） 频率（画师绘画的速度） 显存频率（运输叉车的速度） 显存带宽（运输叉车每次运多少） 显存容量（仓库大小） 成果E5洋垃圾","tags":["电脑组装DIY"]},{"title":"第二十六届人工智能操作手册，测试版","path":"/2024/05/13/第二十六届人工智能操作手册，测试版/","content":"初始介绍用户名：racecar密码：1 思路通过gmapping算法建图，然后通过打点程序储存需要的导航点，在运行程序过程中，发布导航点，车辆就会达到目标点。 建图将车辆发在起始点，注意标注位置，⽐如说后编码器抵着后挡板 启动底盘，启动电调打开在终端中输入 1python3 ~/car_2024_rengong/src/auto_go/scripts/run_mapping.py 启动建图脚本，会弹出若干个弹窗。 在显示有control的终端进行键盘操作， W为向前⾛，Q为向左⽅⾛，E为向右⽅⾛，s为停止。 建图完成后，请按键盘上的m保存地图，此时会弹出⼀个新的终端，终端运⾏完成即可。 如果建图失败，或建图重叠，键盘控制界面按s停止，关闭所有终端，再次输入脚本。 建图时尽量直行，不要过多拐弯，观察rviz,有完。整图后及时按m保存。 标点标注的点为导航点，第一个点是第一个导航点结束标点时，发布⼀个和终点处箭头坐标⼀样的点即可请按照坐标抵达的先后顺序进⾏标点 1python3 ~/car_2024_rengong/src/auto_go/scripts/run_way_point_click.py 如果需要读取并修改之前保存的点，请填⼊1并回⻋，然后需要在rviz的任意处使⽤rviz的Publish Point功能发布⼀个点后，之前保存的点位才会显示。 然后在rviz中进⾏标点，使⽤2D nav goal 按钮进⾏坐标点的发布，如果需要移动以及发布的坐标点，请使⽤Publish Point对已经存在的点进⾏点击，箭头变红，然后就可以使⽤点 结束标点时，发布⼀个和终点处箭头坐标⼀样的点即可 打点时终点一段路多打几个，方便拟合 发车1python3 ~/car_2024_rengong/src/auto_go/scripts/wj_run.py 所有程序都打开后，在出现go?的终端回车，车辆运行 车辆运行关键：1.正确的地图2.合理的参数 参数调整: 12345678打开~/car_2024_rengong/src/racecar/launch/acml_nav.launch文件该参数及其附近参数能够调整其速度 &lt;param name=&quot;vp_min&quot; value=&quot;160&quot;/&gt; 打开~/car_2024_rengong/src/auto_go/scripts/wj_go_hh.py文件该参数能够调整距离导航点多远时，发布下一个导航点。Distance_min = 1.2","tags":["ros"]},{"title":"校巡线车校赛决赛代码","path":"/2024/04/19/校巡线车校赛决赛代码/","content":"校赛第二名，净挣1000，当然不妨碍代码是垃圾代码，没啥必要发github,发发博客差不多得了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;Servo.h&gt; #include &lt;MsTimer2.h&gt;Servo myservo; int pos = 70; //舵机中值，对于我的舵机左-&gt;右 40-100int lift = 20;int right = 120;// 舵机PWM引脚9，左电机PWM引脚5,右电机PWM引脚6；int servo = 9; int motor1=5; int motor2=6;int motor1_speed =60; int motor2_speed =60;// 设置对管状态int white = 0;int black = 1;int err,last_err; //pid 参数定义int output;float kp=10,ki=0,kd=0;float P,I,D;// 红外对管左-&gt;右引脚为2,3,4,7,8,12,13int infrared[7]=&#123;2,3,4,7,8,12,13&#125;;//实例特判int zhijiao = 0;int hu = 0;int hu2 = 0;int hu2_flag =0;int final =0;void flash() &#123; final =1;&#125;void setup() &#123; myservo.attach(9); // 该舵机由arduino第九脚控制 myservo.write(pos); //电机pwm引脚初始化，模式设置为输出模式 pinMode(motor1,OUTPUT); pinMode(motor2,OUTPUT); pinMode(10,OUTPUT); Serial.begin(9600);//串口初始化 //红外对管引脚模式设置为输入上拉模式 pinMode(infrared[0],INPUT_PULLUP); pinMode(infrared[1],INPUT_PULLUP); pinMode(infrared[2],INPUT_PULLUP); pinMode(infrared[3],INPUT_PULLUP); pinMode(infrared[4],INPUT_PULLUP); pinMode(infrared[5],INPUT_PULLUP); pinMode(infrared[6],INPUT_PULLUP); //初始速度 analogWrite(motor1,motor1_speed); analogWrite(motor2,motor2_speed);&#125;void loop() &#123; if(zhijiao == 0)&#123; zhijiao = 1; analogWrite(motor2,80); delay(1800); myservo.write(40); analogWrite(motor2,100); delay(1000); &#125; if((hu == 0 &amp;&amp; zhijiao == 1 &amp;&amp; digitalRead(infrared[0])==black &amp;&amp; digitalRead(infrared[3])==black) || (hu == 0 &amp;&amp; zhijiao == 1 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[3])==black))&#123; hu = 1; analogWrite(5,0); analogWrite(6,0); analogWrite(11,100); myservo.write(70); delay(1800); myservo.write(30); analogWrite(11,0); analogWrite(5,100); analogWrite(6,100); delay(1500); &#125; if(final==1 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[2])==black &amp;&amp; digitalRead(infrared[3])==black)&#123; analogWrite(5,0); analogWrite(6,0); delay(5500); &#125; if(hu==1 &amp;&amp; hu2==0 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[2])==black &amp;&amp; digitalRead(infrared[3])==black)&#123; hu2 = 1; analogWrite(5,0); analogWrite(6,0); analogWrite(11,140); myservo.write(90); delay(2000); myservo.write(30); analogWrite(11,0); analogWrite(5,120); analogWrite(6,120); delay(1000); motor1_speed =70;motor2_speed =70; MsTimer2::set(25000, flash); // 5000ms period MsTimer2::start(); &#125; sensor(); int control_turn =pos + pid(); myservo.write(control_turn); if(err == 4)&#123; analogWrite(motor1,motor1_speed+60); &#125; else if(err == -4)&#123; analogWrite(motor2,motor2_speed+60); &#125; else if(err == 2)&#123; analogWrite(motor1,motor1_speed+20); if(hu==1 &amp;&amp; hu2==0)&#123; analogWrite(motor1,motor1_speed+40); &#125; &#125; else if(err == -2)&#123; analogWrite(motor2,motor2_speed+20); if(hu==1 &amp;&amp; hu2==0)&#123; analogWrite(motor2,motor2_speed+40); &#125; &#125; else&#123; analogWrite(motor1,motor1_speed); analogWrite(motor2,motor2_speed); &#125;&#125;int pid()&#123; P = err; I += err; D = err - last_err; output = kp*P + ki*I + kd*D; last_err = err; return output;&#125;void sensor()&#123; int a_1 = digitalRead(infrared[0]); int a_2 = digitalRead(infrared[1]); int a_3 = digitalRead(infrared[2]); int a_4 = digitalRead(infrared[3]); int a_5 = digitalRead(infrared[4]); int a_6 = digitalRead(infrared[5]); int a_7 = digitalRead(infrared[6]); if(a_1==black &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -4; &#125; else if(a_1==white &amp;&amp; a_2==black &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -2; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==black &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -1; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==black &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = 0; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==black &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = 1; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==black &amp;&amp; a_7==white)&#123; err = 2; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==black)&#123; err = 4; &#125; Serial.println(err); //测试代码&#125;"},{"title":"讯飞二代车记录","path":"/2024/03/30/讯飞二代车记录/","content":"开始二代车https://github.com/liwuyou/xunfei_second.git 初始配置官方包编译键盘控制python文件使用，放在ucar_ws&#x2F;src&#x2F;目录下 建图配置1234567891011121314151617181920212223# 启动键盘节点roslaunch ucar_map ucar_gmapping.launch# 键盘控制节点python3 ~/ucar_ws/src/ucar_map/launch/mbot_teleop.py # 保存地图rosrun map_server map_saver -f /home/iflytek/ucar_ws/src/ucar_map/maps/name# name为自己命名的文件``` ## 挂载地图并取得点坐标```python# 发布已建好的地图rosrun map_server map_server /home/iflytek/ucar_ws/src/ucar_map/maps/name# 打开rviz,挂载地图，选择publisher,看左下角，确定x,yrviz# 修改pose文件欧拉角转四元数https://quaternions.online/ 导航123# 启动导航文件roslaunch ucar_nav ucar_navigation_wy.launch# rviz发布目标点，观察小车轨迹是否有异常，修改配置文件 官方局部路径规划不可用， 1234567891011# 安装teb_local_planner路径规划sudo apt-get install ros-noetic-teb-local-planner# 修改ucar_navi.launch文件下局部路径规划为teb_local_planner，在movebase下添加配置文件 &lt;param name=&quot;base_global_planner&quot; value=&quot;global_planner/GlobalPlanner&quot; /&gt; &lt;param name=&quot;planner_frequency&quot; value=&quot;10.0&quot; /&gt; &lt;param name=&quot;planner_patience&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;use_dijkstra&quot; value=&quot;true&quot; /&gt; &lt;param name=&quot;base_local_planner&quot; value=&quot;teb_local_planner/TebLocalPlannerROS&quot; /&gt; &lt;param name=&quot;controller_frequency&quot; value=&quot;30.0&quot; /&gt; &lt;param name=&quot;controller_patience&quot; value=&quot;10.0&quot; /&gt; &lt;param name=&quot;clearing_rotation_allowed&quot; value=&quot;true&quot; /&gt;","tags":["讯飞"]},{"title":"讯飞车找板子返回坐标点程序","path":"/2024/03/22/讯飞车找板子返回坐标点程序/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import numpy as npdef rotate_vector(vector, angle): &quot;&quot;&quot; 将向量旋转一定的角度 &quot;&quot;&quot; # 将角度转换为弧度 angle_rad = np.deg2rad(angle) # 构造旋转矩阵 rotation_matrix = np.array([[np.cos(angle_rad), -np.sin(angle_rad)], [np.sin(angle_rad), np.cos(angle_rad)]]) # 使用旋转矩阵对向量进行旋转 rotated_vector = np.dot(rotation_matrix, vector) # 保留三位有效数字 rotated_vector = np.around(rotated_vector, decimals=3) return rotated_vectordef radians_to_vector(theta): &quot;&quot;&quot; 将theta转化为向量 &quot;&quot;&quot; # 计算向量的 x 和 y 分量 x = np.cos(theta)*1 y = np.sin(theta)*1 # 保留三位小数 x = np.around(x, decimals=3) y = np.around(y, decimals=3) return np.array([x, y])def is_angle_less_than_X(x, v1, v2): # 计算向量的点积 dot_product = np.dot(v1, v2) # 计算向量的模长 v1_norm = np.linalg.norm(v1) v2_norm = np.linalg.norm(v2) # 计算夹角的余弦值 cos_angle = dot_product / (v1_norm * v2_norm) # 计算 X 度的余弦值 cos_x_deg = np.cos(np.deg2rad(x)) return cos_angle &gt; cos_x_degdef is_angle_greater_than_90(v1, v2): &quot;&quot;&quot; 判断两向量夹角是否大于90度，大于返回True &quot;&quot;&quot; # 计算向量的点积 dot_product = np.dot(v1, v2) # 如果点积小于 0，则夹角大于 90 度 return dot_product &lt; 0class BoardTrue: &quot;&quot;&quot; 用于判断并筛选出有效的板子 &quot;&quot;&quot; def __init__(self, my_list, car_x, car_y, car_theta, cv_po): self.my_list = my_list self.car_x = np.around(car_x, decimals=3) self.car_y = np.around(car_y, decimals=3) self.car_theta = np.around(car_theta, decimals=3) self.cv_po = np.around(cv_po, decimals=3) def chose_board(self): if len(self.my_list) == 0: return None else: n = len(self.my_list) print(n) for i in range(n): if 0.2 &lt; self.my_list[i][2] &lt; 0.7: x = self.my_list[i][0] - self.car_x y = self.my_list[i][1] - self.car_y v1 = np.array([x, y]) v2 = radians_to_vector(self.car_theta) print(&quot;i为&quot; + str(i)) print(is_angle_less_than_X(70, v1, v2)) if is_angle_less_than_X(70, v1, v2): print(&quot;dfg&quot;) mapped_value = (self.cv_po - (0)) * (70 - (-10)) / (640 - 0) + (-70) v3 = rotate_vector(v2, mapped_value) if is_angle_less_than_X(25, v1, v3): print(&quot;asd&quot;) return self.my_list[i] else: continue else: continue return Noneclass BoardWithCv: &quot;&quot;&quot; 使用此类时，请确保传入的板子是一个且有效,他会返回一个导航点x,y,theta &quot;&quot;&quot; def __init__(self, car_x, car_y, car_theta, board_x, board_y, board_theta): # 实例属性 self.car_x = np.around(car_x, decimals=3) self.car_y = np.around(car_y, decimals=3) self.car_theta = np.around(car_theta, decimals=3) self.board_x = np.around(board_x, decimals=3) self.board_y = np.around(board_y, decimals=3) self.board_theta = np.around(board_theta, decimals=3) def is_board_theta_ture(self): &quot;&quot;&quot; 判断并执行板子的角度是否需要反转,并返回导航点,弧度，是否有效 :return: &quot;&quot;&quot; v1 = np.array([self.board_x - self.car_x, self.board_y - self.car_y]) v2 = radians_to_vector(self.board_theta) if is_angle_greater_than_90(v1, v2): self.board_theta = self.board_theta + 3.141 v2 = radians_to_vector(self.board_theta) goal_x = np.around(self.board_x - 0.3 * v2[0], decimals=3) goal_y = np.around(self.board_y - 0.3 * v2[1], decimals=3) return goal_x, goal_y, self.board_thetaif __name__ == &quot;__main__&quot;: ## 测试代码 # board=[-1,1,0.785] board = [-1.6258577108383179, 1.445590853691101, 0.456392377614975, 0.011698315851390362, 1.518639469495104] # board=[-3,1,3.14-0.785] pos = BoardWithCv(-2, 0, 1.57, board[0], board[1], board[4]) print(pos.is_board_theta_ture()) my_list = [[-1, 1,0.5,0.02, 0.785], [-3, 1,0.5,0.02,3.14-0.785], [-2, 1,0.5,0.02,1.3]] my_list2 =[] my_list3 = [[-1.1039749383926392, -1.6410338878631592, 0.459942102432251, 0.006066703703254461, 2.404021134944642], [-1.0234383344650269, 1.4331644773483276, 0.6236299276351929, 0.0975717082619667, 0.6774194980518585], [-1.6258577108383179, 1.445590853691101, 0.456392377614975, 0.011698315851390362, 1.518639469495104], [-2.016007423400879, 1.6973320245742798, 0.17067547142505646, 0.008529485203325748, 1.4121627729088593], [-2.3203864097595215, 1.3803951740264893, 0.4648244082927704, 0.011016763746738434, 2.12274152271989]] my_list4 = [[-2.2005648612976074, -1.9698346853256226, 0.26301005482673645, 0.02629818394780159, 1.2184761268334674], [-1.6092170476913452, -1.8576725721359253, 0.3533917963504791, 0.029181374236941338, 1.9172304414045462], [-1.0438616275787354, -1.4628329277038574, 0.47950631380081177, 0.013515759259462357, 2.4409537863628334], [-1.6358827352523804, 1.4406025409698486, 1.5764230489730835, 0.26953673362731934, 1.4236640668400438]] my_list5 = [[-2.2020256519317627, -1.9928362369537354, 0.2039794772863388, 0.025548739358782768, 1.1120026801359906], [-1.6541303396224976, -1.898160457611084, 0.3227234482765198, 0.01702151633799076, 1.7969596897315867], [-1.4612840414047241, -1.1711866855621338, 0.4812791049480438, 0.05817915499210358, 2.159874044377892], [-1.0457868576049805, 1.2947330474853516, 0.44938141107559204, 0.009451523423194885, 0.8893285575700086], [-2.283306121826172, 1.518304705619812, 0.4721873700618744, 0.007294466253370047, 2.0108069978910965]] posa = BoardTrue(my_list5, -2, 0, 0.8, 331) print(posa.chose_board())&quot;&quot;&quot;[00:15:08.34] 前往pose_3&#123;u&#x27;spontoon&#x27;: 284.0&#125;targetspontoonfirst_1&#123;u&#x27;spontoon&#x27;: 284.0&#125;boards[[-2.20574951171875, -1.9964897632598877, 0.19374234974384308, 0.0202349741011858, 1.0713866771931375], [-1.6379033327102661, -1.9009284973144531, 0.34384506940841675, 0.010412354953587055, 1.8343551319682068], [-1.4544870853424072, -1.176705002784729, 0.4698032736778259, 0.053842246532440186, 2.147697938715995], [-1.02494215965271, 1.2817209959030151, 0.468691885471344, 0.005473896395415068, 0.8983430915438178], [-2.271810293197632, 1.5118887424468994, 0.46807199716567993, 0.00690682977437973, 2.0043066211443765]][-1.02494215965271, 1.2817209959030151, 0.468691885471344, 0.005473896395415068, 0.8983430915438178]quat=[0, 0, 0.434, 0.901]send the goal&quot;&quot;&quot;"},{"title":"ROS车记录","path":"/2024/03/12/ROS车记录/","content":"基于一代讯飞车的ROS记录 常见命令行123456789# 更改屏幕分辨率xrandr --fb 1600x900更改完后，远程桌面要关闭再打开压缩文件夹zip -r file.zip file 常用launch文件包12roslaunch ucar_controller base_driver.launch启动底盘节点 地图操作地图发布，rviz查看12rosrun map_server map_server 文件名.yamlrosrun rviz rviz 建图，并保存1234# 启动建图launch包# 启动键盘控制，小车运动# 保存地图rosrun map_server map_saver -f &lt;map_file_name&gt;","tags":["ros"]},{"title":"python算法实战","path":"/2024/03/12/python算法实战/","content":"去年报名了蓝桥杯，却一直没有练习，也该开始了，为了300的报名费 时间复杂度O(1),O(n),O($n^{2}$),O($log_{2}n$),O(n!)… 空间复杂度 递归 调用条件 结束自身 实例 12345678910def jiecheng(n): if n != 1: sum = n * jiecheng(n - 1) return sum else: return 1print(jiecheng(5)) 12#结果120 查找 顺序查找 二分查找 顺序查找12345678910def shuxu(list_1, val): for i in range(len(list_1)): if val == list_1[i]: return i else: returnlist_my = list(range(5))print(shuxu(list_my, 3)) 12#结果3 二分查找1234567891011121314def binary_search(my_list, val): # my_list 为list,val为待查找的值 lift = 0 right = len(my_list) - 1 mid = (lift + right) // 2 while lift &lt;= right: if my_list[mid] == val: return mid elif my_list[mid] &gt; val: right = mid - 1 else: lift = mid + 1 else: return None 排序将一组无序序列变为有序序列升序与降序内置排序算法sort() LOW 冒泡排序 选择排序 插入排序 NB 快速排序 堆排序 归并排序 其他 希儿排序 计数排序 基数排序 sort的使用需要注意的是，sort()方法会直接修改原列表，而不是返回一个新的排序后的列表 冒泡排序 列表每相邻的两个数，如果后面比前面大，交换两个数 一次排序，无序区减少一个数，有序区增加一个数 12345678910111213import randomdef bubble_sort(my_list): for i in range(len(my_list)-1): # -1防止内存溢出 for j in range(len(my_list)-1-i): if my_list[j]&gt;my_list[j+1]: my_list[j],my_list[j+1]=my_list[j+1],my_list[j]my_list = [random.randint(0,10000) for i in range(5)]print(my_list)bubble_sort(my_list)print(my_list) 123# 结果[3003, 7653, 1759, 5541, 3176][1759, 3003, 3176, 5541, 7653] range详解range() 函数是 Python 中常用的一个函数，用于生成一个整数序列。它常用于循环中，可以生成指定范围的整数序列。 range() 函数有三种常用的用法： range(stop): 生成从 0 开始到 stop-1 的整数序列。 range(start, stop): 生成从 start 开始到 stop-1 的整数序列。 range(start, stop, step): 生成从 start 开始到 stop-1 的整数序列，步长为 step。123456789101112# 生成从 0 到 4 的整数序列for i in range(5): print(i) # 输出：0, 1, 2, 3, 4# 生成从 2 到 5 的整数序列for i in range(2, 6): print(i) # 输出：2, 3, 4, 5# 生成从 1 到 10 的偶数序列for i in range(2, 11, 2): print(i) # 输出：2, 4, 6, 8, 10 需要注意的是，range() 函数生成的是一个可迭代对象，而不是一个列表。如果需要得到一个列表，可以使用 list() 函数将其转换为列表：12my_list = list(range(5)) # 将 range 对象转换为列表print(my_list) # 输出：[0, 1, 2, 3, 4] random详解使用前需要import random random.random(): 返回一个 [0.0, 1.0) 之间的随机浮点数。 random.randint(a, b): 返回一个 [a, b] 之间的随机整数。 random.uniform(a, b): 返回一个 [a, b] 之间的随机浮点数。 random.choice(seq): 从序列 seq 中随机选择一个元素返回。 random.shuffle(seq): 将序列 seq 中的元素随机排序 random.sample(population, k): 从 population 中随机选择 k 个不重复的元素返回，返回一个列表。 选择排序打擂台排序 1234567891011import randomdef select_sort(my_list): for i in range(len(my_list)): for j in range(i,len(my_list)): if my_list[j]&lt;my_list[i]: my_list[j],my_list[i]=my_list[i],my_list[j]my_list = [random.randint(0,10000) for i in range(5)]print(my_list)select_sort(my_list)print(my_list) 123# 结果[3871, 3692, 8939, 1310, 1203][1203, 1310, 3692, 3871, 8939] 插入排序 初始时手里（有序区）只有一张牌 每次（从无序区）摸一张牌，插入到手里已有牌的正确位置123456789101112131415161718import randomdef insert_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j &gt;= 0 and arr[j] &gt; key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = keymy_list = [random.randint(0, 10000) for i in range(5)]print(my_list)insert_sort(my_list)print(my_list) 123# 结果[904, 5335, 5843, 9487, 1597][904, 1597, 5335, 5843, 9487] 数据结构python中数据结构的类型 元组 无法修改，tuple,不可变数据结构 利用in查找 列表 支持增删改查 切片[x:y],左闭右开 追加，列表末尾增加元素list.append(元素) 插入，list.insert(下标,元素) 删除, list.pop(下标)，默认为最后一个元素 字典 删除，dictionary.pop(“键”) 字符与字符串实战统计出其中数字字符的个数输入一行字符，统计出其中数字字符的个数。 12345678user_input = input()digit_count = 0for char in user_input: if char &lt;= &#x27;9&#x27; and char &gt;= &#x27;0&#x27;: digit_count += 1print(digit_count) isdigit() 是 Python 中字符串对象的一个方法，用于检查字符串中的所有字符是否都是数字字符（即 0-9）。可以改为 12345678user_input = input()digit_count = 0for char in user_input: if char.isdigit(): digit_count += 1print(digit_count) 给定一个只包含小写字母的字符串请你找到第一个仅出现一次的字符。如果没有，输出 no 12345678my_list = input()for char in my_list: if my_list.count(char) == 1: print(char) breakelse: print(&quot;no&quot;) 详解countcount() 方法是字符串对象的一个内置方法，用于统计指定子字符串在原字符串中出现的次数。count() 方法只会统计不重叠的子字符串。例如，在字符串 “aaaaa” 中统计子字符串 “aa” 的出现次数，结果为 2，而不是 4，因为两个 “aa” 子字符串之间重叠","tags":["python"]},{"title":"数电重置版","path":"/2024/03/08/数电重置版/","content":"我希望在3月20号之前学完数电，开始挑战！数电第三章不学，七八章选学，带星号不写，over————2024.3.20 整体逻辑框架图 数制与码制10进制转2进制 2进制转10进制 10进制转8421BCD互转 逻辑代数基础异或与同或及其常见与或非 基本公式与常用公式 反演定理与对偶定理 卡诺图 最小项及其无关项无关项（d表示，卡诺图中用X） 任意项 约束项 目的：矩形圈最大，矩形数量最少 化简 转化 组合逻辑电路常见组合逻辑模块编码器 普通编码器 优先编码器（允许同时输入两个以上的编码信号） 译码器与显示译码器 数据选择器 半加器与全加器 数值比较器 竞争冒险现象及其如何消解消除方法 接入滤波电容 引入选通脉冲 增加冗余项（eg: Y&#x3D;A+A’+BC） 半导体电路分类存储大小 存储单元（一个字节） 静态存储单元 动态存储单元（需要定时刷新，主要用电容） 寄存器（一组字节） 存储器（大量字节） SR锁存器 与非门SR锁存器 或非门SR锁存器 触发器电平触发的SR触发器 电平触发的D触发器为了适应单端输入信号需求，常用D输入代替S,R输入利用CMOS传输门组成电平触发的D触发器在clk有效期间，输出与输入相同，该触发器又被称为透明D触发器 边沿触发的D触发器该电路上升沿有效Q*&#x3D;D 脉冲触发的SR触发器 脉冲触发的JK触发器 边沿触发的T触发器 触发器的分类触发方式分类 无触发 电平触发 边缘触发 脉冲触发 触发器分类 SR触发器 D触发器 JK触发器 T触发器 触发方式与逻辑功能无逻辑关系 存储器随机存储器RAM(断电丢失) 静态存储器（SRAM,速度快，集成度低，成本高） 动态存储器（DRAM，速度慢，集成度高，成本低）只读存储器ROM(断电不丢失) 掩膜ROM 可编程ROM 可擦除可编程ROM 存储器的拼装时序逻辑电路 同步，一个时钟信号 异步 同步时序电路"},{"title":"陀螺仪的工作原理","path":"/2024/02/15/陀螺仪的工作原理/","content":"陀螺仪的分类提供位置与角速度的装置 机械陀螺仪 光学陀螺仪 测量各部分压力 光学陀螺仪，计算接受的合成光束与初始光束的相位差，算得偏转量","tags":["其他"]},{"title":"基础电气知识部分综合","path":"/2024/01/29/基础电气知识部分综合/","content":"上拉电阻与下拉电阻下拉电阻没有下拉电阻，引脚浮空，将不确定的信号钳位在低电平不确定阻值设置为10k-100K 上拉电阻将不确定的信号钳位在高电平，有时io驱动能力不足时也可以加上拉电阻 寄生电容即电路中的元件在物理上不是电容时表现得像电容。在高频电路中会导致信号的失真和噪声的增加 如何减少寄生电容1.缩短元件之间的距离，从而减小元件之间的电容。2.将元件引脚与地之间的距离尽量缩短，减小元件与地之间的电容。3.合适的PCB布局，有效减小PCB板上的电容。4.采用屏蔽措施，以便减小电磁干扰。 滤波电容 GPIO的输出模式 高阻输出（有内置上拉电阻，或外加上拉电阻） 推挽输出（参考CMOS功能，输出高低电平）","tags":["PCB设计"]},{"title":"12V转5V电源模块","path":"/2024/01/27/12V转5V电源模块/","content":"前言看了B站孙老师的视频，受益匪浅，决定设计自己的12V转5V的电源模块采用同步整流芯片TPS54302，改芯片数据手册如下 https://www.ti.com/cn/lit/ds/symlink/tps54302.pdf?ts=1706321372159&amp;ref_url=https%253A%252F%252Fitem.szlcsc.com%252F 2 4.5V 至 28V 输入、3A 输出、EMI 友好型同步降压转换 降压电路原理 芯片原理图 自己画的原理图由于实际封装与原理图不一致，自己画的并没有芯片原理图那么规整 第一版pcb设计设计注意要点 线宽 避免直角走线 元件选型 正面 反面 第二版pcb设计设计要点 反馈电路选取电在电容附近 铜箔走线，过大电流 对称，美观 电容电阻选型时要选择合适的封装，电容电阻常见封装为0603,0805,1206等 正面 反图 实物图","tags":["PCB设计"]},{"title":"模电","path":"/2024/01/20/模电/","content":"信号时间和数值 时间连续，数值连续（模拟信号） 时间不连续，数值连续（抽样信号） 时间连续，数值不连续（脉冲信号） 时间不连续，数值不连续（数字信号） 常用半导体器件基础知识 导体 半导体 绝缘体 常见半导体，硅(si)和锗(ge)四价元素 半导体分类，本征半导体与杂质半导体 载流子有自由电子与空穴 N型半导体(五价磷)与P型半导体(三价硼) 重点 PN节硅(si)原子结构 单晶硅齐纳击穿与雪崩击穿扩散运动与漂移运动正向特征 截止区（死区） 导通区 过流区 反向特征 反向饱和区 反向击穿区","tags":["课程"]},{"title":"数电","path":"/2024/01/11/数电/","content":"数制与码制进制转化原码，反码，补码 正数三码合一 负数，反码标志位不变，其他取反，补码，在反码基础上加1 计算机以补码形式运算 逻辑代数基础与或非及其变种 门电路概述 单开关电路与互补开关电路门电路的基本元件 二极管 三极管 MOS管 半导体二极管学习要点 二极管 理想二极管 实际二极管 理想开关 二极管的动态电流效应（类似电容） 二极管实现门电路实现0&#x2F;1实现与电路实现或电路 二极管门电路的缺陷 二极管实现的与或门有高低电平的偏移 负载影响输出的高电平 MOS管P沟道与n沟道MOS管 mos管的输入输出特性 截止区 可变电阻区 恒流区 P沟道与N沟道MOS的区别 CMOS反相器 组合逻辑电路逻辑电路分类 组合逻辑电路 时序逻辑电路（含存储器） 编码器 普通编码器 优先编码器 74HC148引脚定义 16线-4线输出原理图 74HC147（二-十进制优先编码器） 竞争与冒险现象是什么？有尖峰-冒险可能尖峰-竞争 如何判断？是否出现Y&#x3D;A+A’或Y&#x3D;AA’用EDA软件检查是否有毛刺现象，检查时序 如何解决？ 接滤波电容 引入选通信号（再有毛刺发生的时候不输出） 修改逻辑设计（增加冗余项）","tags":["课程"]},{"title":"电子电路基础知识","path":"/2024/01/06/电子电路基础知识/","content":"基础元件 电阻 电容 电感 二极管 三极管&#x2F;mos管 电阻色环电阻的辨认电阻的符号电阻的单位转换电阻的封装 三极管基极B,集电极C,发射极D.B极小电流控制C极大电流，具有电流放大作用 三种工作状态 截止状态 放大状态 饱和状态 MOS管源极S 栅极G 漏极D 特性 栅极阻抗高 易被静电击穿 参数 Vgsth 电压临界值 Rdson 电阻 Cgs 栅极电容 三极管与MOS管的区别 三极管是电流控制的元件，MOS管是电压控制的元件 MOS管省电，阻抗小 三极管便宜，耐高压大电流","tags":["电路"]},{"title":"51单片机核心板绘制","path":"/2024/01/01/51单片机核心板绘制/","content":"参考资料 https://blog.csdn.net/weixin_61121477/article/details/127743905 https://mp.weixin.qq.com/s/Ca96Eaom3HDGVuQAlgokvg https://blog.csdn.net/flying_man_/article/details/82557816 原理图 pcb图 3D渲染图 详解单片机最小系统包括核心模块有： 电源模块 复位模块 外部晶振模块 下载模块 本原理图中，采用type-c 16pin为下载和电源接口，根据单片机手册，输入电压为3.8v~5.5v.根据手册，P0开漏输出，原理图设计时，加上拉电阻作为I&#x2F;O口使用。 晶振模块采用32M,由手册提供，原理图并不完全符合。 https://zhuanlan.zhihu.com/p/72583737晶振电路原理详解 滤波电容，消除震荡。 usb转串口模块常用的有CH340N与CH340G。","tags":["单片机"]},{"title":"电子设计实训小组计划","path":"/2024/01/01/电子设计实训小组计划/","content":"电子设计实训小组计划于2024-01-01开启，新年新气象，这是一次积极的尝试。 初始成员6人 data:2024-01-01目的：锻炼电路设计，编程能力基本准则：共同商议，共同管理，共同进步 第一次计划：51单片机核心板的绘制 寒假学习：1.数电模电2.嘉立创的学习与使用3.个人博客（选修） data:2024-01-06四人完成51单片机的原理图绘制与pcb绘板工作准备开始打板测试工作 data:2024-01-17第一次寒假线上会议，确定基本任务 任务一：个人博客的制作 任务二：12V转5V电源模块 任务三：数电模电第一章的学习 任务四：在嘉立创免费范围内打点小东西 其他：电赛题目搜集。1月25复盘总结。 data:2024-01-25第二次寒假线上会议，总结上次成果12V转5V电源模块 个人博客的汇总http://shisan-ok.gitee.io https://sherlock000125.github.io https://fransic.top https://liwuyou.github.io 下阶段任务 数电第二章，模电第一章未完成继续 设计一个电机驱动模块 跑跑仿真 data:2024-02-02第三次寒假线上会议，总结上次成果电机驱动模块 data:2024-02-14会议重点:1.软件方面，自行处理2.本次做陀螺仪模块，主要处理信号方面，模块外围电路较少，尽量的设计好一点，熟悉芯片的选型，PCB走线信号线设计3.数电模电向前推进一章4.完善个人博客5.我们还差ADC的转换和射频，自行处理。ADC的转换比较重要","tags":["计划"]},{"title":"单片机的常见通讯协议","path":"/2023/12/30/单片机的常见通讯协议/","content":"常见单片机通讯协议 I2c通信 spi通信 I2c通信 https://blog.csdn.net/yanlaifan/article/details/72843577?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170393696216800226590203%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170393696216800226590203&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-72843577-null-null.142^v99^pc_search_result_base3&amp;utm_term=i2c%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E5%9B%BE&amp;spm=1018.2226.3001.4187 硬件层两根线，SDA(数据)和SCL(时钟)从最高位到最低位发送（MSB—&gt;LSB） 协议层协议 空闲态 起始信号 逻辑电平 时序图 停止位在时钟线为高时，数据线为高，为1，否则为0 代码以51单片机为例I2C.h文件 123456789101112#ifndef __I2C_H__#define __I2C_H__void I2C_Start(void);void I2C_Stop(void);void I2C_SendByte(unsigned char Byte);unsigned char I2C_ReceiveByte(void);void I2C_SendAck(unsigned char AckBit);unsigned char I2C_ReceiveAck(void);#endif I2C.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;REGX52.H&gt;sbit I2C_SCL=P2^1;sbit I2C_SDA=P2^0;/** * @brief I2C开始 * @param 无 * @retval 无 */void I2C_Start(void)&#123;\tI2C_SDA=1;\tI2C_SCL=1;\tI2C_SDA=0; I2C_SCL=0; &#125;/** * @brief I2C停止 * @param 无 * @retval 无 */void I2C_Stop(void)&#123;\tI2C_SDA=0;\tI2C_SCL=1;\tI2C_SDA=1;&#125;/** * @brief I2C发送一个字节 * @param Byte 要发送的字节 * @retval 无 */void I2C_SendByte(unsigned char Byte)&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; I2C_SDA=Byte&amp;(0x80&gt;&gt;i); I2C_SCL=1; I2C_SCL=0;\t&#125;&#125;/** * @brief I2C接收一个字节 * @param 无 * @retval 接收到的一个字节数据 */unsigned char I2C_ReceiveByte(void)&#123;\tunsigned char i,Byte=0x00;\tI2C_SDA=1;\tfor(i=0;i&lt;8;i++)\t&#123; I2C_SCL=1; if(I2C_SDA)&#123;Byte|=(0x80&gt;&gt;i);&#125; I2C_SCL=0;\t&#125;\treturn Byte;&#125;/** * @brief I2C发送应答 * @param AckBit 应答位，0为应答，1为非应答 * @retval 无 */void I2C_SendAck(unsigned char AckBit)&#123;\tI2C_SDA=AckBit;\tI2C_SCL=1;\tI2C_SCL=0;&#125;/** * @brief I2C接收应答位 * @param 无 * @retval 接收到的应答位，0为应答，1为非应答 */unsigned char I2C_ReceiveAck(void)&#123;\tunsigned char AckBit;\tI2C_SDA=1;\tI2C_SCL=1;\tAckBit=I2C_SDA;\tI2C_SCL=0;\treturn AckBit;&#125; 写入与读取1帧的数据 123456789101112131415161718192021222324252627282930313233void AT24C02_WriteByte(unsigned char WordAddress,Data)&#123;\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS);\tI2C_ReceiveAck();\tI2C_SendByte(WordAddress);\tI2C_ReceiveAck();\tI2C_SendByte(Data);\tI2C_ReceiveAck();\tI2C_Stop();&#125;/** * @brief AT24C02读取一个字节 * @param WordAddress 要读出字节的地址 * @retval 读出的数据 */unsigned char AT24C02_ReadByte(unsigned char WordAddress)&#123;\tunsigned char Data;\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS);\tI2C_ReceiveAck();\tI2C_SendByte(WordAddress);\tI2C_ReceiveAck();\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS|0x01);\tI2C_ReceiveAck();\tData=I2C_ReceiveByte();\tI2C_SendAck(1);\tI2C_Stop();\treturn Data;&#125; 实验验证4路OLED的驱动基于I2C通信的陀螺仪","tags":["单片机"]},{"title":"复变函数与积分变换","path":"/2023/12/15/复变函数与积分变换/","content":"马上就要考试了，悲 复数与复变函数复数的三种形式 复数的一般形式 $Z&#x3D;x+yi$ 复数的三角表示 $Z&#x3D;r(\\cos\\theta+j\\sin\\theta)$ 复数的指数形式 $Z&#x3D;re^{i\\theta}$ 复数的主值与辐值$$ArgZ &#x3D; argZ + 2k\\pi$$其中 $0 \\leq argZ&lt;2\\pi$ 主值的求解公式 棣莫弗公式 ★$$Z^n&#x3D;[r(\\cos\\theta+i\\sin\\theta)]^n&#x3D;r^n(\\cos{n\\theta}+\\sin{n\\theta})&#x3D;re^{in\\theta}$$当r&#x3D;1时，有$$(\\cos\\theta+i\\sin\\theta)^n&#x3D;\\cos{n\\theta}+\\sin{n\\theta}$$逆运用$$w&#x3D;r^{\\frac{1}{n}}[\\cos(\\frac{1}{n}(\\theta+2k\\pi))+i\\sin(\\frac{1}{n}(\\theta+2k\\pi))]$$ 其中$k&#x3D;0,1,2,…,n-1$$r&#x3D;|Z|$ 练习共轭复数$ReZ&#x3D;\\frac{Z+\\overline{Z}}{2}$$ImZ&#x3D;\\frac{Z-\\overline{Z}}{2i}$ 解析函数解析函数：概念性质、充分&#x2F;必要条件、调和函数、初等函数 解析概念：$w&#x3D;f(Z)$如果在$Z_{0}$及其领域内处处可导，则$f(Z)$在$Z_{0}$处解析解析-&gt;可导-&gt;连续反之不行 函数解析的充要条件（柯西-黎曼方程）C-R方程$f(z)&#x3D;u(x,y)+iv(x,y)$在$z&#x3D;x+iy$处处可导的充要条件是$u(x,y)$，$v(x,y)$在点$(x,y)$处可微$$\\frac{\\partial u}{\\partial x}&#x3D;\\frac{\\partial v}{\\partial y}且\\frac{\\partial u}{\\partial y}&#x3D;-\\frac{\\partial v}{\\partial x}$$ 调和函数调和函数和解析函数针对的对象不同解析函数针对$f(Z)$调和函数针对$u(x,y)与v(x,y)$ 拉普拉斯方程（Laplace）$$\\frac{\\partial^{2} \\varphi}{\\partial^{2}x}+ \\frac{\\partial^{2} \\varphi}{\\partial^{2}y}&#x3D;0$$解析函数的实部和虚部是调和函数 初等函数指数函数$$e^{Z}&#x3D;e^{x+iy}&#x3D;e^{x}(\\cos x +i\\sin y)$$指数函数性质有： $ |e^{Z}|&#x3D;e^{x}$ $Arg(e^{Z})&#x3D;y+2k\\pi$ $e^{Z+i2k\\pi}&#x3D;e^{Z}，即e^{Z}是以2k\\pi 为周期的周期函数$ $(e^{Z})’&#x3D;e^{Z}$ 对数函数$LnZ&#x3D;lnZ+i2k\\pi&#x3D;ln|Z|+iargZ+i2k\\pi$ 幂函数$a^{b}&#x3D;e^{(Lna)b}$ 三角函数 反三角函数 练习复变函数的积分定义及如何积分定义在简单光滑或分段光滑上的有向曲线上的积分$$f(Z)&#x3D;u(x,y)+iv(x,y)$$$$f_{c}(Z)dZ$$如何积分？两种方法 第二型曲线积分$$\\int_{c}(Z)dZ&#x3D;\\int_{c}u(x,y)+iv(x,y)dZ&#x3D;\\int_{c}udx-vdy+i\\int_{c}vdx+udy$$ 参数法$$\\int_{c}(Z)dZ&#x3D;\\int^{\\beta}_{\\alpha}f(Z(t))Z’(t)dt$$ 柯西-古萨定理$$\\oint_{c}f(Z)dZ&#x3D;0$$$f(Z)$在C上及D内解析则成立 复合闭路定理推导$f(Z)$在$\\Gamma$上解析，且$\\Gamma&#x3D;C+C^{-}{1}+C^{-}{2}$+…，则$\\oint_{\\Gamma}f(Z)dZ&#x3D;0$，代入$\\Gamma &#x3D;C+C^{-}{1}+C^{-}{2}$+…则$\\oint_{C+C^{-}{1}+C^{-}{2}+…}f(Z)dZ&#x3D;0$ 化简移项可得 $$\\oint_{c}f(Z)dZ&#x3D; \\sum_{n&#x3D;1}^n\\oint_{C_{k}}f(Z)dZ$$当k&#x3D;1时，则得 $$\\oint_{c}f(Z)dZ&#x3D; \\oint_{k}f(Z)dZ$$ 柯西积分公式 ★适用条件：$f(Z)$要在C上及其内部解析$$\\oint_{c}\\frac{f(Z)}{Z-Z_{0}}dZ&#x3D; 2\\pi if(Z_{0})$$高阶$$\\oint_{c}\\frac{f(Z)}{(Z-Z_{0})^{n-1}}dZ&#x3D; \\frac{2\\pi i}{n!} f(Z_{0})$$ 级数(研究其敛散性)级数的一些性质$\\sum_{n&#x3D;1}^n|Z|$收敛，则$\\sum_{n&#x3D;1}^nZ$也收敛 $\\sum_{n&#x3D;1}^n\\frac{1}{n}$是发散的 复数序列$Z_{1}&#x3D;a_{1}+b_{1}i$，$Z_{2}&#x3D;a_{2}+b_{2}i$，…$Z_{n}&#x3D;a_{n}+b_{n}i$，…上面的序列，简记为$${Z_{n}}$$ 项级数如何判断一个项级数是收敛还是发散的呢？部分和判断部分和为$$S_{n}&#x3D;Z_{1}+Z_{2}+…Z_{n}$$部分和序列$${S_{n}}&#x3D;S_{1}+S_{2}+…S_{n}$$ 幂级数 ★形式和收敛半径要记住，收敛半径的求法，比值法和根值法。其级数在其收敛半径内部绝对收敛，在其收敛半径上不一定。 幂级数和函数性质2的应用 幂级数的运算（加减乘除）对应题型，将函数展开为Z的幂级数（不熟练） 泰勒级数常见泰勒展开泰勒展开的形式 洛朗级数洛朗级数&#x3D;负幂项+正幂项洛朗级数是收敛圆环题型 求收敛圆环的半径 展开为洛朗级数负幂项的收敛半径按正幂项求，最后取倒数。 留数及其应用奇点及奇点的分类及求法 孤立奇点（洛朗展开仅有正幂项） n阶极点（有负幂项，部分为0） 本性奇点（洛朗展开既有正幂项，又有负幂项） 零点及m阶零点零点和极点的关系 留数定义计算 ★一阶极点的留数的快速求法","tags":["课程"]},{"title":"爬虫入门","path":"/2023/12/14/爬虫入门/","content":"爬虫简介爬虫的概念通过编写程序，模拟浏览器上网，然后让其抓取数据的过程 爬虫分类 通用爬虫（整张页面） 聚焦爬虫（局部内容） 增量式爬虫（抓取更新内容） 爬虫的矛与盾 爬虫 反爬机制 反反爬策略 robots.txt协议君子协议，规定可爬取，不可爬取网址后面加&#x2F;robots.txt 即可访问 http协议 概念：服务器与客户端进行数据交互的一种形式 常用请求头信息 User-Agent:请求载体的身份标识 Connection:请求完毕后，是断开连接还是保持连接 常用响应头信息 Content-Type: 服务器响应回客户端的数据类型 https协议:安全的超文本传输协议 加密方式 对称秘钥加密 非对称秘钥加密 证书秘钥加密 requests请求requests模块: python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 作用:模拟浏览器发请求。 如何使用: (requests模块的编码流程) 指定urT 发起请求 获取响应数据 持久化存储环境安装:pip install requests 实战编码:需求: 爬取搜狗首页的页面数据1234567891011121314import requestsif __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/&#x27; # 发起请求 response = requests.get(url=url) # 获取响应数据,text返回的是字符串 page_text = response.text print(page_text) # 持久化存储 with open(&quot;./sogou.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://blog.csdn.net/m0_46778548/article/details/121201868Python文件读写操作 https://blog.csdn.net/qiqicos/article/details/79200089python 里with… as.. 的操作方法 需求: 爬取搜狗指定头条学习点UA伪装 123456789101112131415161718192021222324252627import requests#UA:User-Agent.(请求载体的身份标识)# UA检测门户网站的服务器会检测对应请求的载体身份标识,不正常则服务器端就很有可能拒绝该次请求# UA伪装if __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/web&#x27; # UA伪装:将对应的User-Agent封装到一个完典中 headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0&#x27;&#125; # 处理参数并字典封装 ws = input(&quot;Please enter a word:&quot;) param = &#123;&#x27;query&#x27;: ws&#125; # 对指定的url发起的请求对应的urL是携带参数的，并且请求过程中处理了参数 response = requests.get(url=url, params=param, headers=headers) # 持久化存储 page_text = response.text print(page_text) with open(&quot;./&quot;+ws+&quot;.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://www.runoob.com/python3/python-requests.htmlrequest模块详解","tags":["python"]},{"title":"基于树莓派上位机与arduino下位机实现键盘控制","path":"/2023/12/14/基于树莓派上位机与arduino下位机实现键盘控制/","content":"实现键盘控制小车行驶 下位机代码，Arduino的5号引脚为电机引脚，9号引脚为舵机引脚 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;Servo.h&gt; Servo myservo;String str;int pos = 92; //舵机角度int motor_pwm = 100; //电机数值0 ~255int pos_mid = 92; // 储存舵机中值角度int motorPin = 5; // 确定motor控制引脚int servoPin = 9; //确定servo控制引脚 void setup() &#123; Serial.begin(115200); myservo.attach(servoPin); // 该舵机由arduino第9脚控制 pinMode(motorPin, OUTPUT); // 将电机引脚设为输出模式 myservo.write(pos_mid); // 舵机复位 analogWrite(motorPin,0); // 电机初始转动 delay(1000);&#125; void loop() &#123; if (Serial.available() &gt;= 2) &#123; int servoValue = Serial.read(); int motorValue = Serial.read(); // 控制舵机 myservo.write(servoValue); if (servoValue &lt;40) servoValue=40; else if(servoValue &gt; 140) servoValue=140; Serial.print(&quot;servo: &quot;); Serial.println(servoValue); // 控制电机 if (motorValue &lt;0) motorValue=0; else if(motorValue &gt; 255) motorValue=255; analogWrite(motorPin, motorValue); Serial.print(&quot;motor: &quot;); Serial.println(motorValue); &#125; &#125; 上位机代码文件名 key_control.py 123456789101112131415161718192021222324252627282930313233343536373839404142# Author: 无忧# Date: 2023-12-02# Description: 这是一个键盘控制的简单代码# 请调节键盘状态为英语小写状态# -------------------- import keyboardimport time# 要下包keyboardfrom send_M_S import * speed = 0speed_max = 60 # 速度的最大值turn = 92 # 舵机中值turn_l = 60 # 舵机打角最左turn_r = 120 # 舵机打角最右 if __name__ == &quot;__main__&quot;: ser = init_send() while True: try: if keyboard.is_pressed(&#x27;w&#x27;): speed += 5 if speed &gt;= speed_max: speed = speed_max elif keyboard.is_pressed(&#x27;a&#x27;): turn -= 8 if turn &lt;= turn_l: turn = turn_l elif keyboard.is_pressed(&#x27;d&#x27;): turn += 8 if turn &gt;= turn_r: turn = turn_r elif keyboard.is_pressed(&#x27;s&#x27;): speed -= 5 if speed &lt;= 0: speed = 0 time.sleep(0.1) # 系统响应速度 send_values(ser, turn, speed) except KeyboardInterrupt: break 上位机串口代码文件名send_M_S 123456789101112131415161718192021222324252627282930313233# Author:# Date: 2023-12-02# Description: This script does XYZ.import serialimport timeimport sys # 设置串口参数def init_send(): ser = serial.Serial(&#x27;COM4&#x27;, 115200, timeout=1) return ser def send_values(ser, servo_value, motor_value): # 向串口发送舵机值和电机值 time.sleep(0.1) ser.write(bytes([servo_value, motor_value])) while ser.in_waiting: arduino_feedback = ser.readline().decode() print(&quot;Arduino:&quot;, arduino_feedback) if __name__ == &#x27;__main__&#x27;: # 初始化串口 ser = init_send() try: while True: for i in range(60, 120, 1): send_values(ser, i, 50) for i in range(120, 60, -1): send_values(ser, i, 50) except KeyboardInterrupt: # 在用户按下 Ctrl+C 时，关闭串口并退出程序 ser.close() sys.exit()","tags":["arduino"]},{"title":"电路复习","path":"/2023/11/14/电路复习/","content":"写在前面的话我打算尝试一下，用markdown，部署到网页进行电路的学习与记录困难点来自两1.多图片，图床问题2.多数学公式 这是一次有意义的探索，一次尝试 电路的简化电压源串联电流源并联电压源与电流源的串联相当与电流源 电压源与电流源的并联相当与电压源 电流源的内阻为无穷大 电压源与电流源的转化$\\Delta$与Y的等效变换$\\Delta$ -&gt; Y $$Y型电阻 &#x3D; \\frac{\\Delta相邻电阻乘积}{\\Delta电阻之和}$$Y -&gt; $\\Delta$$$\\Delta型电阻 &#x3D; \\frac{Y型电阻两两乘积之和}{Y型不相邻电阻}$$相同阻值情况下，3Y&#x3D;$\\Delta$ 电源置零独立电压源短路，独立电流源断路 独立源与受控源受控源 vcvc 电压控制的电压源 vccs 电压控制的电流源 ccvs 电流控制的电压源 cccs 电流控制的电流源 voltage 电压 current 电流 control控制 source源 输入电阻无源一端口网络的等效变换，无源指的是无独立电源简而言之，一个不含独立源的一端口网路，等效为一个电阻$R_{eq}$输入电阻求法 外加电源法 建议外加电压源$$R_{eq} &#x3D; \\frac{u}{i}$$注意，在存在受控源的情况下，R可能为负。 【大学电路习题讲解——求输入电阻1】 【精准空降到 00:19】 https://www.bilibili.com/video/BV1z7411W72Z/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6&amp;t=19 三种电流方法基本概念 结点(n) 支路(b) 网孔 网孔数&#x3D;独立回路数 支路电流法（基本用不到） 找出支路数(b)，找出结点数(n) 列n-1个KCL方程 列b-n+1个KVL方程 联立求解 回路电流法 找出b-n+1个回路 列方程求解 $$R_{11}i_{1}+R_{12}i_{2}+… &#x3D; u_{11}$$$$R_{21}i_{1}+R_{22}i_{2}+… &#x3D; u_{22}$$$$R_{31}i_{1}+R_{32}i_{2}+… &#x3D; u_{22}$$$$……$$$$R_{n1}i_{1}+R_{n2}i_{2}+… &#x3D; u_{22}$$ 其中，$R_{11}$…$R_{nn}$为回路n的电阻之和$R_{21}$&#x3D;$R_{12}$为回路1，2共有的电阻(方向相同则为正)$u_{11}$回路1所有电压源之和，指定电流由“+” -&gt; “—”取负，反之 结点电压 找出所有结点，选取待测相关的一个结点为0，其他分别为1，2，… 将与电流源串联的电阻变导线，与电压源并联的电阻变短路 列方程求解$$G_{11}u_{n1}+G_{12}u_{n2}+… &#x3D; i_{s11}$$$$G_{21}u_{n1}+G_{22}u_{n2}+… &#x3D; i_{s22}$$$$G_{31}u_{n1}+G_{32}u_{n2}+… &#x3D; i_{s33}$$ 其中，$i_{s11}$&#x3D;$\\frac{电压源}{所在支路电阻}+电流源$，流入结点为正，流出为负 例题精讲（待补充）电路原理叠加定理 https://www.bilibili.com/video/BV1HF411W7L9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=755a0f899976f771c7923daed9448d48 表述：在线性电阻电路中，某处电压或电流都是各个独立电源单独作用时，电压与电流的叠加 注意： 某电源作用时，其他独立源置零 受控源不置零 线性电路 可设置0电压的点，即接地 替换定理简述：任何一个支路（端口）已知电压或电流，就可以将该支路（端口）用电压源或电流源替代。既可以线性电路，也可以非线性 适用条件及其注意点不要把受控源的控制量替换掉 戴维南定理（等效电压源定理）简述：将一个二端网路，等效为一个电压源串联一个等效电阻。注意开路，开路！！步骤： 剥离待求项，将原电路化为开路二端网络，求U, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电压源串联一个等效电阻 诺顿定理（等效电流源定理）简述：将一个二端网路，等效为一个电流源并联一个等效电阻。 剥离待求项，将原电路d待求项短接，求I, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电流源并联一个等效电阻 戴维宁求谁断路谁，诺顿求谁断路谁，然后电源置零，用外加电压法$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$，求输入电阻 储能元件电容（电流记忆元件）VCR为$$i &#x3D; C\\frac{ d_{u}}{d_{t}}$$ 电感（电压记忆元件）VCR为$$u&#x3D; L\\frac{ d_{i}}{d_{t}}$$ 电容与电感的串并联电容的串并联与电阻相反电感的串并联与电阻类似 RC电路与RL电路的响应$$U_{c}&#x3D;U_{c}(\\infty)+[U_{c}(0_{+})-U_{c}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;RC)$$1.电容断路，求$U_{c}(\\infty)$和$U_{c}(0_{+})$，求变化前后稳定时的电压。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电容断路，求输入电阻3.代入求解 $$I_{L}&#x3D;I_{L}(\\infty)+[I_{L}(0_{+})-I_{L}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;R&#x2F;L)$$1.电感短路路，求$I_{L}(\\infty)$和$I_{L}(0_{+})$，求变化前后稳定时的电流。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电感断路，求输入电阻3.代入求解 补充$$U(t)&#x3D;U(t_{0})+\\frac{1}{C}\\int_{t_{0}}^tI_{t}d\\xi$$$$I(t)&#x3D;I(t_{0})+\\frac{1}{L}\\int_{t_{0}}^tu_{t}d\\xi$$ 一阶电路与二阶电路的时域分析零输入响应（无电源）零状态响应（未充能）全响应（有电源且电容已充能）向量法复数的三种形式$$F&#x3D;|F|(\\cos\\theta+j\\sin\\theta)&#x3D;a+jb$$$$F&#x3D;|F|e^{j\\theta}$$$$F&#x3D;|F|\\angle\\theta$$ 欧拉公式$$e^{j\\theta}&#x3D;(\\cos\\theta+j\\sin\\theta)$$$$e^{j\\pi}+1&#x3D;0$$ 正弦量$$u&#x3D;U_{max}\\cos(wt+\\psi)&#x3D;\\sqrt{2}V\\cos(wt+\\psi)&#x3D;V\\angle\\theta$$注意，向量法表述时为有效值 https://zhuanlan.zhihu.com/p/110148728 电路定理的向量形式基尔霍夫定律$$\\Sigma i(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{I}(t)&#x3D;0$$$$\\Sigma u(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{U}(t)&#x3D;0$$ 电路元件的向量关系$$u&#x3D;Ri \\rightleftarrows \\dot{U}&#x3D;R\\dot{I}$$$$u&#x3D; L\\frac{ d_{i}}{d_{t}} \\rightleftarrows \\dot{U}&#x3D;jwL\\dot{I}$$$$u&#x3D;\\frac{1}{C}\\int idt \\rightleftarrows \\dot{U}&#x3D;\\frac{1}{jwC}\\dot{I}&#x3D;-j\\frac{1}{wC}\\dot{I}$$","tags":["课程"]},{"title":"numpy库的学习","path":"/2023/10/24/numpy库的学习/","content":"参考资料 https://www.runoob.com/numpy/numpy-tutorial.html 线性代数基础概念理解线性代数的概念忘了，这里补一补 https://zhuanlan.zhihu.com/p/422251943 numpyNumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C&#x2F;C++&#x2F;Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能","tags":["python"]},{"title":"python的os库的使用","path":"/2023/10/22/python的os库的使用/","content":"参考资料 https://blog.csdn.net/m0_55697123/article/details/119464001 https://blog.csdn.net/wulishinian/article/details/106420532 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport time# print(os.system(&#x27;C:\\\\Windows\\\\System32\\\\calc.exe&#x27;))print(os.name) # linux 显示posixprint(os.environ) # 环境变量# windows \\ , linux /# 常用系统相关变量，sep分隔符print(os.sep)print(os.pathsep)print(os.linesep)# 文件和目录操作# os.mkdir(&quot;test&quot;) # 在当前路径下创建目录# os.rmdir(&quot;test&quot;) # delete目录# os.remove(&quot;文件名&quot;) #delete文件print(os.getcwd()) # 打印当前目录# os的子模块 os.pathfile = os.getcwd()+&quot;/main.py&quot;print(os.path.split(file)) # 分割文件名和路径mkdir, filename = os.path.split(file)print(filename)# 判断绝对路径与相对路径print(os.path.isabs(file)) # 是绝对，则返回TRUE# 判断文件或目录是否存在print(os.path.exists(file))# 拿到目录或文件最后修改时间，开始创建时间print(os.path.getatime(file)) # 显示时间戳print(os.path.getctime(file)) #print(os.path.getsize(file)) # 拿到文件大小,字节# 执行命令# os system popen 不推荐使用 执行结果 1234567891011121314151617181920ntenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming&#x27;, &#x27;COMMONPROGRAMFILES&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMMONPROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)\\\\Common Files&#x27;, &#x27;COMMONPROGRAMW6432&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMPUTERNAME&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;COMSPEC&#x27;: &#x27;C:\\\\Windows\\\\system32\\\\cmd.exe&#x27;, &#x27;DRIVERDATA&#x27;: &#x27;C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData&#x27;, &#x27;HOMEDRIVE&#x27;: &#x27;C:&#x27;, &#x27;HOMEPATH&#x27;: &#x27;\\\\Users\\\\Windows&#x27;, &#x27;IDEA_INITIAL_DIRECTORY&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\Desktop&#x27;, &#x27;LOCALAPPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local&#x27;, &#x27;LOGONSERVER&#x27;: &#x27;\\\\\\\\DESKTOP-0R6DJK5&#x27;, &#x27;NUMBER_OF_PROCESSORS&#x27;: &#x27;4&#x27;, &#x27;ONEDRIVE&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;ONEDRIVECONSUMER&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;OS&#x27;: &#x27;Windows_NT&#x27;, &#x27;PATH&#x27;: &#x27;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\ odejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Scripts\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming\\ pm;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PATHEXT&#x27;: &#x27;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#x27;, &#x27;PROCESSOR_ARCHITECTURE&#x27;: &#x27;AMD64&#x27;, &#x27;PROCESSOR_IDENTIFIER&#x27;: &#x27;Intel64 Family 6 Model 78 Stepping 3, GenuineIntel&#x27;, &#x27;PROCESSOR_LEVEL&#x27;: &#x27;6&#x27;, &#x27;PROCESSOR_REVISION&#x27;: &#x27;4e03&#x27;, &#x27;PROGRAMDATA&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;PROGRAMFILES&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)&#x27;, &#x27;PROGRAMW6432&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PSMODULEPATH&#x27;: &#x27;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules&#x27;, &#x27;PUBLIC&#x27;: &#x27;C:\\\\Users\\\\Public&#x27;, &#x27;PYCHARM&#x27;: &#x27;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PYCHARM_DISPLAY_PORT&#x27;: &#x27;63342&#x27;, &#x27;PYCHARM_HOSTED&#x27;: &#x27;1&#x27;, &#x27;PYTHONIOENCODING&#x27;: &#x27;UTF-8&#x27;, &#x27;PYTHONPATH&#x27;: &#x27;D:\\\\opencv_study;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_matplotlib_backend;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_display&#x27;, &#x27;PYTHONUNBUFFERED&#x27;: &#x27;1&#x27;, &#x27;SESSIONNAME&#x27;: &#x27;Console&#x27;, &#x27;SYSTEMDRIVE&#x27;: &#x27;C:&#x27;, &#x27;SYSTEMROOT&#x27;: &#x27;C:\\\\Windows&#x27;, &#x27;TEMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;TMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;USERDOMAIN&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERDOMAIN_ROAMINGPROFILE&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERNAME&#x27;: &#x27;Windows&#x27;, &#x27;USERPROFILE&#x27;: &#x27;C:\\\\Users\\\\Windows&#x27;, &#x27;WINDIR&#x27;: &#x27;C:\\\\Windows&#x27;&#125;)\\;D:\\opencv_study(&#x27;D:\\\\opencv_study&#x27;, &#x27;main.py&#x27;)main.pyTrueTrue1697922899.98245931697807194.7697878986Process finished with exit code 0 python文件打开新的终端，并执行文件linux 环境在写Python程序的时候遇到需要打开一个新的终端(terminal)或者说命令行窗口进行监视的情况 12345import osos.system(&quot;gnome-terminal -e &#x27;ls&#x27;&quot;) # 窗口执行后关闭os.system(&quot;gnome-terminal -e &#x27;bash -c \\&quot;ls; exec bash\\&quot;&#x27;&quot;) # 窗口执行后不关闭# 其中 &#x27;ls&#x27; 部分即为所需执行的内容。 Windows环境1234import osos.system(&quot;start powershell.exe cmd /k &#x27;dir&#x27;&quot;)# 其中 &#x27;dir&#x27; 部分即为所需执行的内容","tags":["python"]},{"title":"opencv學習","path":"/2023/10/19/opencv學習/","content":"参考资料 https://www.bilibili.com/video/BV1ET4y127vd/?spm_id_from=333.999.0.0&amp;vd_source=755a0f899976f771c7923daed9448d48 https://opencv.apachecn.org/ opencv简介是什么？计算机视觉开源软件库 numpy opencv-python的安装打开cmd输入 123pip install opencv-pythonpip install opencv-contrib-python 开梯子下载更快 测试代码 123456import cv2# 读一个图片并进行显示(图片路径需自己指定)lena=cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, lena) # 打开新窗口，窗口名为image,显示Lenacv2.waitKey(0) opencv模块其中core、highgui、imgproc是最基础的模块，该课程主要是围绕这几个模块展开的，分别介绍如下: core模块实现了最核心的数据结构及其基本运算，如绘图函数、数组操作相关函数等 highgui模块实现了视频与图像的读取、显示、存储等接口。 imgproc模块实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、闻值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。 其他 features2d模块用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。obidetect模块实现了一些目标检测的功能，经典的基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification (级联分类)和Latent SVM等。 stitching模块实现了图像拼接功能。 FLANN模块 (Fast Library for Approximate Nearest Neighbors)，包含快速近似最近搜索FLANN和聚类Clustering算法。 ml模块机器学习模块 (SVM，决策树，Boosting等等) photo模块包含图像修复和图像去噪两部分。 video模块针对视频处理，如背景分离，前景检测、对象跟踪等。 calib3d模块即Calibration (校准)3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。G-API模块包含超高效的图像处理pipeline引擎 图像的基础操作 掌握图像的读取和保存方法 能够使用OpenCV在图像上绘制几何图形 能够访问图像的像素 能够获取图像的属性，并进行通道的分离和合并0 能够实现颜色空间的变换 读取图像1cv.imread(&quot;路径&quot;) cv.IMREAD*COLOR:以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。 cv.IMREAD*GRAYSCALE: 以灰度模式加载图像 Cv.IMREAD UNCHANGED: 包括alpha通道的加载图像模式。可以使用1、0或者-1来替代上面三个标志12345678import numpy as npimport cv2#以灰度图的形式读取图像img = cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, img)cv2.waitKey(0) 注意:如果加载的路径有错误，不会报错，会返回一个None值 显示图像1cv.imshow(&quot;窗口名&quot;， 图片) 注意:在调用显示图像的API后，要调用cv.waitKey()&#x2F;&#x2F;等待键盘输入 给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来。waitkey(0)，永远等待另外我们也可使用matplotlib对图像进行展示。 保存图像1cv.imwrite(&quot;文件名&quot;， 图片变量) 总结： 12345678910import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt#读取图像img = cv.imread(&#x27;1.png&#x27;,1)# 利用opencv展示图像cv.imshow( &#x27; image&#x27;, img)k = cv.waitKey(0)# 3 保存图像cv.imwrite( &#x27;messigray.png&#x27;,img) course_1code123456789101112131415161718192021222324252627# 学习了基本操作，imread(), imwrite()等import cv2 as cv# 获取摄像头cap = cv.VideoCapture(0)# set the height(3) and width(4) of the windows# windows系统下，微软surface的系统摄像头，该设置失效，原因未明# 外置摄像头OKcap.set(3, 640)cap.set(4, 480)# set brightness# 但好像也没什么用cap.set(10, 0.00001)while True: success, img = cap.read() cv.imshow(&quot;camera&quot;, img) if cv.waitKey(1) == ord(&#x27;Q&#x27;) or cv.waitKey(1) == 27: # 当所有事完成，释放 VideoCapture 对象 cap.release() cv.destroyAllWindows() break 详解1234cap = cv.VideoCapture(2)VideoCapture()中参数是0，表示打开笔记本的内置摄像头，参数是视频文件路径，打开方式如下：cap = cv2.VideoCapture(“../test.avi”) 12success, img = cap.read()cap.read()按帧读取视频，ret,frame是获cap.read()方法的两个返回值。 其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就为False。frame就是每一帧的图像，是个三维矩阵。 1234waitKey（）方法本身表示等待键盘输入，参数是1，表示延时1ms切换到下一帧图像。对于视频而言；参数为0，如cv2.waitKey(0)只显示当前帧图像，相当于视频暂停；参数过大如cv2.waitKey(1000)，会因为延时过久而卡顿感觉到卡顿。c得到的是键盘输入的ASCII码，esc键对应的ASCII码是27，即当按esc键是if条件句成立 course_2code1234567891011121314151617181920212223242526272829303132333435import cv2 as cvimport numpy as npaaa = np.ones((5, 5), np.uint8)# cv.imread(&quot;路径&quot;， 参数)，参数不传，默认参数1img = cv.imread(&quot;img/1 (1).jpg&quot;)# cv2.namedWindow(‘窗口标题’,默认参数) 创建新窗口cv.namedWindow(&#x27;Local Camera&#x27;, 0)# 设置显示的窗口大小为500,500，建议大于等于摄像头分辨率cv.resizeWindow(&quot;Local Camera&quot;, 300, 300)cv.imshow(&quot;Local Camera&quot;, img)# 灰度图片imgGray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)cv.imshow(&quot;show imgGray&quot;, imgGray)# 高斯模糊imgBlur = cv.GaussianBlur(img, (7, 7), 0)cv.imshow(&quot;show imgBlur&quot;, imgBlur)# 边缘检测imgCanny = cv.Canny(img, 150, 200)cv.imshow(&quot;show imgCanny&quot;, imgCanny)# 膨胀imgDilation = cv.dilate(imgCanny, aaa, iterations=1)cv.imshow(&quot;show imgDilation&quot;, imgDilation)# 腐蚀imgErode = cv.erode(imgDilation, aaa, iterations=1)cv.imshow(&quot;show imgErode&quot;, imgErode)cv.waitKey(0) course_3学习图像像素查看，图片大小调整，图片裁剪 opencv的X,Y的位置 code12345678910111213141516171819202122232425import cv2 as cvimport numpy as npimg = cv.imread(&quot;img/1 (1).jpg&quot;)print(img.shape)print(img.shape[0])# 打印出(1526, 1080, 3)# 打印出的分别是，高，宽，BGR# 图像大小调整，参数为宽，高a = int(img.shape[1]*0.3)b = int(img.shape[0]*0.3)imgResize = cv.resize(img, (a, b))print(imgResize.shape)# 图像裁剪 高与宽imgCropped = img[0:400, 200:400]cv.imshow(&quot;LOCAL img&quot;, img)cv.imshow(&quot;LOCAL imgResize&quot;, imgResize)cv.imshow(&quot;LOCAL imgCropped&quot;, imgCropped)cv.waitKey(0) course_4 绘画12345678910111213141516171819202122import cv2 as cvimport numpy as np# 0为黑，1为白img = np.zeros((400, 400))img1 = np.zeros((400, 400, 3))imgBlue = img1.copy() # 令imgBlub = img，则会报错，img为二维数组，只有黑白imgBlue[:] = 255, 0, 0# 划线，参数1,图片，参数2，起始点,参数3，终止点，参数4，color 参数5，厚度cv.line(img1, (0, 0), (400, 250), (255, 255, 255), 1)# 画矩形，参数配置同上,参数5也可用cv.FILLED,填充cv.rectangle(img1, (0, 0), (400, 200), (255, 255, 0), 2)# 画圆cv.circle(img1, (200, 70), 30, (255, 255, 100), cv.FILLED)cv.imshow(&quot;img&quot;, img)cv.imshow(&quot;img2&quot;, img1)cv.imshow(&quot;imgBlue&quot;, imgBlue)cv.waitKey(0) course_5 透视变换12345678910111213141516import cv2 as cvimport numpy as np# 矩阵变换width, height = 250, 350img = cv.imread(&quot;img/1 (15).png&quot;)pts1 = np.float32([[108, 240], [276, 209], [150, 491], [342, 451]])pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])matrix = cv.getPerspectiveTransform(pts1, pts2) # 获得透视矩阵out_img = cv.warpPerspective(img, matrix, (width, height)) # 透视cv.imshow(&quot;local img&quot;, img)cv.imshow(&quot;out_img img&quot;, out_img)cv.waitKey(0) 解析cv2.getPerspectiveTransform()是一个OpenCV函数，用于获取透视变换矩阵。它需要两个参数，分别是源图像中待测矩形的四点坐标和目标图像中矩形的四点坐标。它返回一个3x3的变换矩阵，可以用于cv2.warpPerspective()函数进行透视变换。 1234567891011121314import cv2import numpy as np# 定义源图像中待测矩形的四点坐标pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])# 定义目标图像中矩形的四点坐标pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])# 获取透视变换矩阵M = cv2.getPerspectiveTransform(pts1, pts2)# 输出变换矩阵print(M) 输出为 123[[ 8.24482681e-01 -1.02318154e-01 -3.33674687e+01] [ 1.18180922e-01 9.43895645e-01 1.17818491e+01] [ 1.65498408e-04 -1.69338403e-04 1.00000000e+00]] warpPerspective()函数主要作用：对图像进行透视变换，就是变形cv.warpPerspective是OpenCV中的一个函数，主要用于对图像进行透视变换。它可以将原始图像中的任意四边形区域转换为目标图像中的矩形区域，从而实现图像的透视变换。该函数的语法如下： 1dst = cv.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) 其中，参数含义如下：src：输入图像，可以是8位无符号整数、32位浮点数或16位有符号整数。M：3x3变换矩阵。dsize：输出图像的大小。dst：输出图像，与输入图像具有相同的数据类型和通道数。flags：插值方法的标志，可以是cv2.INTER_NEAREST、cv2.INTER_LINEAR、cv2.INTER_CUBIC、cv2.INTER_AREA、cv2.INTER_LANCZOS4等。borderMode：边界填充模式，可以是cv2.BORDER_CONSTANT、cv2.BORDER_REPLICATE、cv2.BORDER_REFLECT、cv2.BORDER_WRAP等.borderValue：边界填充值。","tags":["opencv"]},{"title":"linux系统学习","path":"/2023/10/10/linux系统学习/","content":"计算机硬件结构冯 诺依曼结构 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 其他主流计算机硬件结构 哈佛体系 计算机之父 冯 诺依曼图灵 计算机硬件组成输入设备输出设备存储器RAMRAM(random access memory) 即随机存储内存 速度快，容量小 掉电易失 逻辑IO ROMROM (Read-Onboy Memory) 即只读内存硬盘 容量大，速度相对较慢 长久保存 物理10 运算器、控制器网络连接 ip地址 子网掩码 默认网关 DNS ip地址IPADDRip地址 &#x3D; 网络地址+主机地址ip地址是一个4*8bit由0&#x2F;1组成的字符串（ip4协议） 子网掩码","tags":["linux"]},{"title":"gazebo的学习与应用","path":"/2023/09/26/gazebo的学习与应用/","content":"学习目标与任务 Gazebo和环境模型设计 机器人模型设计 为模型上装备传感器与执行器 https://gazebosim.org/docs","tags":["ros"]},{"title":"基于古月居的ros入门","path":"/2023/09/21/基于古月居的ros入门/","content":"前言由于前段时间的学习总结的习惯不好，决定新开一栏用于ros基础学习。有一说一，通过和学长的进度比较，总感觉自己是个废物。 虚拟机的安装不要装机械盘，运行慢。使用VMwareubantu系统18 linux基本命令行123456789101112cdlsmvrm -rcppwdmkdirtouchshutdown -h nowrebootsudo 基本命令行12sudo apt-get update //更新源source ~/catkin_ws/devel/setup.bash //刷新环境变量 前置安装123456789//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim//ros安装wget http://fishros.com/install -O fishros &amp;&amp; . fishros ros的核心概念节点（node）与节点管理器（ros master）节点名称唯一 话题(topic)与服务(serve) 话题：单向 发布者 订阅者 消息(massage):话题的数据由.msg文件定义 服务：双向 客户端 服务端 .srv文件定义命名请求应答数据 参数(parameter)—全局共享字典适合静态，非二进制的配置参数 文件系统 功能包（package） ：含节点源码，配置文件，数据定义 功能包清单： 作者信息，许可信息，依赖选项 元功能包：组织多个同一目的的功能包 ros命令行工具123456rostopicrosservicerosnoderosparamrosmsgrossrv 小海龟123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 工具123456789rqt_graph //节点可视化rosnode //显示节点rostopic //话题 pubrosmsgrosservice //服务 callrosbag record -a -O cmd_record //话题记录 cmd_record位保存文件名，默认hom目录下rosbag play cmd_record.bag //话题复现 ros的文件结构 1234567891011121314151617181920212223242526272829303132WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 创建工作空间123456789101112131415//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_makecatkin_make install //可要可不要//设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash 问题：我需要在原有的ROS工程基础之上，新建一个ROS功能包。我直接复制了其他目录下原有的一个包，进行修改。然后问题来了：catkin_make后竟然没有反应。甚至没有检测到我新改写的cmake 解决：ros允许多个工作空间使用相同功能包，但多个工作空间source不要放在脚本里，手动敲，否则会被覆盖,在catkin_make之前source一下，之后再source一下。而且要多次执行，如下。注意要先开下roscore，py文件要给其可执行权限. 123456//将文件复制过来后，在工作空间目录下打开终端source ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bash 脚本文件的source只在新的终端开启时才运行 发布者与订阅者以海龟为例 python文件要记得给可执行权限 发布者123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher():\t# ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True)\t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)\t#设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 订阅者123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber():\t# ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True)\t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)\t# 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 消息的自定义定义msg文件在功能包的src同级目录下创建msg文件夹12345678910// 举例，该文件名为Person.msgstring nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 launch文件使用 launch 文件，可以一次性启动多个 ROS 节点launch文件自动启动ROS Master 123456789101112131415161718192021&lt;!-- 包名 节点名称 自定义节点名 --&gt;&lt;!-- 注释 --&gt;&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt; &lt;!-- 参数设置 --&gt; &lt;param name=&quot;output_feame&quot; value=&quot;odom&quot;/&gt; &lt;!-- name:参数名称，value 参数值 --&gt; &lt;rosparam= file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!-- 重映射remap --&gt; &lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt; &lt;!-- from:原名 to:映射后的名字 --&gt; &lt;!-- 嵌套include --&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 客户端与服务端客户端 rosservice call &#x2F;clear “{}” 参数的使用parameter Server 全局变量存储空间 123456789101112// 列出当前有多个参数rosparam list// 显示某个参数值rosparam get param_key// 设置某个参数值rosparam set param_key param_value//保存参数到文件rosparam dump file_name// 从文件读取参数rosparam load file_anme// 删除参数rosparam delete param_key yaml 参数文件在程序里实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config():\t# ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True)\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;);\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() TF坐标管理系统tf功能包，默认10秒 实现机制 广播TF变换 监听TF变换12345678//安装功能包sudo apt-get install ros-melodic-turtle-tf//启动节点roslaunch turtle tfturtle tf demo.launch//turtles键盘控制节点rosrun turtlesim turtle teleop_key//保存tf tree为 pdf 至当前目录rosrun tf view frames tf工具 命令行工具rosrun tf tf_echo turtle1 turtle2 可视化工具 rosrun rviz rviz -d rospack find turtle tf &#x2F;rviz&#x2F;turtle rviz.rviz tf坐标的广播与监听单词释义quaternion 四元数radian 弧度degree 角度 常用可视化工具QT工具箱 日志输出rqt_console 计算图ret_graph 数据绘图rqt_plot 图像渲染rqt_image_view rviz gazebo 进阶 控制与仿真 gazebo + ros +ros_control","tags":["ros"]},{"title":"stc驱动TM1608","path":"/2023/09/16/stc驱动TM1608/","content":"tm1638.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef _TM1638_H#define _TM1638_H#include &lt;STC32G.H&gt;//TM1638模块引脚定义sbit DIO=P1^3; //数据线sbit CLK=P1^0; //时钟线sbit STB=P1^1; //片选线//共阴数码管显示代码unsigned char code dis[11]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x00&#125;; unsigned char while_one[8]=&#123;0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce&#125;;void TM1638_Write(unsigned char Data) //写数据函数&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; CLK=0; DIO=Data&amp;0x01; Data&gt;&gt;=1; CLK=1;\t&#125;&#125;void Write_Command(unsigned char Command) //发送命令&#123;\tSTB=0;\tTM1638_Write(Command);\tSTB=1;&#125;void Write_Data(unsigned char add,unsigned char Data) //指定地址写入数据&#123;\tSTB=0;\tTM1638_Write(0x00|add);\tTM1638_Write(Data);\tSTB=1;&#125;//TM1638初始化函数void init_TM1638(void)&#123;\tunsigned char i;\tWrite_Command(0x8F); Write_Command(0x40); //采用地址自动加1\tSTB=0; TM1638_Write(0xc0); //设置起始地址\tfor(i=0;i&lt;16;i++) //传送16个字节的数据 TM1638_Write(0x00);\tSTB=1;&#125;#endif tm1638.c 123456789101112131415161718192021#include &lt;STC32G.H&gt;#include &quot;tm1638.h&quot;void TMmain(void)&#123; unsigned char i;\tP0=0xff;P2=0x80;P2&amp;=0x1f; P0=0;P2=0xa0;P2&amp;=0x1f; //关闭单片机LED、蜂鸣器、继电器，主要是刺眼。。。 init_TM1638(); //初始化TM1638\tfor(i=0;i&lt;8;i++)\tWrite_Data(i,dis[10]); //初始化寄存器\twhile(1)\t&#123; Write_Data(while_one[0],dis[6]); //选中GRID1，令第一位数码管显示0\t&#125;&#125;","tags":["单片机"]},{"title":"stc32学习","path":"/2023/09/14/stc32学习/","content":"时隔三月，再摸单片机，这一次我要把遗忘的全部拿回来 STC32介绍 STC I&#x2F;O口工作模式 除了P3.0和P3.1（准双向口）外，其他默认高阻输入模式准双向口和推挽输出模式默认为高电平 define和typedef12typedf unsigned char u8;给已存在的数据类型起别名 WTST程序读取等待控制寄存器，上电默认为70-255 volatile设置变量，防止优化 预编译处理12345678910//主要命令有#include#ifndef //如果宏未定义则执行#define //定义宏#endif //结束有if的定义#elif#undef // 取消已定义的宏#line#program#error 模块化编程思想 移位法点亮LED 1234567while(1)&#123; for(i = 0;i &lt; 8; i++) &#123; P2 = ~(0x01 &lt;&lt; i); delayms(500); &#125;&#125; 上拉电阻和下拉电阻所有IO口都配置了一个4.1K的上拉电阻和10K的下拉电阻都是8位寄存器上拉电阻控制寄存器：PxPU上拉电阻控制寄存器：PxPD(x &#x3D;0,1,2,3,4,5,6,7) 123456789P7M1 = 0xFF;P7M0 = 0x00; //高阻输入模式EAXFR = 1; //使能XFR,特殊寄存器，设置使之能访问while(1)&#123; P7PU = 0x01; //加上拉电阻等于准双向口模式 delayms(1000); P&amp;PD = 0x00; delayms(1000);&#125; 自适应delayms()函数12345678#define MAIN_Fose = 35000000 //设置主频void delayms(int ms)&#123; int i; do&#123; i = MAIN_Fose/6000; while(i--); &#125;while(--ms);&#125; 特殊功能寄存器（SFR，XFR） 地址范围0x7E0000-0x7EFFF如需访问扩展寄存器，需先设置SFR使能寄存器CKCON 外部数据总线时钟控制寄存器CKCON &#x3D; 0x00;(上电默认为7，建议设为0) 74HC595独立按键定时器与计数器5个24位定时器&#x2F;计数器（八位预分频+16位计数）","tags":["单片机"]},{"title":"python study","path":"/2023/08/10/python-study/","content":"python规范 结尾空一行 导入库空两行 注释# 空一格 Python库的安装1pip install 库名 Python的导包方式12345678910111213# 1.import 常规导入，直接导入整个包的所有的功能函数##eg# 2.import多个导入，导入多个包的所有功能函数。##eg# 3.from … import …导入整个包的部分功能函数。##eg# 4.当然也可以通过from … import * 这个也是直接导入包的所有功能。相当于import … 重要的，在实际的应用中用得也是比较多的，我们自定义我们自己写的功能包。第一：在test_package文件夹中创建_init_.py文件，里边什么都不需要编辑。第二：在代码中把test_package的文件的路径加入到python解释器可以搜索到的路径列表中，这里就用到了python的包sys模块。下边是运行过一次的目录结构：pyc文件是py文件编译后生成的字节码文件，不需要自己创建，在你第一次成功导入包并运行成功之后会自动生成。 自定义导包 https://blog.csdn.net/weixin_45577864/article/details/121714956?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-121714956.nonecase&amp;spm=1018.2226.3001.4187","tags":["python"]},{"title":"links","path":"/2023/07/30/links/","content":"图标 介绍 网址 triority’s blog https://triority.cn/ 天鹅绒房间 https://qwqpap.xyz/ 北矿3D打印社 https://cumtb.club/"},{"title":"arduino小项目2——电压表","path":"/2023/07/30/arduino小项目2——电压表/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕，小按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V; void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; float a = Voltage_detect(); displayMenu(a);&#125; //oled屏幕显示void displayMenu(float a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); u8g2.print(&quot;Voltage, (0-5v)&quot;); // 显示电压表... u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.setCursor(20, 34); u8g2.println(a); u8g2.sendBuffer();&#125; //检测并转化为0-5vfloat Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); //读取io口模拟值 float Voltage = analogdate*5.0/1023.0; //转化 //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); //串口打印 &#125; else Serial.println(Voltage); return Voltage; //返回值&#125; 本来想弄万用表来着，emmp,放弃了,没写完，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int gear = 0; // 万用表状态 0.菜单；1.电压表；2.电流表；3.电阻表int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V;int R_I=220; // 电流表状态，电阻为220欧姆 void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; double a = Voltage_detect(); switch1(); displayMenu(a); int analogdate = analogRead(A0); &#125; void switch1() &#123; int key = digitalRead(2); // 第一次判断 if (key == 0) &#123; // 延时20ms 消除按键抖动 delay(20); // 第二次判断 if (key == 0) &#123; gear++; // 状态++ if (gear &gt; 3) &#123; gear = 0; // 循环到第一个菜单状态 &#125; &#125; // 等待按键被松开 while (!digitalRead(2)) &#123; // 等待按键松开 &#125; &#125;&#125; void displayMenu(double a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); switch (gear) &#123; case 0: //u8g2.print(&quot;Menu&quot;); // 显示菜单选项... face(); break; case 1: u8g2.print(&quot;Voltage&quot;); // 显示电压表... u8g2.setCursor(20, 34); u8g2.println(a); break; case 2: u8g2.print(&quot;Current&quot;); // 显示电流表... break; case 3: u8g2.print(&quot;Resistance&quot;); // 显示电阻表... break; &#125; u8g2.sendBuffer();&#125; void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; float Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); float Voltage = analogdate*5.0/1023.0; //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); &#125; else Serial.println(Voltage); return Voltage;&#125;","tags":["arduino"]},{"title":"arduino小项目1——小时钟","path":"/2023/07/30/arduino小项目1——小时钟/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕 接线图，文字描述。单片机上的A4接小屏幕上的SDA，A5接SCL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;MsTimer2.h&gt;#include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int year = 2020, month = 1, day = 1, hour = 0, minute = 0, second = 0; void onTimer() &#123; second++; if (second &gt;= 60) &#123; second = 0; minute++; if (minute &gt;= 60) &#123; minute = 0; hour++; if (hour &gt;= 24) &#123; hour = 0; &#125; &#125; &#125;&#125; void setup() &#123; Serial.begin(9600); u8g2.begin(); u8g2.clearBuffer(); MsTimer2::set(1000, onTimer); // 中断时间为1秒 MsTimer2::start(); // 启动定时器&#125; void loop() &#123; displayTime();&#125; void displayTime() &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.drawStr(0, 15, &quot;TIME:&quot;); u8g2.setFont(u8g2_font_ncenB12_tr); char strTemp[12]; sprintf(strTemp, &quot; %d.%.2d.%.2d&quot;, year, month, day); u8g2.drawStr(35, 15, strTemp); u8g2.setFont(u8g2_font_ncenB14_tr); sprintf(strTemp, &quot;%.2d.%.2d.%.2d&quot;, hour, minute, second); u8g2.drawStr(25, 45, strTemp); u8g2.sendBuffer();&#125;","tags":["arduino"]},{"title":"markdown基本介绍与语法","path":"/2023/07/26/markdown基本介绍与语法/","content":"markdown是什么？Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等 我为什么使用markdown写个人博客需要，且markdown使用简单，b站搜索十分钟学会，word无法完成个人博客的书写.markdown和word可相互转化,但效果不好，排版问题较大。markdown无法实现精细排版要求。 在线编译器网址https://markdown.com.cn/editor/在线转化器网址https://www.easeconvert.com/markdown-to-word/ 基本语法12345678910111213141516171819202122232425262728293031323334353637383940——————标题——————# 一级标题## 二级标题### 三级标题...###### 六级标题——————字体———————**这个是粗体***这个是斜体****这个是粗体加斜体***~~这里想用删除线~~--- 分割线——————列表———————无序列表的使用，在符号`-`后加空格使用有序列表的使用，在数字及符号`.`后加空格后输入内容——————图片———————使用符号&gt;&gt; 引用内容——————表格———————可以使用冒号来定义表格的对齐方式，如下：| 姓名 | 年龄 | 工作 || :----- | :--: | -------: || 小可爱 | 18 | 吃可爱多 || 小小勇敢 | 20 | 爬棵勇敢树 || 小小小机智 | 22 | 看一本机智书 |——————链接———————[描述](链接)——————图片———————&#123;% image 链接 %&#125;——————代码———————```语言代码块``` (占位，不管) 笔记over","tags":["markdown"]},{"title":"ros车基本学习（基于讯飞车）","path":"/2023/07/24/ros车基本学习/","content":"ros是什么（个人理解）ros是个机器人操作系统，可以在上面实现对机器人的操作，好比一个工作台，别人给你造好，直接使用上面的工具方便造自己的作品. 我为什么学ROS竞赛需要,智能车讯飞比赛及人工智能比赛甚至电赛控制类赛题也能用到 节系统是乌班图18的系统。 123456//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim 代码运行实例（c++） 123456789101112//终端输入，在主目录下创造一个test的文件夹。mkdir test//创建一个名为hello的点cpp文件。touch hello.cpp//在文件中写入内容//写完后保存关闭//打开终端输入,编译C加加文件g++ hello.cpp -o hello//执行可执行文件。./hello//同理。执行python文件python hello.py ros安装 1234567891011121314151617181920//添加ros软件源sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; //添加密匙sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 //安装rossudo apt updatesudo apt install ros-melodic-desktop-full //初始化rosdepsudo rosdep initrosdep update //设置环境变量echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc //安装rosinstallsudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 鱼香ros一键安装 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 小乌龟实例 123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 创建工作空间 1234567891011121314//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_make //设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译 12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs geometry_msgs turtlesim //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash C++编译配置&lt;cmakelists.txt&gt;12add_executable($&#123;PROJECT_NAME&#125;_node src/my_package_name_node.cpp)target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;)自定义消息1.在功能包文件夹内创建msg文件夹，并新建Person.msg文件，在里面写入 1234567string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 2.在package.xml文件内添加依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.在CMakeLists.txt内加入： 123456789 add_message_files( FILES Person.msg) generate_messages( DEPENDENCIES std_msgs)并把1# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim改为1CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime系统关机及重启 1234//关机shutdown -h now//重启sudo reboot ctrl all+T打开新的终端 摄像头参数命令1qv4l2 launch文件启动rviz每次启动rviz都要设置订阅的话题、点云大小等等机械化的设置，为了方便快捷的操作，把rviz的设置写入launch文件内，就可以一键启动了。1.先启动需要运行的节点，再启动一个rviz；2.设置好订阅的话题、点云大小、坐标轴等需要用到的设置3.点击左上角的file，选择另存为到一个指定地址(功能包文件夹下创建config文件夹，rviz配置文件放里面)；4、写入launch文件 1234&lt;launch&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find my_package)/config/path_to_your_rviz_config_file.rviz&quot; /&gt;&lt;/launch&gt; 其中 find my_package 为你的功能包名，path_to_your_rviz_config_file.rviz为rviz文件名","tags":["ros"]},{"title":"我的技术栈","path":"/2023/07/24/我的技术栈/","content":"我的技术栈语言类： c++&#x2F;c python不懂算法，C的指针操作忘了，会基础的代码编写，小车雷达找板子，键盘控制小车移动，上下位机通信 软件类： ros基本框架及实际ROS小车搭建 51单片机 stc32单片机 arduino单片机 linux基础&#x2F;驱动开发 eps32 stm32(未学) 网络基础 树莓派 opencv 神经网络 通讯协议 硬件类： solidwords&#x2F;3d打印 四层板以下pcblayout设计 非BGA封装，0402的元件等电路板焊接 通信协议（硬件类） 贴片机的了解与使用，及garber文件的操作，CAM350的使用 轮式车运动学"},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的个人博客联系邮箱：&#51;&#x33;&#x31;&#49;&#x37;&#x30;&#x34;&#53;&#48;&#57;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d; 姓名：李无忧爱好：睡觉和吃饭以及听音乐性格：温和喜静理想：实现共产主义，追求社会公平讨厌的事：被他人意志所裹挟擅长的事：模仿与学习 为什么写博客？ 主要原因有二个方面吧，首先呢，记录学习状态。学习的时候很多代码确实很难记住，知道怎么用就好了，必要的时候翻翻个人博客就可以找到。然后吧，记录生活日常。当然这个可能比较少。 我的技术栈语言类： c++&#x2F;c python不懂算法，C的指针操作忘了，会基础的代码编写，小车雷达找板子，键盘控制小车移动，上下位机通信 软件类： ros基本框架及实际ROS小车搭建 51单片机 stc32单片机 arduino单片机 linux基础&#x2F;驱动开发 eps32 stm32(未学) 网络基础 树莓派 opencv 神经网络 通讯协议 硬件类： solidwords&#x2F;3d打印 四层板以下pcblayout设计 非BGA封装，0402的元件等电路板焊接 通信协议（硬件类） 贴片机的了解与使用，及garber文件的操作，CAM350的使用 轮式车运动学"},{"title":"成就","path":"/achievement/index.html","content":"学科竞赛 第十七届智能车室外组ROS 省二（首座） 第十八届智能车室外组ROS 国一（首座） 第十八届智能车讯飞创意组 国一 第二十五届中国机器人及人工智能大赛智能驾驶 国二（首座） 2023全国大学生电子设计大赛 省三 第二十六届中国机器人及人工智能大赛智能驾驶 国一 第二十六届中国机器人及人工智能大赛百度星火 国一 第十九届智能车讯飞创意组 国二 学校奖励 2023年校级三等奖学金 学院新生辩论赛一等奖 优秀团员"}]