[{"title":"基于simplefoc 实现一个无刷电机操作另一个无刷电机转动","path":"/2024/10/23/基于simplefoc-实现一个无刷电机操作另一个无刷电机转动/","content":"基于simplefoc 实现一个无刷电机操作另一个无刷电机转动 基本框架 主机代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * Torque control example using voltage control loop. * * Most of the low-end BLDC driver boards doesn&#x27;t have current measurement therefore SimpleFOC offers * you a way to control motor torque by setting the voltage to the motor instead hte current. * * This makes the BLDC motor effectively a DC motor, and you can use it in a same way. *///力矩闭环#include &lt;SimpleFOC.h&gt;// magnetic sensor instance - SPI// MagneticSensorSPI sensor = MagneticSensorSPI(AS5147_SPI, 10);// magnetic sensor instance - I2CMagneticSensorI2C sensor = MagneticSensorI2C(AS5600_I2C);// magnetic sensor instance - analog output// MagneticSensorAnalog sensor = MagneticSensorAnalog(A1, 14, 1020);// BLDC motor &amp; driver instanceBLDCMotor motor = BLDCMotor(7);BLDCDriver3PWM driver = BLDCDriver3PWM(9, 5, 6, 8);// Stepper motor &amp; driver instance//StepperMotor motor = StepperMotor(50);//StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6, 8);// voltage set point variablefloat target_voltage = 0;// instantiate the commanderCommander command = Commander(Serial);void doTarget(char* cmd) &#123; command.scalar(&amp;target_voltage, cmd); &#125;void setup() &#123; // use monitoring with serial Serial.begin(115200); // enable more verbose output for debugging // comment out if not needed SimpleFOCDebug::enable(&amp;Serial); // initialise magnetic sensor hardware sensor.init(); // link the motor to the sensor motor.linkSensor(&amp;sensor); // power supply voltage driver.voltage_power_supply = 12; driver.init(); motor.linkDriver(&amp;driver); // aligning voltage motor.voltage_sensor_align = 5; // choose FOC modulation (optional) motor.foc_modulation = FOCModulationType::SpaceVectorPWM; // set motion control loop to be used motor.controller = MotionControlType::torque; // comment out if not needed motor.useMonitoring(Serial); // initialize motor motor.init(); // align sensor and start FOC motor.initFOC(); // add target command T command.add(&#x27;T&#x27;, doTarget, &quot;target voltage&quot;); Serial.println(F(&quot;Motor ready.&quot;)); Serial.println(F(&quot;Set the target voltage using serial terminal:&quot;)); _delay(1000);&#125;void loop() &#123; // main FOC algorithm function // the faster you run this function the better // Arduino UNO loop ~1kHz // Bluepill loop ~10kHz motor.loopFOC(); // Motion control function // velocity, position or voltage (defined in motor.controller) // this function can be run at much lower frequency than loopFOC() function // You can also use motor.move() and set the motor.target in the code motor.move(target_voltage); float angle_in_radians = sensor.getAngle(); Serial.println(&quot;T&quot;+String(angle_in_radians)); // user communication command.run();&#125; 从机代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * * Position/angle motion control example * Steps: * 1) Configure the motor and magnetic sensor * 2) Run the code * 3) Set the target angle (in radians) from serial terminal * */#include &lt;SimpleFOC.h&gt;// magnetic sensor instance - SPI// MagneticSensorSPI sensor = MagneticSensorSPI(AS5147_SPI, 10);//magnetic sensor instance - MagneticSensorI2CMagneticSensorI2C sensor = MagneticSensorI2C(AS5600_I2C);// magnetic sensor instance - analog output// MagneticSensorAnalog sensor = MagneticSensorAnalog(A1, 14, 1020);// BLDC motor &amp; driver instanceBLDCMotor motor = BLDCMotor(11);BLDCDriver3PWM driver = BLDCDriver3PWM(9, 5, 6, 8);// Stepper motor &amp; driver instance//StepperMotor motor = StepperMotor(50);//StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6, 8);// angle set point variablefloat target_angle = 0;// instantiate the commanderCommander command = Commander(Serial);void doTarget(char* cmd) &#123; command.scalar(&amp;target_angle, cmd); &#125;void setup() &#123; // use monitoring with serial Serial.begin(115200); // enable more verbose output for debugging // comment out if not needed SimpleFOCDebug::enable(&amp;Serial); // initialise magnetic sensor hardware sensor.init(); // link the motor to the sensor motor.linkSensor(&amp;sensor); // driver config // power supply voltage [V] driver.voltage_power_supply = 12; driver.init(); // link the motor and the driver motor.linkDriver(&amp;driver); // choose FOC modulation (optional) motor.foc_modulation = FOCModulationType::SpaceVectorPWM; // set motion control loop to be used motor.controller = MotionControlType::angle; // contoller configuration // default parameters in defaults.h // velocity PI controller parameters motor.PID_velocity.P = 0.15f; motor.PID_velocity.I = 0; motor.PID_velocity.D = 0; // maximal voltage to be set to the motor motor.voltage_limit = 6; // velocity low pass filtering time constant // the lower the less filtered motor.LPF_velocity.Tf = 0.03f; // angle P controller motor.P_angle.P = 20; // maximal velocity of the position control motor.velocity_limit = 20; // comment out if not needed motor.useMonitoring(Serial); // initialize motor motor.init(); // align sensor and start FOC motor.initFOC(); // add target command T command.add(&#x27;T&#x27;, doTarget, &quot;target angle&quot;); Serial.println(F(&quot;Motor ready.&quot;)); Serial.println(F(&quot;Set the target angle using serial terminal:&quot;)); _delay(1000);&#125;void loop() &#123; // main FOC algorithm function // the faster you run this function the better // Arduino UNO loop ~1kHz // Bluepill loop ~10kHz motor.loopFOC(); // Motion control function // velocity, position or voltage (defined in motor.controller) // this function can be run at much lower frequency than loopFOC() function // You can also use motor.move() and set the motor.target in the code motor.move(target_angle); float angle_in_radians = sensor.getAngle(); Serial.println(angle_in_radians); // function intended to be used with serial plotter to monitor motor variables // significantly slowing the execution down!!!! // motor.monitor(); // user communication command.run();&#125; 接线有点烂，暂时就先就这样了","tags":["无刷电机"]},{"title":"USB3.0拓展坞设计","path":"/2024/10/22/USB3-0拓展坞设计/","content":"前言感觉自己天天开新坑却不填，想做一个USB3.0的拓展坞，单纯的集线器并不难，想加一些功能，有网口读取，SD卡，TF卡功能，视频传输，ST-link下载，串口，USB转CAN口。Ok，主要是想通过这个项目了解一下各种协议及其在硬件上的规定，作为练习。尽可能采用四层板。 USB3.0硬件设计规范 usb3.0六根信号线 D+ D- RX+ RX- TX+ TX- D+与D-是兼容USB2.0的信号线，剩下四根是高速线，并且同组内可交叉连线注意ESD，选择可适配3.0的ESD(还是有点没太理解)TX端即host端要加一个100nf的耦合电容，靠近连接器端 阻抗控制： 建议USB3.0的差分阻抗控制90Ω误差10%，USB2.0差分阻抗控制90Ω误差10%。 时延控制： 建议USB3.0差分对内需等长设计，误差小于5mil。USB2.0等长误差控制小于10mil。 隔直电容： 建议选取0402以下封装电容，容值官方SPEC要求75nF-265nF之间，布局时靠近端子放置。 对内交叉： USB3.0 的P&#x2F;N如果走线上有交差，可以将差分对的P&#x2F;N交换，USB3允许P&#x2F;N反转。 参考链接 接口一览https://blog.csdn.net/Mark_md/article/details/114578359"},{"title":"USB to can的学习与踩坑","path":"/2024/10/20/USB-to-can的学习与踩坑/","content":"前言一切的开始从一个项目说起，3D打印机的项目需要用到工具板，采用CAN通讯，由于不理解，决定学习一下CAN通讯，并由U_TO_C模块做起。 开源项目的学习 https://oshwhub.com/hvan/usb_can项目地址 打板后，存在问题，该种型号的排阻在淘宝上难以买到，0402封装比较难焊接。原理图部分还是比较简单 不知道是什么原因，完全焊接上后无法使用，需要去掉，注意事项写在下面了 接头间距为sh1.0，没有的得提前买，建议一边接头，另一边杜邦线2.54mm母头 焊接好的成品如图 后面有时间对其改造一下 固件烧录这里我采用ST-LINK对其烧录，固件PCAN-USB。固件及后续上位机放到了github的仓库里烧录时，ST-LINK电源使用3.3V,录个视频，如下 驱动安装分为LINUX与windows系统，这里仅介绍windows系统驱动及其上位机安装，linux后续有时间再议。这里采用Pcan-view 上位机使用及其演示两台USB-to-can实现互发","tags":["通讯"]},{"title":"无线蓝牙鼠标的拆解","path":"/2024/10/17/无线蓝牙鼠标的拆解/","content":"之前在淘宝上买了个蓝牙鼠标，最近电池不耐用了，就拆解一下 PCB板如图，反面和正面 1是FCT3065-XY（无线鼠标传感器IC），上面丝印为FCT3065-XY，D23443BN2是红光LED3是电源管理芯片，丝印LTH74是无线通讯芯片,通过旁边的天线发送信号，丝印BYKC68MS,M16 AAD9 AJ,BY2307-BP34(,为换行)5是16000晶振6是3.0V的LDO，丝印65Z5 https://developers.goodix.com/zh/bbs/blog_detail/bebdd04ccdfc4f7682ab27a8e77a14ad","tags":["拆解"]},{"title":"无刷电机","path":"/2024/10/16/无刷电机/","content":"电机的内容十分重要，用处大大的，之前一直只会使用驱动板对电机进行相关控制，也没有总结和相关算法的学习，这样不好，决定新开一篇用于记录无刷电机的学习。foc 磁场定向控制技术 注意通过FOC控制的云台电机和通过电调控制的动力电机一般是不通用的 无刷电调这儿制作还是挺简单的，这里使用开源的PCB， 用了三个n沟道MOS和三个P沟道MOS，P沟道MOS采用三极管驱动。R1是上拉电阻并兼有限流功能，R2是基极串联电阻 三极管由发射极、基极和集电极组成，其中基极是控制三极管导通和截止的引脚。 在实际电路中，为了稳定三极管的工作状态，通常会在基极引脚串联一个电阻。 这个电阻被称为基极串联电阻，其作用是限制基极电流，确保三极管正常工作。 供电接口选用：XT30PW-M固件烧写接口：GH125-S04DCA-00 单片机固件在参考的链接里找话说电调里到底写了啥，这里只有HEX文件，咋也不知道，后续再看。话说逐飞科技也开源了基于STC32的电调，后续再看。 基于arduino的开源项目 【开源Arduino无刷电调制作】 https://www.bilibili.com/video/BV1PS4y1P7AS/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6这个部分就更贴切我对无刷电机的想象，将驱动部分和控制部分分开。 BLDC与PMSM无刷直流电机（Brushless DC motor, BLDCM）定义一般有两种：一种定义认为只有梯形波&#x2F;方波无刷直流电机才可以被称为无刷直流电机，而正弦波无刷电机则被称为永磁同步电机（permanent magnet synchronous motor, PMSM） KV值：转速&#x2F;V，意思为输入电压每增加 1 伏特，无刷电机空转转速增加的转速值。比如说，标称值为 1000KV 的外转子无刷电机，在 11 伏的电压条件下，最大空载转速即为：11× &#x3D; 1000 11000rpm（rpm 的含义是：转&#x2F;分钟）。 径向磁铁与轴向磁铁编码器磁编码器霍尔编码器电流采集电路与电压采集电路https://blog.csdn.net/yck1716/article/details/135967890 参考 【没有专业术语！新手小白也能看懂的FOC科普】 https://www.bilibili.com/video/BV1XvtNeaE54/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6无刷电调PN双层 v2https://oshwhub.com/maker-lee/luo-li-wu-shua-dian-diao-2020-ban-pn-shuang-ceng-v1_copy无刷电调固件https://www.aliyundrive.com/s/yW373tpkXLm","tags":["电机"]},{"title":"专业版立创EDA如何将pcb复制到另一个PCB中？","path":"/2024/10/16/专业版立创EDA如何将pcb复制到另一个PCB中？/","content":"如题所示，下面有两块板 工艺边板是由其他文件克隆而来，我想在需要将工艺边板加到三和一小板中，如何操作？在工艺边板中框选待复制对象，按CTRL+C 然后再该pcb文件中按CTRL+V 在工艺边PCB视窗中不要左键确定，也不要右键取消，点击三和一小板，来到该板子 CTRL+V 复制 左键点击该PCB视窗，确定","tags":["EDA"]},{"title":"硬件基础篇-常见封装工艺","path":"/2024/10/14/硬件基础篇-常见封装工艺/","content":"DIP封装 SOP封装 QFP封装 QFN封装 BGA封装 LGA封装 PGA封装 常见封装 DIP封装 SOP封装 QFP封装 QFN封装 BGA封装 LGA封装 inter CPU PGA封装 AMD CPU 【7种常见的芯片封装形式，你了解几种？】 https://www.bilibili.com/video/BV1kT421a7mS/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["硬件基础"]},{"title":"常见通讯协议","path":"/2024/10/14/常见通讯协议/","content":"USB通讯 物理接口 3.0是高速线，有设计规范 如何识别USB接口电路的速度呢？ 低速接口设计 高速&#x2F;全速接口设计 从机的上拉电阻在D-线上为低速，在D+线上为高速。高速和全速通过硬件区分 USB2.0接口电路 补充知识，共模电感，能够抑制共模信号，用于电源和信号的EMI电路中 TVS和ESD二极管的区别TVS,瞬态抑制，ESD,防静电 USB3.0接口设计 重学 ESD器件选择双向负载电容，USB2.0小于2PF,USB3.0小于0.2PF CAN通讯Controller Area Network半双工通信总线can收发芯片 差分信号(差模信号) 电压差为0为逻辑1。有利于抗干扰和减少噪声，需要双线输入，传输距离长 数据结构和传输协议 两个设备同时发送信息，以哪个设备信息优先呢？ 要看11位的识别码，识别码中不同的以最先出现逻辑0优先。 【趋近于完美的通讯 CAN总线！4分钟看懂！】 https://www.bilibili.com/video/BV14k4y187e6/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【CAN接口电路设计】 https://www.bilibili.com/video/BV1FT411g77P/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["单片机"]},{"title":"3D打印耗材直径的检测方案","path":"/2024/10/13/3D打印耗材直径的检测方案/","content":"本文主要讨论3D打印耗材直径的检测，前期所有的数据将由单片机呈现，后期将考虑加入klipper固件。目前主流的方案有两种，一种是线性CCD检测，一种是基于霍尔检测。 霍尔检测线性CCD检测CCD的基本原理","tags":["项目"]},{"title":"电机与拖动","path":"/2024/10/06/电机与拖动/","content":"基本概念 电机及其分类 所有物质都具有导磁能力，只是强弱不同 习题 铁磁性材料的性质 习题 总结","tags":["课程"]},{"title":"硬件基础篇-二极管","path":"/2024/10/06/硬件基础篇-二极管/","content":"总体介绍 封装各不相同 常见分类 普通二极管 恒流二极管 肖特基二极管 快恢复二极管 TVS 齐纳二极管（稳压二极管） 发光二极管 光电二极管 变容二极管 双向触发二极管 开关二极管 肖特基二极管和快恢复二极管的反向恢复时间都较短，肖特基10ns，快恢复二极管的反向恢复时间要长于肖特基二极管，但是，肖特基二极管的反向耐压低常规二极管的正向压降在0.7V,发光二极管在2-3V之间 开关二极管和TVS是什么？ 普通二极管（常规二极管） K为阴极，A为阳极 二极管的作用 防反接 钳位 限幅 检波 整流 续流 倍压 逻辑门 倍压需要交流电，下图是二极管倍压电路，输入交流，输出直流 雪崩击穿与齐纳击穿及热击穿参数 封装 正向导通电压 结电容 反向击穿电压 平均电流&#x2F;峰值电流（100mA左右） 浪涌电流 正向压降 反向电流漏电流 反向恢复时间 浪涌电流，电容电感等初始充电时，产生的较大电流，时间1ns左右，下图中的前段时浪涌电流，后段峰值部分被称成为峰值电流。 齐纳二极管重要参数 标称稳定电压$V_{z}$ 额度工作电流$I_{zt}$ 最小稳定工作电流$I_{zk}$ 最大稳定工作电流$I_{zm}$ 最大耗散功率$P_{zm}$ 动态电阻（越小，稳压越好） 温度系数 R1是限流电阻，R2是负载。 不如做道题，电压小于反向击穿电压时，齐纳管是截至状态。 TVS与齐纳二极管的区别 TVS有单向和双向的区分，稳压管都是单向的； TVS通流比较大，20A都算正常，稳压管通流较小； TVS常放置在接口引脚处，稳压管放在板内信号或电源上； TVS响应时间很快，可达ps级，稳压管很少将相应时间； TVS管用于瞬态电压保护，稳压管对漏极和源极进行箝位保护。 应用 稳压二极管不允许并联，但可以串联（正反向） 过压保护 稳压输出 肖特基二极管 应用，双电源切换这里要压降低，反向恢复速度快 参考文献 【稳压二极管的关键参数】 https://www.bilibili.com/video/BV1WiHveQEhN/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["硬件基础"]},{"title":"硬件基础篇-电池篇","path":"/2024/10/03/硬件基础篇-电池篇/","content":"这里只对我目前使用或接触的电池进行介绍，并不全面与准确 电池的分类 锂电池 铅蓄电池 干电池 这里的分类并不全面，只针对我接触的电池，其中锂电池是重点 干电池是我们家用常见的电池，5号电池与7号电池，以及小圆薄片电池铅蓄电池常用于电瓶，也称为铅酸电池，比锂电池更安全，而且便宜。但是重又大。 锂电池 注意，淘宝上很多锂电池的电芯是18650 钴酸锂电池常用于手机平板，三元锂电池是使用最广泛的一种电池，磷酸电池常用于电动车和户外储能，但不耐低温，锰酸锂电池价格便宜，用于快消平，充电宝等 航模电池由于无人机和智能车捣鼓的比较多，这里就介绍一下航模电池。接头常用型号XT30,XT60,T型插头, DC插头 具体淘宝搜索查看 平衡头，检测电压。可用BB响检测电压 电池参数 电芯 电压 容量 最大放电电流 充电倍率 以下图为例 上图展示的是一个航模电池的主视图和侧视图。由侧视图可以看出有三块电芯，即3S电池，3s表示3块电池串联，1p表示1块电池变量，1p省略。一般一块电芯额度电压为3.7V,最大电压4.2V,则上图的3S电池额定电压为11.1V,最大充电到电池电压为12.6V，满电。1100mAh 表示充满电后，电压为额定电压，放电电流1100mA的情况下，可以放电1小时，即电池的容量，W&#x3D;mAhV，总做工为容量乘以电压。30C为其放电倍率，表示在最大工作放电电流为1100mA30，即33A.charge为充电，该图充电倍率未注明该电芯为软包电池 报废电池处理盒子加水，放入适量食用盐，将待报废电池置入盒体，将盒子放置到阳台等卡阔通风处，静置两天，直至电池接口处不再冒出气泡，有铜绿出现开始 两天后 参考资料 【如何低成本 自制穿越机固定翼用 高性能航模电池 电池组装教学】 https://www.bilibili.com/video/BV1Qg4y1C7E3/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【用废旧电池，小伙制作出耐用的铅酸电瓶，让你的电器更持久！】 https://www.bilibili.com/video/BV1cM4m1X7CS/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【锂电池种类千千万，你知道他们的区别吗？】 https://www.bilibili.com/video/BV1Q24y1w7Su/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6【航模电池，需要知道这些！【我的第一架遥控飞机】第四集】 https://www.bilibili.com/video/BV1M7411C7gi/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6","tags":["硬件基础"]},{"title":"硬件设计研究","path":"/2024/09/26/硬件设计研究/","content":"硬件工程师基本分类 板卡规范，CPCI&#x2F;PCle&#x2F;VPX 电阻1英寸&#x3D;25.4mm需找一个电阻的数据手册封装分类，阻值辨识，电气特性， 分类 厚膜电阻和薄膜电阻的区别 选型参数 阻值 精度 额定功率 额定电压、最高工作电压 温度系数"},{"title":"Arduino uno 开发","path":"/2024/09/05/Arduino-uno-开发/","content":"前言写下此文字时，是24年6月10日，我刚刚结束24年6月1,2日的中国机器人及人工智能大赛的北京市省赛和6号的模电考试，省赛是线下比赛，第一天调试不顺，第二天比赛也是匆匆忙忙，十分混乱。比完后内心感慨，思绪良久。七八号左右出成绩，幸运的是，二队省一，一队三队省二，基本上都可以进国赛。虽然十五号四级，但内心有一种强烈的欲望，想要对自己进行整理，生理上的，心理上的。我开始对我的技术栈进行整理，决定从最简单的auduino开始，这也是我写下本文的初衷，对知识进行整理。本文大概分为四个部分，第一部分，arduino基础知识学习，第二部分，外设的使用，第三部分，电机的驱动，第四部分，实战。第三部分按理应放在第二部分，但个人认为电机驱动部分相对重要，就单列一部分了。我将遵循简约，准确的原则开始编写本文。本文并不针对初学者，需要一些C语言知识，电学知识作为前置知识，本文不介绍此部分。本文使用了chat，加速本文的开发。 第一章\tArduino uno初识1.1\tArduino简介Arduino 旗下系类有很多，其中用途广泛的有四种，Arduino UNO，Arduino mega 2560,Arduino nano,Arduino uno wifi. 顺序从左到右对应。Arduino UNO为通用型号，mega 2560引脚多，功能更强大，Arduino nano,板子小巧，质量轻，体积小，Arduino UNO wifi,多了个wifi功能，建议别用，直接用esp32.本文主要针对的是arduino uno进行开发介绍。中文网站如下 https://arduino.nxez.com/ 1.2\tArduino 引脚功能介绍 引脚分为5个区，区域如下 1区为引脚供电区，-\tIORES,输入输出参考电压-\tRESET,复位引脚，默认输出为1，下拉即可复位。-\t3.3V和5V是供电引脚，uno可通过USB输入电源,此时，3.3V和5V可对外供电，也可通过3.3V和5V对单片机进行供电，不使用usb供电-\tGND,地线-\tVin,外部电源为开发板供电 2区为模拟口引脚区(analog)ADC表示模拟到数字转换器。 ADC是用于将模拟信号转换为数字信号的电子电路。模拟信号的这种数字表示允许处理器（其是数字设备）测量模拟信号并在其操作中使用它。 Arduino引脚A0-A5能够读取模拟电压。在Arduino上，ADC具有10位分辨率，这意味着它可以通过1,024个数字电平表示模拟电压。 ADC将电压转换成微处理器可以理解的位。模拟引脚只能模拟输入，不能模拟输出。3区为ICSP插头接口区 4区为同3区，部分板子无此区域5区为数字引脚区(digital)Arduino Uno的引脚0-13用作数字输入&#x2F;输出引脚。其中，引脚13连接到板载的LED灯；引脚3、5、6、9、10、11具有PWM功能 以下是 Arduino Uno 的一些关键硬件规格：•\t微控制器：ATmega328P•\t工作电压：5V•\t输入电压（推荐）：7-12V•\t输入电压（限制）：6-20V•\t数字I&#x2F;O引脚：14（其中6个提供PWM输出）•\t模拟输入引脚：6•\t每个I&#x2F;O引脚的直流电流：20 mA•\t3.3V引脚的直流电流：50 mA•\t闪存：32 KB（ATmega328P），其中0.5 KB用于引导加载程序•\tSRAM：2 KB（ATmega328P）•\tEEPROM：1 KB（ATmega328P）•\t时钟速度：16 MHz 1.3\tArduino 供电与取电 Arduion UNO 的供电方式有四种1.\tUSB接口供电（5V）2.\t外部电源接口供电，直流电源电压必须为7V ~ 12V3.\tVin供电引脚供电，供电电压7~12V4.\t5V引脚5V供电。 注意通过VIN引脚供电，有一定可能性造成降压芯片烧毁，所以，如果电源12V，走外部电源接口供电，如果电源5V，走5V引脚供电。 3.3V无法通过3.3V引脚供电，会造成单片机工作异常。 大功率用电模块不要走单片机的引脚供电，一方面，供电不足，另一方面，可能造成烧毁或异常。 1.4\tArduino 引脚设置打开Arduino的开发IDE,插上arduino,使用USB接口,另一端接入电脑，选择端口和开发板。IDE的安装和端口选择及中文语言选择自行百度，这里略过。IDE如下。 Setup(){}函数为初始化函数，会在arduino开机时执行一次。Loop(){}函数为循环函数，主程序会在这里循环执行。 我们在这里学习数字和模拟引脚的设置。 1.4.1数字引脚数字引脚即可以输入也可以输出。该类引脚有两种状态，高电平(1)与低电平(0)，高低电平的确定由参考电压(AREF)确定。每个数字I&#x2F;O口（input,输入，output，输出）可提供最高40mA的电流和5V的电压。数字I&#x2F;O口定义函数。 pinMode(pin,mode) pinMode()函数为数字引脚定义函数，第一个参数pin,为引脚标号，即要设置那个引脚，范围为0-13，即数字引脚区。Mode有三种模式，INPUT(输入)，INPUT_PULLUP(带上拉电阻输入)，OUTPUT(输出)。 digitalWrite(pin,mode); 设置引脚输出状态后，可用digitalWrite函数设置引脚置为0还是1，不设置的话默认为LOW,低电平。第一个参数为引脚标号，第二个参数为状态，LOW或者HIGH; digitalRead(pin); digitalRead(pin)该函数为读取引脚状态，返回值为int型。结果为HIGH,LOW。注意：在进行读取引脚操作前，需先对引脚输入模式进行定义 1.4.2模拟引脚使用模拟引脚时，在模拟方面只能模拟输入无法模拟输出。 int b&#x3D;analogRead(A0); A0为模拟口的一个引脚，可替换为A0，A1- A5;返回值为0-1023一个数字，模拟引脚内置10位A&#x2F;D转换器，能将0~5V的电压转换为0-1023的数值，读取精度为5V&#x2F;210即，每单位4.9mV.模拟口也可作为数字引脚使用。使用如下 pinMode(A0,OUTPUT); digitalWrite(A0,HIGH); A0A5也可用14-19表示。1.4.2PWM引脚在数字引脚上，我们可以观察到有的数字引脚旁边带号，这说明此引脚具有PWM输出的功能。如何使用这些引脚输出PWM波呢？首先，这些引脚是数字引脚区，应先设置引脚输出状态，再设置PWM波的占空比。 pinMode(3,OUTPUT); analogWrite(3,100); 通过anglogWrite(pin,Value);设置占空比，占空比范围为0-255。PWM波不是模拟输出，arduino的PWM波输出频率较低，一千Hz以内，后续再详细介绍PWM. 1.5\tArduino串口通讯通过USB线将板子和计算机连接，可实现串口通讯，UNO的硬件串口资源仅有一个，一个串口资源，仅支持1对1，板子与计算机通讯时不要使用其他模块占用此通道，否则可能造成串口传输乱码，或者下载失败。本小节仅讨论计算机与板子的串口操作，串口的其他操作后续内容后面章节补充 1.5.1串口初始化使用 Serial.begin(baudRate) 函数来初始化串口通信，参数 baudRate 是波特率（数据传输速率），常见值是 9600, 115200 。初始化内容一般放在setup函数里。如下。 123void setup() &#123; Serial.begin(9600); // 初始化串口通信，波特率为9600&#125; 1.5.2发送数据• Serial.print(data)：发送数据，但不换行。• Serial.println(data)：发送数据并换行。可用串口接收器接受。 1.5.3接受数据• Serial.available()：返回串口缓冲区中的字节数。• Serial.read()：读取串口缓冲区中的一个字节，返回值为 -1 表示没有数据可读。• Serial.readString()：读取串口缓冲区中的字符串，直到超时（需要 Serial.setTimeout() 配合）。• Serial.readStringUntil(char terminator)：读取串口缓冲区中的字符串，直到遇到终止符（如换行符）。Serial.setTimeout(500); &#x2F;&#x2F; 设置超时为500毫秒 1.5.4串口综合12345678910111213141516void setup() &#123; Serial.begin(9600); // 初始化串口，波特率为9600 Serial.setTimeout(1000); // 设置读取操作的超时时间为5秒，可注释 Serial.println(&quot;Enter a string (timeout 5 seconds):&quot;); //提示用户输入字符串&#125;void loop() &#123; // 检查是否有数据可读 if (Serial.available() &gt; 0) &#123; String receivedString = Serial.readString(); // 读取串口缓冲区中的字符串 Serial.print(&quot;You entered: &quot;); Serial.println(receivedString); // 打印接收到的字符串 &#125; delay(500); // 延迟500毫秒&#125; 操作时，要注意程序运行在uno上，主体是单片机而不是计算机。 1.6\tArduino AREF与IOREF的使用部分arduino的板子的IOREF引脚会该成5V供电引脚 ,查阅原理图，IOREF被锁死。 AREF在mega328中，有六个模拟输入引脚，这些模拟输入引脚简单的说测量的是输入的电压值然后用 0~ 1023来表示电压的大小，当然，这个值有一个范围，通常来说是0~5V，查阅UNO的规格书可以知道UNO是具有10位的ADC。 10位ADC以为着什么呢？以为着它能将0 ~ 5 V的电压分成1024份（2^10），算出来即为4.882mV的测量精度，举个例子就是0V的时候测量结果为0，5V为1023，3V约为615，但是有一种情况就是你输入的电压最大是3.3V，测量出来的最大值也就是675，这个时候你或许会想到map，确实这不失为一个好办法。 但是AREF提供了另一个更好的解决办法，即在AREF接入一个最大模拟输入量作为参考值（比如上面所说的3V3），这样不仅能直接读到1023，更为重要的是精度提高，用3V3作为AREF的时候精度是多少？？ 3.3&#x2F;1023 &#x3D;&#x3D;3.223mV，测量精度提高了。 使用外部电源注意事项：-\t确保外部参考电压在 0 到 Vcc 之间，对于 5V Arduino 板，电压应在 0 到 5V 之间。-\t外部参考电压不应超过 Vcc，否则可能会损坏 Arduino 板。-\t使用一个稳定的电压源作为外部参考电压。如果外部参考电压不稳定，ADC 的精度会受到影响。-\t如果已经连接了外部参考电压，不要在代码中使用 analogReference(DEFAULT); 或 analogReference(INTERNAL);。这样可能会引起冲突和不正确的读数。 123456789void setup() &#123; Serial.begin(115200); analogReference(EXTERNAL); // 使用外部参考电压&#125; void loop() &#123; int a = analogRead(A0); Serial.println(a); &#125; 1.7\tArduino 上拉电阻上拉电阻是什么？在I&#x2F;O口模式设置中，输入模式有两种，INPUT和INPUT_PULLUP,这两者有什么区别吗？本节将解答上面的问题。输入模式的引脚相当于电压表的探头，如果测得电压比基准电压高，则为1，比基准电压低为0；首先我们要了解一个概念，引脚悬空，即当某个引脚处于输入模式时，而该引脚什么也没有接的情况称之为引脚悬空。灵魂画手上线，如下图。 引脚悬空会有什么问题呢？会造成读取的引脚状态不对，此时是高电平还是低电平呢？无法确定。 123456789101112void setup() &#123; Serial.begin(115200); pinMode(2,INPUT);&#125;void loop() &#123; delay(50); int a =digitalRead(2); Serial.println(a);&#125; 打印结果如下，特别是将手指捏在悬空引脚尤为明显。 而将引脚模式设置为输入上拉后，输出不飘了，为1. pinMode(2,INPUT_PULLUP); Arduino内部的上拉电阻为20K欧，一般上拉电阻为10K欧 此时引脚不接东西时，测的电压为VCC,即高电平，上拉电阻阻值较大，能够限流，防止大电流灌入引脚。当引脚接GND时，此时pin测的电压为GND的电压，为低电平。不使用单片机的内置上拉电阻，自行在输入引脚外接一个阻值大小合适电阻是相同的效果。上拉电阻稳定输入引脚状态，克服了引脚悬空带来的引脚测量值不准的问题。 1.8\tArduino 定时器资源Arduino Uno 基于 ATmega328P 微控制器，该微控制器包含三个硬件定时器资源：Timer0、Timer1 和 Timer2。每个定时器有不同的特性和用途，具体如下： Timer0类型：8位定时器用途：主要用于 Arduino 内部计时功能，例如 millis() 和 delay() 函数。它可以生成中断，用于更新系统时间。尽量不要更改这个定时器。PWM 引脚：5和 6（对应 Arduino 引脚）Timer1类型：16位定时器用途：由于其较高的分辨率，Timer1 常用于需要精确时间控制的任务，例如 Servo 库。它也可以生成高精度的 PWM 信号。PWM 引脚：9 和 10（对应 Arduino 引脚）Timer2类型：8位定时器用途：通常用于生成较低频率的 PWM 信号或执行其他定时任务。其频率设置比较灵活，适用于音频生成等应用。PWM 引脚：3 和 11（对应 Arduino 引脚） 中断频率（Hz）&#x3D;（Arduino时钟速度16MHz）&#x2F;（预分频器*（比较匹配寄存器+ 1）) WGM02、WGM01、WGM00：这三个位用于选择相位校正（phase correct）模式、快速（Fast）模式或CTC模式。相位校正模式：计数器在达到最大值（255）后开始减小，形成一个三角形波形。快速模式：计数器达到最大值后归零，形成锯齿波形。CTC模式：计数器在达到OCR0A（比较寄存器A）后归零，形成可变的锯齿波形。CS02、CS01、CS00：用于控制预分频系数，即将系统时钟分频得到计时器时钟。分频系数1：无分频。分频系数8：系统时钟除以8。比较寄存器A、B：除了设置定时器外，还有两个寄存器用于控制PWM比较值，从而控制占空比。COM0A1、COM0A0、COM0B1、COM0B0：用于设置PWM输出引脚的电平。COM0A1&#x2F;COM0B1、COM0A0&#x2F;COM0B0为1、1时，当OCR比较寄存器小于计数器值时引脚输出0，大于计数器值时输出1。COM0A1&#x2F;COM0B1、COM0A0&#x2F;COM0B0为1、0时，当OCR比较寄存器小于计数器值时引脚输出1，大于计数器值时输出0。CTC模式下，COM0A1&#x2F;COM0B1、COM0A0&#x2F;COM0B0为0、1时，每当计数器溢出，引脚输出取反。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int toggle0, toggle1, toggle2;void setup() &#123; cli(); // 关闭全局中断 // 设置定时器0为10kHz(100us) TCCR0A = 0; // 将整个TCCR0A寄存器设置为0 TCCR0B = 0; // 将整个TCCR0B寄存器设置为0 TCNT0 = 0; // 将计数器值初始化为0 // 设置计数器为10kHz，即100us OCR0A = 24; // 比较匹配寄存器 = [16,000,000Hz /（预分频器 * 所需中断频率）] - 1 // 比较匹配寄存器 = 24, 中断间隔 = 100us 即中断频率10kHz TCCR0A |= (1 &lt;&lt; WGM01); // 打开CTC模式 TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00); // 设置CS01位为1，CS00位为1(64倍预分频) TIMSK0 |= (1 &lt;&lt; OCIE0A); // 启用定时器比较中断 // 设置定时器1为1kHz TCCR1A = 0; // 将整个TCCR1A寄存器设置为0 TCCR1B = 0; // 将整个TCCR1B寄存器设置为0 TCNT1 = 0; // 将计数器值初始化为0 // 设置计数器为1kHz，即1ms OCR1A = 1999; // = (16*10^6)/(1000*8) - 1 (must be &lt;65536) TCCR1B |= (1 &lt;&lt; WGM12); // 打开CTC模式 TCCR1B |= (1 &lt;&lt; CS11); // 设置CS11位为1(8倍预分频) TIMSK1 |= (1 &lt;&lt; OCIE1A); // 启用定时器比较中断 // 设置定时器2为8kHz TCCR2A = 0; // 将整个TCCR2A寄存器设置为0 TCCR2B = 0; // 将整个TCCR2B寄存器设置为0 TCNT2 = 0; // 将计数器值初始化为0 // 设置计数器为8kHz OCR2A = 249; // = (16*10^6) / (8000*8) - 1 (must be &lt;256) TCCR2A |= (1 &lt;&lt; WGM21); // 打开CTC模式 TCCR2B |= (1 &lt;&lt; CS21); // 设置CS21位为1(8倍预分频) TIMSK2 |= (1 &lt;&lt; OCIE2A); // 启用定时器比较中断 sei(); // 打开全局中断&#125;// 中断0服务函数ISR(TIMER0_COMPA_vect) &#123; // timer0中断，产生频率为10kHz / 2 = 5kHz的脉冲波 if (toggle0) &#123; digitalWrite(8, HIGH); toggle0 = 0; &#125; else &#123; digitalWrite(8, LOW); toggle0 = 1; &#125;&#125;// 中断1服务函数ISR(TIMER1_COMPA_vect) &#123; // timer1中断，产生频率为2Hz / 2 = 1Hz的脉冲波 if (toggle1 &gt;= 500) &#123; digitalWrite(13, HIGH); &#125; if (toggle1 &lt;= 500) &#123; digitalWrite(13, LOW); &#125; toggle1 += 1; if (toggle1 &gt;= 1000) &#123; toggle1 = 0; &#125;&#125;// 中断2服务函数ISR(TIMER2_COMPA_vect) &#123; // timer2中断，产生频率为8kHz / 2 = 4kHz的脉冲波 if (toggle2) &#123; digitalWrite(9, HIGH); toggle2 = 0; &#125; else &#123; digitalWrite(9, LOW); toggle2 = 1; &#125;&#125;// 主循环函数void loop() &#123;&#125; 1.9\t其他板间通讯。如果想对板子进行更细致的操作，建议更换STM32,或者其他单片机。 第二章\t常用模块的使用2.1 红外对光管的检测 应用场合： 1.电度表脉冲数据采样 2.传真机碎纸机纸张检测 3.障碍检测 4.黑白线检测 DO 为数字输出口AO为模拟输出口可5V或3.3V供电。 中间的螺旋可以调节探测的距离。当红外接收器接受到信号时，开光指示灯亮起。DO为低电平，检测这个端口的值，即可知道探测状态。 测试5V供电，DO引脚接3号，AO接A0 12345678910111213void setup() &#123; pinMode(3,INPUT_PULLUP);//使用三号数字引脚探测DO Serial.begin(115200); // 初始化串口，波特率为115200&#125;void loop() &#123; // put your main code here, to run repeatedly: int a = digitalRead(3); //变量a接受数字值 int b = analogRead(A0); //变量b接受模拟值 Serial.println(a); Serial.println(b); delay(100);&#125; 当开关灯亮时，一个模拟值，一个数字值。串口显示器显示如下 2.2光敏&#x2F;热敏传感器的检测 这里以光敏传感器为例，热敏检查代码相同。应用场景1.\t暗室监测2.\t熄屏亮灯此类传感器与红外检查方法基本类似，将检测的模拟值，根据实际情况转化为实际量，温度，光照等。 接线：DO接数字引脚2，AO接模拟引脚A0。原理，这两个相当于电阻，电阻值随环境变化而变化。 12345678910111213void setup() &#123; pinMode(2,INPUT_PULLUP); Serial.begin(115200);&#125;void loop() &#123; int a = digitalRead(2); int b = analogRead(A0); Serial.print(&quot;a=&quot;); Serial.println(a); Serial.print(&quot;b=&quot;); Serial.println(b); &#125; 读到的模拟量需根据光敏电阻的参数转化为具体的亮度。 2.3超声波传感器 应用场合：1.机器人避障和导航2.距离测量3.接近测量4.智能垃圾桶 可3.3V或者5V输入 HC-SR04超声波测距模块可提供2cm-60cm的非接触式距离感测功能，测距精度可达高到3mm；模块包括超声波发射器、接收器与控制电路。超声波测距模块——触发信号后发射超声波，当超声波投射到物体而反射回来时，模块输出——回响信号，以触发信号和回响信号间的时间差，来判定物体的距离。使用首先要安装NewPing 库。注意，该库会调用定时器2资源。网上的很多关于超声波模块的教程，不使用定时器，并且使用delay(),会挤占主进程。 12345678910111213141516171819202122232425262728#include &quot;NewPing.h&quot; #define TRIGGER_PIN 2 //引脚定义#define ECHO_PIN 3#define MAX_DISTANCE 60 //设置最大距离NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); float duration, distance; int iterations = 5; //求平均的次数 void setup() &#123; Serial.begin (115200);&#125; void loop() &#123; duration = sonar.ping_median(iterations); //多次测量时间求平均值 distance = (duration / 2) * 0.0343; //将测量的时间转换成距离 Serial.print(&quot;Distance = &quot;); if (distance &gt;= MAX_DISTANCE || distance &lt;= 2) &#123; Serial.println(&quot;Out of range&quot;); &#125; else &#123; Serial.print(distance); Serial.println(&quot; cm&quot;); &#125;&#125; 经测试，结果如下 注意，当靠的太近时，距离不准，会增加。本代码对数据只进行求平均处理，可用其他方法进行滤波。减小误差。 2.4 4PIN-OLED 小屏幕的驱动 应用场景：1.\t显示输出2.\t多级菜单3.\t表情显示 可3.3V或者5V输入，一般使用有多重库函数，这里使用u8g2库SCL接A5,SDA接A4，示例如下 使用：首先要安装u8g2库，该库可以驱动4pin,0.96寸OLED小屏幕 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;U8g2lib.h&gt; //u8g2库#define SCL A5 //引脚定义，可替换为数字引脚#define SDA A4U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0,SCL,SDA); //配置构造函数 int a=66; //定义变量a=66void setup() &#123; u8g2.begin(); //启动u8g2驱动程序 u8g2.clearBuffer(); //清空显示屏缓存&#125;void loop() &#123; face(); //调用函数，显示图案 delay(1000); //持续一秒钟 heart(); //调用函数，显示英文字母和图案 delay(1000); //持续一秒钟 letter(a); //调用函数，显示中文和变量 delay(1000); //持续一秒钟&#125;void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; void heart()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.setFont(u8g2_font_open_iconic_human_2x_t); // 设置字体 u8g2.drawGlyph(58,30,66); // 画心，符号左下角坐标为（58,36），符号编号为66 u8g2.setFont(u8g2_font_unifont_t_chinese2); //设置字体 u8g2.drawUTF8(58+20,30,&quot;ZFY&quot;); //显示英文，左下角位置坐标为（78，30） u8g2.drawUTF8(58-14-16,30,&quot;JHR&quot;); //显示英文，左下角位置坐标为（28，30） u8g2.sendBuffer(); // 加载以上内容&#125; void letter(int a)&#123; u8g2.clearBuffer(); //清空显示屏缓存 //int8_t a=u8g2.getMaxCharHeight(); //获取最大高度 //int8_t b=u8g2.getMaxCharWidth(); //获取最大宽度 u8g2.setFont(u8g2_font_unifont_t_chinese2); //设置字体 u8g2.drawUTF8(20,17,&quot;智能检测系统&quot;); //显示文字，左下角位置坐标为（20，17） u8g2.drawUTF8(50,34,&quot;：&quot;); //显示:，左下角坐标为（50,34） u8g2.drawUTF8(0,34,&quot;位移为:&quot;); u8g2.setCursor(64,34); //设置将要打印变量的左下角坐标 u8g2.drawUTF8(0,34,&quot;位移为:&quot;); u8g2.print(a); //打印变量a u8g2.sendBuffer(); // 加载以上内容 &#125; 屏幕显示还有ISP协议的，这种一般为7PIN，这里只介绍相对简单，接线少，使用I2C协议的4pin,0.96寸OLED屏幕。 2.5温湿度传感器 使用DHT11，温湿度传感器还有其他类型DHT22等应用场景1.\t温湿度检测2.\t小闹钟配件 引脚正对着自己，从左至右。 使用，安装库Adafruit Unified Sensor及DHT-sensor-library两个库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 需要以下 Arduino 库：// - DHT 传感器库：https://github.com/adafruit/DHT-sensor-library// - Adafruit 统一传感器库：https://github.com/adafruit/Adafruit_Sensor#include &quot;DHT.h&quot;#define DHTPIN 2 // 连接到 DHT 传感器的数字引脚// Feather HUZZAH ESP8266 注意：使用引脚 3, 4, 5, 12, 13 或 14 --// 引脚 15 也可以使用，但在上传程序时必须断开 DHT 连接。// 取消注释你正在使用的传感器类型！#define DHTTYPE DHT11 // DHT 11//#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321//#define DHTTYPE DHT21 // DHT 21 (AM2301)// 将传感器的引脚 1（左边的）连接到 +5V// 注意：如果使用 3.3V 逻辑电平的板子（如 Arduino Due），将引脚 1 连接到 3.3V 而不是 5V！// 将传感器的引脚 2 连接到 DHTPIN// 将传感器的引脚 3（右边的）连接到 GND（如果传感器有 3 个引脚）// 将传感器的引脚 4（右边的）连接到 GND，并且引脚 3 空置（如果传感器有 4 个引脚）// 将一个 10K 电阻从传感器的引脚 2（数据）连接到引脚 1（电源）// 初始化 DHT 传感器。// 注意：旧版本的库有一个可选的第三参数来调整较快处理器的时序。// 现在不再需要这个参数，因为当前的 DHT 读取算法会自适应较快的处理器。DHT dht(DHTPIN, DHTTYPE);void setup() &#123; Serial.begin(9600); Serial.println(F(&quot;DHTxx test!&quot;)); dht.begin();&#125;void loop() &#123; // Wait a few seconds between measurements. delay(2000); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds &#x27;old&#x27; (its a very slow sensor) float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht.readTemperature(true); // 检查是否有读取失败并提前退出（以便重试） if (isnan(h) || isnan(t) || isnan(f)) &#123; Serial.println(F(&quot;Failed to read from DHT sensor!&quot;)); return; &#125; // Compute heat index in Fahrenheit (the default) float hif = dht.computeHeatIndex(f, h); // Compute heat index in Celsius (isFahreheit = false) float hic = dht.computeHeatIndex(t, h, false); Serial.print(F(&quot;Humidity: &quot;)); Serial.print(h); Serial.print(F(&quot;% Temperature: &quot;)); Serial.print(t); Serial.print(F(&quot;°C &quot;)); Serial.print(f); Serial.print(F(&quot;°F Heat index: &quot;)); Serial.print(hic); Serial.print(F(&quot;°C &quot;)); Serial.print(hif); Serial.println(F(&quot;°F&quot;));&#125; 2.6HW504摇杆的使用 引脚说明GND 地5V 电源5VSW 按键（数字量）VRX X轴 （模拟量）VRY Y轴 （模拟量）1.输入电压范围：直流3.3V 至 5V。2.输出信号：模块特设二路模拟输出和一路数字输出接口，输出值分别对应（X，Y）双轴偏移量，其类型为模拟量；按键表示用户是否在Z轴上按下，其类型为数字开关量VRx，VRy （X、Y轴）为模拟输入信号，连接到模拟IO口A0A7。VRx，VRy 的值：从 0 ~ 1023 分别代表 左右，上~下。中间值为512。SW （Z轴）是数字输入信号，连接到数字端口，并启用上拉电阻。SW 的值：1代表未按下，0代表按下。实验这里VRx接A0，VRy接A1，SW接D6 12345678910111213141516171819int value = 0;void setup()&#123; pinMode(6, INPUT_PULLUP); Serial.begin(115200);&#125; void loop()&#123; value = analogRead(A0); Serial.print(&quot;X:&quot;); Serial.print(value, DEC); value = analogRead(A1); Serial.print(&quot; | Y:&quot;); Serial.print(value, DEC); value = digitalRead(6); Serial.print(&quot; | Z: &quot;); Serial.println(value, DEC); delay(100);&#125; 2.7WIFI模块的使用这里我们使用的是4Pin的ESP8266模块,这里只做简单的介绍，具体可后面学习ESP32.ESP8266模块内置TCP&#x2F;IP协议，能够实现串口与WIFI之间的转换。该模块有三种工作WIFI模式，STA,AP,STA+AP.STA,客户端模式，可连接其他WIFI,手机等设施实现对设备的远程连接。AP，接入点模式，模块作为WIFi热点。STA+AP,混合模式。 123456789101112131415161718#include&lt;SoftwareSerial.h&gt;#define rxPin 2#define txPin 3SoftwareSerial ESP8266(rxPin,txPin);void setup() &#123; // put your setup code here, to run once: Serial.begin(115200); ESP8266.begin(115200);&#125;void loop() &#123; // put your main code here, to run repeatedly: if(ESP8266.available()) Serial.write(ESP8266.read()); else if(Serial.available()) ESP8266.write(Serial.read());&#125; 测试，在串口里输入AT,会返回OK; 2.8\t其他Arduino uno的模块还有蓝牙模块等，不过感觉有些鸡肋，使用uno的板子搭配这些模块，不如直接买esp32.所以一些无线通讯的模块就不介绍了。Arduino的外设很丰富，这里就不多介绍了。 第三章\t电机的驱动3.1PWM波的认识PWM（Pulse Width Modulation，脉宽调制）是一种用于模拟信号和功率控制的技术，通过改变脉冲的宽度来调节信号的平均电压或功率.PWM 信号在一定周期内以高电平和低电平交替出现，通过改变高电平的持续时间（占空比）来实现对输出电压或功率的调节。应用场景有电机控制，LED调光，电源转换和通信等。 PWM的重要参数有，-\t频率（Frequency）：频率的选择取决于具体应用。例如，电机控制通常使用几千赫兹的频率，而 LED 调光可能使用几百赫兹到几千赫兹。-\t占空比（Duty Cycle）：占空比是指高电平时间相对于一个周期的比例，通常用百分比表示-\t分辨率（Resolution）：分辨率是指占空比可调节的最小步进，通常与控制器的位数有关。例如，8 位分辨率的 PWM 控制器可以将占空比调整到 256 个不同的级别。-\t电压幅度（Voltage Amplitude）：PWM 信号的高电平和低电平的电压值。高电平通常是电源电压（如 5V 或 3.3V），低电平通常是 0V。 一般而言，要特别注意频率，频率过低，在驱动电机时可能出现异常，电机哮鸣。一般电机是需要较高频率的PWM信号控制.单片机的PWM一般作为信号使用，驱动一些小功率LED时，可作为电源使用。 3.2 PWM波驱动小功率直流电机我们在前面学习到，UNO的数字引脚上有几个特定引脚可以输出PWM波，分别为3,5,6,9,10,11.但是这种方式 PWM 信号的频率是固定的默认值，引脚上的 PWM 信号频率约为490 Hz，在 Uno板上，引脚5和6的频率约为980Hz。 123456789# define analogPin 3 // 引脚命名void setup()&#123; pinMode(analogPin,OUTPUT);&#125;void loop()&#123; analogWrite(analogPin,100); // 输出PWM，占空比为 100/255&#125; 通过这种方法产生的PWM波频率过低，在驱动电机时可能出现异常。因此需要输出更高频率的PWM信号。此时，小功率的直流电机一端接GND,一端接3号引脚也是可以驱动的，通过调节占空比即可调节速率。为了使PWM的发生不占用主进程，这里使用定时器来操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 通过一个除数来分频给定的 PWM 引脚频率。 * 生成的频率等于基频除以给定的除数： * – 基频： * o 引脚 3、9、10 和 11 的基频是 31250 Hz。 * o 引脚 5 和 6 的基频是 62500 Hz。 * – 除数： * o 引脚 5、6、9 和 10 可用的除数有：1、8、64、256 和 1024。 * o 引脚 3 和 11 可用的除数有：1、8、32、64、128、256 和 1024。 * PWM 频率成对关联。如果一对中的一个改变，另一个也会改变以匹配： * – 引脚 5 和 6 在定时器0上成对 * – 引脚 9 和 10 在定时器1上成对 * – 引脚 3 和 11 在定时器2上成对 * * 请注意，此函数会对其他使用定时器的内容产生副作用： * – 改变引脚 3、5、6 或 11 可能会导致 delay() 和 millis() 函数停止工作。其他与定时相关的函数也可能受到影响。 * – 改变引脚 9 或 10 会导致 Servo 库无法正常工作。 * * 感谢 Arduino 论坛的 macegr 提供的 PWM 频率除数文档。他的帖子可以在以下链接查看： * http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1235060559/0#4 */void setup() &#123;// Set pin 6’s PWM frequency to 62500 Hz (62500/1 = 62500)// Note that the base frequency for pins 5 and 6 is 62500 Hz setPwmFrequency(6, 1); analogWrite(6,124);&#125;void loop() &#123;&#125;void setPwmFrequency(int pin, int divisor) &#123; byte mode; if(pin == 5 || pin == 6 || pin == 9 || pin == 10) &#123; switch(divisor) &#123; case 1: mode = 0x01; break; case 8: mode = 0x02; break; case 64: mode = 0x03; break; case 256: mode = 0x04; break; case 1024: mode = 0x05; break; default: return; &#125; if(pin == 5 || pin == 6) &#123; TCCR0B = TCCR0B &amp; 0b11111000 | mode; &#125; else &#123; TCCR1B = TCCR1B &amp; 0b11111000 | mode; &#125; &#125; else if(pin == 3 || pin == 11) &#123; switch(divisor) &#123; case 1: mode = 0x01; break; case 8: mode = 0x02; break; case 32: mode = 0x03; break; case 64: mode = 0x04; break; case 128: mode = 0x05; break; case 256: mode = 0x06; break; case 1024: mode = 0x07; break; default: return; &#125; TCCR2B = TCCR2B &amp; 0b11111000 | mode; &#125;&#125; 示波器测量频率为62.5KHZ,改变下面的124,改变占空比，占空比0-255。 analogWrite(6,124); 3.3\tL298N的使用与双路电机驱动 供电方式：-\t7-12V电源走VCC供电，电源上的跳线帽连接，5v的位置不用接电源，该位置可输出一个5v，可用于给单片机供电。-\t当输入电压大于12v时，需要拔掉电源旁的跳线帽，5V端需要接入5v的电压，GND还是接GND-\t接入5V电源， L298N的12V和5V都接5V供电。 注意：GND不但要接驱动电源的GND，一定要从这里再引出一根GND和单片机或者系统的GND相连,使电压有参考电平 控制引脚 IN1 &amp; IN2 电机驱动器A的输入引脚，控制电机A转动及旋转角度 IN1输入高电平HIGH，IN2输入低电平LOW，对应电机A正转 IN1输入低电平LOW，IN2输入高电平HIGH，对应电机A反转 IN1、IN2同时输入高电平HIGH或低电平LOW，对应电机A停止转动 调速就是改变IN1、IN2高电平的占空比（需插上ENA处跳帽） IN3 &amp; IN4 电机驱动器B的输入引脚，控制电机B转动及旋转角度 IN3输入高电平HIGH，IN4输入低电平LOW，对应电机B正转 IN3输入低电平LOW，IN4输入高电平HIGH，对应电机B反转 IN3、IN4同时输入高电平HIGH或低电平LOW，对应电机B停止转动调速就是改变IN3、IN4高电平的占空比（需插上ENB处跳帽） 控制有两种方式，以一边电机为例：1.\tENA,引脚通过跳帽线与+5V连接，IN1悬空或接GND,IN2输入PWM信号。2.\tENA拔掉跳帽线，输入PWM信号，IN1接1，IN2接0。改变IN1与IN2的值就可以停止或正反转。 3.4舵机的驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 12345678910111213141516171819202122232425262728293031323334353637/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 3.5 其他还有无刷电机，步进电机，arduino驱动这些电机设备时，一般不直接驱动，中间都会连接一个驱动模块，上文的L298N就是一种驱动模块。 第四章\t成品制作4.1可以制作哪些？如何制作？个人DIY时，除了学习单片机外，还需要学习PCB焊接和3D打印的一些知识，并且熟悉一些常见的DIY材料，丙烯颜料，环氧树脂等，以及钳子，等常见工具的使用。当然最最最重要的是热爱。基于UNO，我们可以做出很多有意思的作 品，小时钟，个性灯等，在开源社区有很多有意思的作品，可以自行搜索。","tags":["arduino"]},{"title":"无聊的盒子-二代","path":"/2024/09/04/无聊的盒子-二代/","content":"前言小的练习项目，熟悉pcb制版和solidwoks技能总体框架 硬件 PCB 3D建模 软件 arduino PCB绘制包括两块板，拓展板和核心板。核心板淘宝买，这里做拓展板实现功能有 充电 供电 引脚引出","tags":["PCB"]},{"title":"室外组二代车上手记录","path":"/2024/08/06/室外组二代车上手记录/","content":"碎碎念8月5号拿到室外组二代新车，人有点麻，一方面比赛日期临近，而且二队还没有车。新车上手后，发现问题很多，首先是密码登不上去，车的所有USB端口都被占满，而且昇腾310的板没有内置wifi,300块的树莓派都有wifi,他没有，而且系统是Ubuntu22(魔改版，单内核)的，只有这个版本的镜像，这导致无法在原生环境跑ros1,赛事方给出的解决方法是在root用户在跑linux容器，容器为ubuntu20,在此跑ros，然后通过与用户ubuntu20的电脑使用ros的主从机和ssh连接实现远程部分可视化操作我的评价是，脑残，傻逼操作，垃圾昇腾上位机板卡没wifi，支持的镜像也少，官网查询板卡资料，还带锁，各种注册，还要序列号申请，垃圾板卡，狗都不用。工控机都比他强碎碎念结束，不管这么说，比赛还是要继续的。 vim常见命令及操作首先，关闭大写锁定，切换为英语小写模式 基础操作 进入文件 vim 文件名，文件不存在会创建文件 按a或i进入编辑模式，此时左下方显示 –INSERT–，o新增加一行，进入编辑模式 输入文本，后按Ese退出编辑模式，输入:,进入命令行模式 q为不保存退出，wq为保存退出 shift+i，在此行最前面加内容，shift+a，在此行最后面就内容 普通模式输入gg，光标回到起头，输入shift+g，光标回到最后 配置 小插曲，突然发现图床用不了了，检查发现系统时间用问题，更新一下就可以了，时间问题是因为双系统切换导致的，具体原因不明 输入 vim –version 打开其中的$HOME&#x2F;.vimrcVim $HOME&#x2F;.vimrc 增加set numbervim显示行号 进阶操作 gg-到第一行 shift + g 最后一行 yy-复制当前行 dd-删除当前行 u-撤销前次操作 .重复前次操作 &#x2F; 搜索 :&#x2F;%s&#x2F;原单词&#x2F;新单词&#x2F;g zip常见操作 zip的安装，打开终端输入下面两行,安装 zip 和 unzip 12sudo apt updatesudo apt install zip unzip 基本创建 12345zip archive_name.zip file1 file2# 这个命令将 file1 和 file2 压缩到一个名为 archive_name.zip 的ZIP文件中zip -r archive_name.zip directory_name# 使用 -r 选项可以递归地将整个目录（包括其子目录和文件）压缩到ZIP文件中。 解压ZIP文件 12345678unzip archive_name.zip# 这个命令将 archive_name.zip 文件中的所有内容解压到当前目录。unzip archive_name.zip -d destination_directory# 使用 -d 选项可以将ZIP文件的内容解压到指定的目录 destination_directory 中。unzip -o archive_name.zip# 使用 -o 选项将覆盖现有的文件。 linux系统操作命令行12345678910111213141516171819202122232425262728293031323334# 过于基本的就略过了mkdir directory_name创建目录rm -r directory_name删除非空目录cp source_file destination_file复制文件或目录mv source_file destination_file移动文件或目录mv old_name new_name重命名文件chmod -R 777 /path/to/directory赋予文件夹下所有文件777权限ps显示当前用户的进程top实时显示系统进程uname -a显示系统信息free -h显示内存使用情况du -sh [目录]显示指定目录的磁盘使用情况 与功能包安装及下载相关12345678910111213141516171819首先检查网路，并且检查时间的准确性ping baidu.comsudo apt-get update更新包列表sudo apt-get install [包名]安装软件包sudo apt-get remove [包名]卸载软件包sudo apt update更新源sudo apt install ros-版本-库名ros相关包安装，版本有noetic,等 ros车设置新车实录 警告1，所有的端口定义与官方给的教程并不相同，而且雷达端口在车辆启动后拔插会导致该端口丢失。所以开机后不要尝试拔插雷达口，所有USB接口已用小标签标注 警告2,由于升腾的板卡没有WiFi模块，所以通过拓展坞插上网口，连接有网的路由器后，还需要拔掉车载路由器与板卡的网线，否则没有网 警告3,小车的ROS相关进程需要在固定IP下才能运行，该固定IP是由车载路由器固定，也就是说在通过网卡联网时，ROS相关程序会报错，找不到IP之类的，秉持有用就不折腾的原则，ROS关于IP的配置文件就不更改了，后来者自行调整。 室外组上手 镜像 前期准备打开车和电脑从机，电脑链接下车wifi 终端链接，密码Mind@123打开VScode，远程链接小车主机 建图将车放在出发区，位置要记住 在终端出运行 python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;map_wj.py 运行前打开底盘，运行后，底盘控制小车建图，建完图后，在键盘控制的终端里按g保存地图 打点建完图后，vscode重开一个终端 python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;run_way_point_click.py 运行后输入1或2回车，打开从机的rviz，挂载rviz.rviz 如何挂载rviz,点击file，点击rencent config,选择rviz.rviz,如果你是第一次打开，点击open config 在rviz（已经放在代码文件下）文件夹中找到rviz.rviz 点击2D Nav Goal开始打点，打完点后，再次点击2D Nav Goal，使点位与最后一个重合，终端窗口显示，保存成功。 如果选择的是1，可以点击PUBlish Point ，点击空白处，显示之前打的点位，点击publish Point,点击要更改的点，点击 红绿灯与斑马线停车点位修改修改start_light_post ，white_go，while_back 开跑将车放在起始点，运行 python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;wj_run.py打开rviz，配置文件选择acml_rviz.rviz在python3 &#x2F;racecar&#x2F;src&#x2F;auto_car&#x2F;scripts&#x2F;wj_run.py代码下的终端回车，车辆开跑。 速度更改vp_min 跑的不好的话，更改点位，再次跑 代码讲解代码分为3个部分，建图，打点，启动代码程序总结构 建图代码map_wj.py 文件map_wj.py，这个代码是建图文件总得启动代码，主要启动两个roslaunch节点和一个python文件。其中使用subprocess库可以方便在该文件在命令行窗口启动其他窗口，subprocess是非阻塞，打开后和在命令行窗口运行的本程序失去关系，无法通过关闭命令行窗口的方式关闭其打开的其他程序，所以需要使用ps aux | grep ros | xargs -n 1 kill -9 关闭其打开的其他程序，主要是ros程序。在建图方面主要做的工作是将多个命令集成到一个python文件中，方便操作。 123456789101112131415161718192021222324import subprocessimport timeimport os# ps aux | grep ros | xargs -n 1 kill -9# 杀死所有ros相关的终端# stdout=subprocess.DEVNULL 和 stderr=subprocess.DEVNULL 会将标准输出和标准错误重定向到 DEVNULL，这意味着它们不会被打印到终端。# 启动 Run_car.launch，不打印输出subprocess.Popen(&quot;roslaunch racecar Run_car.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;Run_car.launch已执行&quot;)time.sleep(3)# 启动 Run_gmapping.launch，不打印输出subprocess.Popen(&quot;roslaunch racecar Run_gmapping_wy.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;Run_gmapping已执行&quot;)time.sleep(3)# 启动 python 脚本，打印输出，按g保存文件，小写！cmd = &quot;python3 /racecar/src/auto_car/scripts/racecar_teleop.py&quot;os.system(cmd)# subprocess是非阻塞的，os.system(cmd)是阻塞的 Run_gmapping_wy.py Run_gmapping_wy.py这个是gmapping建图的配置文件，可以通过这个文件改变建图的大小，分辨率，雷达有效范围等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;!-- &lt;arg name=&quot;use_rviz&quot; default=&quot;true&quot; /&gt; --&gt; &lt;!-- ODOMETRY --&gt; &lt;!--rf2o_Laser_Odometry--&gt; &lt;include file=&quot;$(find racecar)/launch/includes/rf2o.launch.xml&quot; /&gt; &lt;!-- wheel odometry --&gt; &lt;include file=&quot;$(find encoder_driver)/launch/wheel_odom.launch&quot;/&gt; &lt;!-- Robot_Localization --&gt; &lt;node pkg=&quot;robot_localization&quot; type=&quot;ekf_localization_node&quot; name=&quot;ekf_se&quot; clear_params=&quot;true&quot;&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find racecar)/param/ekf_params.yaml&quot; /&gt; &lt;/node&gt; &lt;!-- gmapping --&gt; &lt;node pkg=&quot;gmapping&quot; type=&quot;slam_gmapping&quot; name=&quot;slam_gmapping&quot; output=&quot;screen&quot;&gt; &lt;remap from=&quot;scan&quot; to=&quot;scan&quot;/&gt; &lt;param name=&quot;map_update_interval&quot; value=&quot;2&quot;/&gt; &lt;param name=&quot;maxUrange&quot; value=&quot;4&quot;/&gt; &lt;param name=&quot;sigma&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;kernelSize&quot; value=&quot;1&quot;/&gt; &lt;param name=&quot;lstep&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;astep&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;iterations&quot; value=&quot;5&quot;/&gt; &lt;param name=&quot;lsigma&quot; value=&quot;0.075&quot;/&gt; &lt;param name=&quot;ogain&quot; value=&quot;3.0&quot;/&gt; &lt;param name=&quot;lskip&quot; value=&quot;0&quot;/&gt; &lt;param name=&quot;srr&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;srt&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;str&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;stt&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;linearUpdate&quot; value=&quot;0.10&quot;/&gt; &lt;param name=&quot;angularUpdate&quot; value=&quot;0.25&quot;/&gt; &lt;param name=&quot;temporalUpdate&quot; value=&quot;1.0&quot;/&gt; &lt;param name=&quot;resampleThreshold&quot; value=&quot;0.25&quot;/&gt; &lt;param name=&quot;particles&quot; value=&quot;30&quot;/&gt; &lt;param name=&quot;xmin&quot; value=&quot;-50.0&quot;/&gt; &lt;param name=&quot;ymin&quot; value=&quot;-50.0&quot;/&gt; &lt;param name=&quot;xmax&quot; value=&quot;50.0&quot;/&gt; &lt;param name=&quot;ymax&quot; value=&quot;50.0&quot;/&gt; &lt;param name=&quot;delta&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;llsamplerange&quot; value=&quot;0.01&quot;/&gt; &lt;param name=&quot;llsamplestep&quot; value=&quot;0.01&quot;/&gt; &lt;param name=&quot;lasamplerange&quot; value=&quot;0.005&quot;/&gt; &lt;param name=&quot;lasamplestep&quot; value=&quot;0.005&quot;/&gt; &lt;param name=&quot;odom_frame&quot; value=&quot;odom&quot;/&gt; &lt;param name=&quot;base_frame&quot; value=&quot;base_footprint&quot;/&gt; &lt;/node&gt; &lt;!-- Rviz --&gt; &lt;!-- &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find racecar)/rviz/gmapping.rviz&quot; if=&quot;$(arg use_rviz)&quot;/&gt; --&gt;&lt;/launch&gt; Run_car.launch这个代码是底盘控制代码，开启这个代码能够开启上位机ros对下位机发送速度指令,下车速度话题名为car&#x2F;cmd_vel，其他话题运行该launch文件后，使用rostopic list 查看 racecar_teleop.py这是一个键盘控制小车移动的代码，具体操作键见具体代码在官方代码里补充了一个按g，保存地图到指定位置的代码行 1234elif key == &#x27;g&#x27; : cmd = &quot;rosrun map_server map_saver -f /racecar/src/auto_car/rengong&quot; os.system(cmd) break 打点 run_way_point_click.py，该程序实现的功能是通过订阅rviz发布的点位将其储存到配置文件中，启动实跑时，将点位发布出去，实现导航 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import osimport rospyfrom geometry_msgs.msg import PointStamped, PoseStampedfrom nav_msgs.msg import Pathfrom scipy.interpolate import splprep, splevimport numpy as npimport jsonfrom visualization_msgs.msg import Marker, MarkerArrayimport timeimport subprocessprint(&quot;是否加载历史json文件: 1.是 2.否，丢弃旧数据 请输入数字1或2：&quot;)data = []clicked_point = -1number = input()if number == &quot;1&quot;: with open(&#x27;/racecar/src/auto_car/scripts/waypoint.json&#x27;,&quot;r&quot;) as f: data = json.load(f)[&quot;waypoint&quot;] f.close()# os.system(f&quot;gnome-terminal -e &#x27;bash -c \\&quot;roslaunch /home/racecar/car_2024_rengong/src/auto_go/launch/path_click.launch; exec bash\\&quot;&#x27;&quot;)subprocess.Popen(&quot;roslaunch /racecar/src/auto_car/launch/path_click.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)rospy.sleep(3)rospy.init_node(&#x27;way_point_click&#x27;, anonymous=True)# 在rviz里显示箭头def show_arrow(): global clicked_point,data marker_array = MarkerArray() for i,d in enumerate(data): marker = Marker() marker.header.frame_id = &quot;map&quot; marker.type = marker.ARROW marker.action = marker.ADD marker.ns = &quot;marker&quot; marker.scale.x = 0.5 marker.scale.y = 0.1 marker.scale.z = 0.1 marker.color.a = 1.0 marker.color.r = 0.0 marker.color.g = 1.0 marker.color.b = 0.0 if i==clicked_point: marker.color.r = 1.0 marker.color.g = 0.0 marker.color.b = 0.0 marker.pose.position.x = d[0] marker.pose.position.y = d[1] marker.pose.position.z = 0.0 marker.pose.orientation.w = d[2] marker.pose.orientation.x = d[3] marker.pose.orientation.y = d[4] marker.pose.orientation.z = d[5] marker_array.markers.append(marker) id = 0 for m in marker_array.markers: m.id = id id += 1 marker_pub.publish(marker_array)def click_goal_callback(msg): global data, clicked_point if clicked_point==-1: if len(data)&gt;0 and (msg.pose.position.x-data[-1][0])**2 + (msg.pose.position.y-data[-1][1])**2 &lt; 0.1: # 保存数据 with open(&#x27;/racecar/src/auto_car/scripts/waypoint.json&#x27;,&quot;w&quot;) as f: json.dump(&#123;&quot;waypoint&quot;:data&#125;,f) f.close() print(&quot;保存成功&quot;) return data.append([msg.pose.position.x,msg.pose.position.y,msg.pose.orientation.w,msg.pose.orientation.x,msg.pose.orientation.y,msg.pose.orientation.z]) else: data[clicked_point][0] = msg.pose.position.x data[clicked_point][1] = msg.pose.position.y data[clicked_point][2] = msg.pose.orientation.w data[clicked_point][3] = msg.pose.orientation.x data[clicked_point][4] = msg.pose.orientation.y data[clicked_point][5] = msg.pose.orientation.z clicked_point = -1 show_arrow()def clicked_callback(msg): # 寻找最近的点 global data, clicked_point x = msg.point.x y = msg.point.y if len(data) == 0: return min_dis = 100000 min_index = 0 for i in range(len(data)): dis = (x-data[i][0])**2 + (y-data[i][1])**2 if dis &lt; min_dis: min_dis = dis min_index = i if min_dis&lt;0.1: clicked_point = min_index else: clicked_point = -1 show_arrow() marker_pub = rospy.Publisher(&quot;/my_marker&quot;, MarkerArray, queue_size=5)rospy.Subscriber(&quot;/move_base_simple/goal&quot;, PoseStamped, click_goal_callback)rospy.Subscriber(&quot;clicked_point&quot;, PointStamped, clicked_callback)show_arrow()# 订阅move_base_sarospy.spin() 启动wj_run.py 启动脚本，集成了底盘launch文件，导航launch文件，控制主程序wj_go_hh.py 1234567891011121314import subprocessimport timeimport ossubprocess.Popen(&quot;roslaunch racecar Run_car.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;Run_car.launch已执行&quot;)time.sleep(3)subprocess.Popen(&quot;roslaunch racecar amcl_nav_wy.launch&quot;, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)print(&quot;amcl_nav_wy.launch已执行&quot;)time.sleep(2)# 启动 python 脚本cmd = &quot;python3 /racecar/src/auto_car/scripts/wj_go_hh.py&quot;os.system(cmd) amcl_nav_wy.launch Run_car.launch文件上面已经介绍过了，这里就不介绍了，acml_nav_wy.launch文件是导航控制文件该文件同级目录下还有一个文件acml_nav.launch，是官方原文件，这里对他进行了修改，主要在move_base进行修改，由于实际上局部路径规划并没有用到，这里就将其注释掉了，其中，该文件，调用了acml，controller也会介绍param name&#x3D;”base_global_planner” value&#x3D;”navfn&#x2F;NavfnROS”&#x2F;该文件中使用的全局路径规划器为NavfnROS,而不是GlobalPlanner，由于时间较短没有测试两者区别。这里的controller控制器代替了局部路径规划器的功能。这里介绍一下导航控制代码的总体思路。wj_run.py脚本会启动底盘节点，导航节点，wj_go_hh.py文件。wj_go_hh.py会读取之前打点的参数文件，按先后顺序发布，导航节点会调用全局路径规划器，计算出此时位置倒目标点的路径，由node pkg&#x3D;”racecar” type&#x3D;”car_controller_new” respawn&#x3D;”false” name&#x3D;”car_controller” output&#x3D;”screen运行的car_controller_new.cpp文件负责发布car&#x2F;cmd_vel速度与舵机话题控制下位机实现底盘运动。这个代码后面会介绍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;arg name=&quot;use_rviz&quot; default=&quot;flase&quot; /&gt; &lt;!-- for amcl --&gt; &lt;arg name=&quot;init_x&quot; default=&quot;0.0&quot; /&gt; &lt;arg name=&quot;init_y&quot; default=&quot;0.0&quot; /&gt; &lt;arg name=&quot;init_a&quot; default=&quot;0.0&quot; /&gt; &lt;!-- Map server --&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;map_to_odom&quot; args=&quot;0.0 0.0 0.0 0 0 0.0 /map /odom 1000&quot;/&gt; &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;base_to_laser&quot; args=&quot;0.0 0.0 0.0 0 0 0.0 /base_link /laser 1000&quot;/&gt; &lt;node name=&quot;map_server&quot; pkg=&quot;map_server&quot; type=&quot;map_server&quot; args=&quot;$(find auto_car)/rengong.yaml&quot;/&gt; &lt;!-- ODOMETRY --&gt; &lt;!--rf2o_Laser_Odometry--&gt; &lt;include file=&quot;$(find racecar)/launch/includes/rf2o.launch.xml&quot; /&gt; &lt;!-- wheel odometry --&gt; &lt;include file=&quot;$(find encoder_driver)/launch/wheel_odom.launch&quot;/&gt; &lt;!-- Robot_Localization --&gt; &lt;node pkg=&quot;robot_localization&quot; type=&quot;ekf_localization_node&quot; name=&quot;ekf_se&quot; clear_params=&quot;true&quot;&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find racecar)/param/ekf_params.yaml&quot; /&gt; &lt;/node&gt; &lt;!-- Localization --&gt; &lt;!-- AMCL --&gt; &lt;include file=&quot;$(find racecar)/launch/includes/amcl.launch.xml&quot;&gt; &lt;arg name=&quot;init_x&quot; value=&quot;$(arg init_x)&quot;/&gt; &lt;arg name=&quot;init_y&quot; value=&quot;$(arg init_y)&quot;/&gt; &lt;arg name=&quot;init_a&quot; value=&quot;$(arg init_a)&quot;/&gt; &lt;/include&gt; &lt;!-- Navstack --&gt; &lt;node pkg=&quot;move_base&quot; type=&quot;move_base&quot; respawn=&quot;false&quot; name=&quot;move_base&quot;&gt; &lt;!-- local planner --&gt; &lt;!-- &lt;param name=&quot;base_global_planner&quot; value=&quot;global_planner/GlobalPlanner&quot;/&gt; --&gt; &lt;param name=&quot;base_global_planner&quot; value=&quot;navfn/NavfnROS&quot;/&gt; &lt;!--param name=&quot;base_local_planner&quot; value=&quot;dwa_local_planner/DWAPlannerROS&quot;/--&gt; &lt;!--rosparam file=&quot;$(find racecar)/param/dwa_local_planner_params.yaml&quot; command=&quot;load&quot;/--&gt; &lt;!-- costmap layers --&gt; &lt;!-- rosparam file=&quot;$(find racecar)/param/local_costmap_params.yaml&quot; command=&quot;load&quot;/--&gt; &lt;rosparam file=&quot;$(find racecar)/param/global_costmap_params.yaml&quot; command=&quot;load&quot;/&gt; &lt;!-- move_base params --&gt; &lt;rosparam file=&quot;$(find racecar)/param/base_global_planner_params.yaml&quot; command=&quot;load&quot;/&gt; &lt;rosparam file=&quot;$(find racecar)/param/move_base_params.yaml&quot; command=&quot;load&quot;/&gt; &lt;remap from=&quot;/odom&quot; to=&quot;/odometry/filtered&quot;/&gt; &lt;/node&gt; &lt;node pkg=&quot;racecar&quot; type=&quot;car_controller_new&quot; respawn=&quot;false&quot; name=&quot;car_controller&quot; output=&quot;screen&quot;&gt; &lt;param name=&quot;Vcmd&quot; value=&quot;2.0&quot; /&gt; &lt;!--speed of car m/s --&gt; &lt;!-- ESC --&gt; &lt;param name=&quot;baseSpeed&quot; value=&quot;60&quot;/&gt; &lt;param name=&quot;baseAngle&quot; value=&quot;0.0&quot;/&gt; &lt;param name=&quot;Angle_gain_p&quot; value=&quot;-5.0&quot;/&gt; &lt;param name=&quot;Angle_gain_d&quot; value=&quot;-0.0&quot;/&gt; &lt;param name=&quot;Lfw&quot; value=&quot;1.5&quot;/&gt; &lt;param name=&quot;vp_max_base&quot; value=&quot;80&quot;/&gt; &lt;param name=&quot;vp_min&quot; value=&quot;50&quot;/&gt; &lt;/node&gt; &lt;!-- Rviz --&gt; &lt;!-- &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=:&quot;rviz&quot; args=&quot;-d $(find racecar)/rviz/amcl.rviz&quot; if=&quot;$(arg use_rviz)&quot; /&gt; --&gt;&lt;/launch&gt; amcl.launch.xml src\\racecar\\launch\\includes\\amcl.launch.xml该文件是acml配置文件其中param name&#x3D;”tf_broadcast” value&#x3D;”false”&#x2F;该参数表示是否将计算的位姿发布到全局，这里我选择了false,由于之前的一代车雷达位姿计算不准，导致位姿乱跳，二代车位姿尚可，但未测试。在位姿计算准确的情况下，可以防止车辆跑的过程中雷达扫到的图和与建的图不重合，有较大偏差。其他参数chat搜索。自行添加注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot;?&gt;&lt;launch&gt; &lt;arg name=&quot;init_x&quot; default=&quot;0&quot; /&gt; &lt;arg name=&quot;init_y&quot; default=&quot;0&quot; /&gt; &lt;arg name=&quot;init_a&quot; default=&quot;0&quot; /&gt; &lt;node pkg=&quot;amcl&quot; type=&quot;amcl&quot; name=&quot;amcl&quot; output=&quot;screen&quot;&gt; &lt;!-- Publish scans from best pose at a max of 10 Hz --&gt; &lt;param name=&quot;transform_tolerance&quot; value=&quot;1.0&quot; /&gt; &lt;param name=&quot;gui_publish_rate&quot; value=&quot;10.0&quot;/&gt; &lt;param name=&quot;laser_max_beams&quot; value=&quot;10&quot;/&gt; &lt;param name=&quot;min_particles&quot; value=&quot;100&quot;/&gt; &lt;param name=&quot;max_particles&quot; value=&quot;5000&quot;/&gt; &lt;param name=&quot;kld_err&quot; value=&quot;0.01&quot;/&gt; &lt;param name=&quot;kld_z&quot; value=&quot;0.99&quot;/&gt; &lt;!-- translation std dev, m --&gt; &lt;param name=&quot;odom_alpha1&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha2&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;odom_alpha3&quot; value=&quot;0.8&quot;/&gt; &lt;param name=&quot;odom_alpha4&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;laser_z_hit&quot; value=&quot;0.5&quot;/&gt; &lt;param name=&quot;laser_z_short&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_max&quot; value=&quot;0.05&quot;/&gt; &lt;param name=&quot;laser_z_rand&quot; value=&quot;0.5&quot;/&gt; &lt;param name=&quot;laser_sigma_hit&quot; value=&quot;0.2&quot;/&gt; &lt;param name=&quot;laser_lambda_short&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;laser_model_type&quot; value=&quot;likelihood_field&quot;/&gt; &lt;!-- &lt;param name=&quot;laser_model_type&quot; value=&quot;beam&quot;/&gt; --&gt; &lt;param name=&quot;laser_likelihood_max_dist&quot; value=&quot;4.0&quot;/&gt; &lt;param name=&quot;update_min_d&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;update_min_a&quot; value=&quot;0.1&quot;/&gt; &lt;param name=&quot;resample_interval&quot; value=&quot;2&quot;/&gt; &lt;!--//在重采样前需要的滤波更新的次数,默认2--&gt; &lt;param name=&quot;transform_tolerance&quot; value=&quot;0.2&quot;/&gt; &lt;!--tf变换发布推迟的时间--&gt; &lt;param name=&quot;recovery_alpha_slow&quot; value=&quot;0.0&quot;/&gt; &lt;!-- 慢速速的平均权重滤波的指数衰减频率，用作决定什么时候通过增加随机位姿来recover，默认0（disable）--&gt; &lt;param name=&quot;recovery_alpha_fast&quot; value=&quot;0.0&quot;/&gt; &lt;!-- 快速的平均权重滤波的指数衰减频率，用作决定什么时候通过增加随机位姿来recover，默认0（disable），可能0.001是一个不错的值--&gt; &lt;param name=&quot;use_map_topic&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;first_map_only&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;tf_broadcast&quot; value=&quot;false&quot;/&gt; &lt;param name=&quot;odom_frame_id&quot; value=&quot;odom&quot;/&gt; &lt;param name=&quot;global_frame_id&quot; value=&quot;map&quot;/&gt; &lt;param name=&quot;base_frame_id&quot; value=&quot;base_footprint&quot;/&gt; &lt;param name=&quot;odom_model_type&quot; value=&quot;diff&quot;/&gt; &lt;param name=&quot;initial_pose_x&quot; value=&quot;$(arg init_x)&quot;/&gt; &lt;param name=&quot;initial_pose_y&quot; value=&quot;$(arg init_y)&quot;/&gt; &lt;param name=&quot;initial_pose_a&quot; value=&quot;$(arg init_a)&quot;/&gt; &lt;param name=&quot;initial_cov_xx&quot; value=&quot;0.25&quot; /&gt; &lt;param name=&quot;initial_cov_yy&quot; value=&quot;0.25&quot; /&gt; &lt;param name=&quot;initial_cov_aa&quot; value=&quot;0.2&quot; /&gt; &lt;/node&gt;&lt;/launch&gt; amcl.launch.xml src\\racecar\\src\\car_controller_new.cpp代码很长，这里就不放了，自行下载源代码查看。这个代码很重要，我将其中的舵机限幅改大了，并注释掉了到达目标点后，发布速度为0，舵机打角为0的部分，实际上发布的节点是car&#x2F;cmd_vel,舵机打角0度，向右偏到最大，90才是正中，修复到达目标点后计算并突然左打角的BUG. wj_go_hh.py src\\auto_car\\scripts\\wj_go_hh.py控制主程序思路读取打点的配置文件，发布目标点，检测自身位置，当目标点与自身位姿小于参数Distance_min（单位m）时,发布下一个目标点停车思路，这里并没有实际检测红绿灯和斑马线，而是采用定点的方式，首先将参数start_light_post ，white_go ，while_back 写入，横纵坐标，写入后程序会检测打点配置文件中哪些目标点与这些停车点距离最近，在发布到这个目标点时，先停车一段时间后，在出发，停车采用发布&#x2F;light话题，car_controller_new节点接受到后就会停车。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254import rospyfrom geometry_msgs.msg import Twistfrom geometry_msgs.msg import PoseWithCovarianceStampedimport mathimport numpy as npfrom wj_pid import PIDimport jsonimport timefrom nav_msgs.msg import Odometryfrom std_msgs.msg import String, Float64from move_base_msgs.msg import MoveBaseActionResultfrom actionlib_msgs.msg import GoalStatusArrayfrom geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped# 参数配置，# 角度从车右方逆时针旋转Angle_min = 50.0 #右拐最大角Angle_max = 130.0 #左拐最大角Angle_mid = 90.0 #中间值Speed_max = 1700My_Speed = 1630now_Goal=[0,0,0,1]Distance_min = 1.0is_start_light = 1 #是否开启红绿灯定点？light_index = 0 light_flag = 0is_white = 1 #是开启斑马线定点？white_go_index = 0while_back_index = 0white_flag = 0is_rest = 0 #开启定点纠偏rest_index = 0rest_post = [6.18,-1.40]rest_flag = 0# 参数修改start_light_post = [[8.39,-0.1],[10.8,-0.4],[12.6,-0.2],[7.25,-1.87],[10,-2],[12.3,-1.9]]white_go = [3.0, -0.5]while_back = [3.5,-1.1]def find_closest_point(start_light_post, post): &#x27;&#x27;&#x27; my_list格式为[[a,b],[c,d],[e,f]...] my_post格式为[a,b] 该函数会返回my_list距离my_post最近的坐标的下标 &#x27;&#x27;&#x27; # 提取每个点的 x 和 y 坐标 points = np.array(start_light_post)[:, :2] # 计算每个点与post的距离 distances = np.sqrt((points[:, 0] - post[0])**2 + (points[:, 1] - post[1])**2) # 返回距离最小的点的下标 return np.argmin(distances)def send_goal(to_Goal, map_frame): goal_msg = PoseStamped() goal_msg.header.stamp = rospy.Time.now() goal_msg.header.frame_id = &#x27;map&#x27; # 坐标系应与目标点一致，通常是地图坐标系 goal_msg.pose.position.x = to_Goal[0] # 替换为目标点的 x 坐标 goal_msg.pose.position.y = to_Goal[1] # 替换为目标点的 y 坐标 goal_msg.pose.position.z = 0.0 # 替换为目标点的 z 坐标 # 设置目标点的姿态，通常不需要设置 goal_msg.pose.orientation.x = 0.0 goal_msg.pose.orientation.y = 0.0 goal_msg.pose.orientation.z = to_Goal[3] goal_msg.pose.orientation.w = to_Goal[2] # 发布目标点 goal_publisher.publish(goal_msg) rospy.loginfo(&quot;Goal sent!&quot;) class go_to: def __init__(self): self.pose_amcl = rospy.Subscriber(&#x27;/odometry/filtered&#x27;,Odometry,self.amcl_pose_callback,queue_size=1) # self.pose_amcl = rospy.Subscriber(&quot;/amcl_pose&quot;, PoseWithCovarianceStamped, self.amcl_pose_callback, queue_size=10) self.now_position = [0,0,0,1] def amcl_pose_callback(self, data): position = data.pose.pose.position orientation = data.pose.pose.orientation self.now_position = [round(position.x, 3), round(position.y, 3), round(orientation.z, 3), round(orientation.w, 3)] class controll: def __init__(self,Angle_min,Angle_max,Angle_mid,Speed_max,My_Speed): self.pub_speed = rospy.Publisher(&#x27;/car/cmd_vel&#x27;, Twist, queue_size=1) self.Angle_min=Angle_min self.Angle_max=Angle_max self.Angle_mid=Angle_mid self.Speed_max=Speed_max self.My_Speed=My_Speed self.pid = PID(Kp=1.2, Ki=0, Kd=0, setpoint=0) self.pub_stop = rospy.Publisher(&#x27;/light&#x27;, String, queue_size=1) def go_goal(self,To_Goal,Now_Goal): &#x27;&#x27;&#x27; To_Goal表示目标点，为一个列表，内有4个数据，依次为，位置x,位置y,方向z,方向w Now_Goal表示当前位置 &#x27;&#x27;&#x27; vector_point=[To_Goal[0]-Now_Goal[0],To_Goal[1]-Now_Goal[1],0] print(&quot;vector_point&quot;+str(vector_point)) ang = quaternion_to_euler(Now_Goal[2], Now_Goal[3]) print(&quot;ang&quot;+str(ang)) ang = ang*math.pi/180 print(&quot;ang&quot;+str(ang)) vector_angle = [round(math.cos(ang), 3),round(math.sin(ang), 3),0] print(&quot;vector_angle&quot;+str(vector_angle)) final_ang = angle_between_vectors(vector_angle, vector_point) return final_ang def angle_control(self,angle_1): angle_2 = self.Angle_mid + self.pid.update(angle_1) print(&quot;angle_2&quot;, angle_2) # 舵机限幅 if angle_2 &lt; self.Angle_min: return self.Angle_min elif angle_2 &gt; self.Angle_max: return self.Angle_max else: return angle_2 def publish_velocity(self, linear_x, angular_z): twist = Twist() twist.linear.x = linear_x twist.linear.y = 0 twist.linear.z = 0 twist.angular.z = angular_z twist.angular.x = 0 twist.angular.y = 0 self.pub_speed.publish(twist)def work1(): rospy.spin() # print(&quot;to_Goal&quot;,to_Goal) # print(&quot;now_Goal&quot;,go_to_obj.now_position) if __name__ == &quot;__main__&quot;: with open(&#x27;/racecar/src/auto_car/scripts/waypoint.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f) f.close() index_point=0 waypoint = data[&quot;waypoint&quot;] print(waypoint) point_len = len(waypoint) print(&quot;go?&quot;) www = 5 aaa=input() start_time = time.time() if is_start_light == 1: # 开启定点 light_index = find_closest_point(waypoint, start_light_post[int(www)]) print(&quot;最经点的下标为：&quot; + str(light_index)) white_go_index = find_closest_point(waypoint,white_go) while_back_index = find_closest_point(waypoint,while_back) rest_index = find_closest_point(waypoint,rest_post) rospy.init_node(&quot;wj_go&quot;, anonymous=True) go_to_obj = go_to() control = controll(Angle_min,Angle_max,Angle_mid,Speed_max,My_Speed) goal_publisher = rospy.Publisher(&#x27;/move_base_simple/goal&#x27;, PoseStamped, queue_size=10) map_frame = rospy.get_param(&#x27;~map_frame&#x27;, &#x27;map&#x27; ) time.sleep(1) # t1 = Thread(target=work1) # t1.start() to_Goal = [waypoint[index_point][0],waypoint[index_point][1],waypoint[index_point][2],waypoint[index_point][5]] send_goal(to_Goal,map_frame) while True: now_Goal = go_to_obj.now_position distance = np.sqrt((to_Goal[0]-now_Goal[0])**2+(to_Goal[1]-now_Goal[1])**2) if (distance &lt;= Distance_min and index_point &lt;= point_len-1): if index_point == point_len -1 : pass print(&quot;over&quot;) finish_time = time.time() print(finish_time-start_time) while True: control.publish_velocity(1200,90) index_point = index_point + 1 if index_point == rest_index and is_rest == 1 and rest_flag == 0: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) rest_flag = 1 if index_point == light_index and is_start_light==1 and light_flag == 0: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) light_flag = 1 if index_point == white_go_index and is_white ==1 and white_flag == 0: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) white_flag = 1 if index_point == while_back_index and is_white ==1 and white_flag == 1: now_time = time.time() control.pub_stop.publish(&quot;red&quot;) while time.time()-now_time &lt; 2.3: pass #control.publish_velocity(1200,90) control.pub_stop.publish(&quot;green&quot;) white_flag = 2 to_Goal = [waypoint[index_point][0],waypoint[index_point][1],waypoint[index_point][2],waypoint[index_point][5]] send_goal(to_Goal,map_frame) 改进代码介绍完毕，下面介绍一下改进的思路。 由于主程序是一个一个点发布的，每次导航只是专注于此时的目标点，导致路径不平滑，有时由于拐的太大，在下一个目标点，无法回正到正确的轨迹，可尝试对打点的参数文件做平滑处理 controller_new.cpp文件中还有bug没修改，并且这个控制器不好用，可以自己写一个 可以关闭controller，启用局部路径规划，衔接局部路径规划和底盘的代码 赛后结果及其感悟三个队，国一，国二，国三，结果还行，没崩。","tags":["ros","竞赛"]},{"title":"批量文件重命名脚本","path":"/2024/08/05/批量文件重命名脚本/","content":"实现重命名特定后缀文件，批量增加特定前缀 123456789101112131415161718192021222324252627282930import osdef batch_rename(folder_path, file_extension, prefix): # 检查文件夹是否存在 if not os.path.exists(folder_path): print(f&quot;文件夹 &#123;folder_path&#125; 不存在&quot;) return # 获取文件夹中的所有文件 files = os.listdir(folder_path) for filename in files: # 检查文件的后缀是否匹配 if filename.endswith(file_extension): # 构造新的文件名 new_name = prefix + filename # 获取旧文件的完整路径 old_file = os.path.join(folder_path, filename) # 获取新文件的完整路径 new_file = os.path.join(folder_path, new_name) # 重命名文件 os.rename(old_file, new_file) print(f&quot;已将 &#123;old_file&#125; 重命名为 &#123;new_file&#125;&quot;)# 示例调用folder_path = &#x27;/path/to/your/folder&#x27;file_extension = &#x27;.txt&#x27;prefix = &#x27;prefix_&#x27;batch_rename(folder_path, file_extension, prefix)","tags":["脚本"]},{"title":"verilog_base_study","path":"/2024/08/05/verilog-base-study/","content":"verilog 模块结构 verilog基本框架 实例、 进行实例化对象，以二选一选择器和D触发器为例，涉及到always和assign 模块说明部分 模块说明部分的涉及及其注意事项 assign语句 进入assign语句，注意事项，必须&#x3D;,且wire类型 assign操作 基本运算符号及其类型 always语句 always表示总是如此，@表示等待，赋值目标必须为reg类型目标条件有两种，边沿触发和电平触发 assign与always的区别 begib end 的使用 相当于括号，always如果有多条赋值语句，必须用begin end 将其包裹 阻塞赋值与非阻塞赋值 时序电路常使用非阻塞&lt;&#x3D;赋值 举例 底层模块 例化时采用.x(x)形式进行例化，即命名法格式 门原语调用 基本用不到 verilog数据类型 wire reg input，inout信号必须为net形，output随意 数字表示格式 if语句 case语句 case endcase 语言描述风格 下面这种用的最多 其他规则","tags":["verilog"]},{"title":"电力电子技术","path":"/2024/08/03/电力电子技术/","content":"电力电子技术概念信息电子技术与电力电子技术 两大分支 电力电子器件的制造技术 变流技术 电力变化的四大类 电力电子技术与信息电子的区分 电力电子技术与自动化 电力电子技术的发展史 1957年美国通用电气公司研制了世界上第一个晶闸管，标志着电力电子技术的诞生 电力电子技术的应用 习题 直流电DC,Direct Current;交流电AC,Alternating Current 总结 电力电子器件概述基本概念 特征★ 电力电子器件的损耗 电力电子器件的系统组成 电力电子器件的分类 不可通过控制电路控制电力电子器件的开通的是不可控器件，可以通过控制电路控制电力电子器件的开通，但不可通过控制电路控制电力电子器件的关断的是半控型器件，即可开通又可关断的是全控型器件。 习题 A不是最重要的，D,需要散热器，但不讲究散热设计，当然，个人更倾向与ABCD全选 总结 不可控器件-电力二极管基本结构 电力二极管具有电导调制效应，电流小时，阻值大，电流大时阻值小 工作原理 先发生电击穿，后发生热击穿 基本特性 主要参数 有点没懂，得重学，这个参数最重要 种类 恢复时间越来越短 习题 总结 半控型器件-晶闸管★ 前面还有些内容要补上 晶闸管正常工作特性总结 晶闸管导通时，看作导线 基本特性 主要参数 维持电流是从通态到断态，擎住电流是从断态到通态 派生器件 习题 总结 晶闸管是电力电子器件最重要的器件 全控型器件-GTO(门级可关断晶闸管)是晶闸管的派生器件 结构 基本工作原理 GTO与普通晶闸管的区别★ GTO的动态特性 前面的得复习了，没太懂 主要参数 给GTO通的电流不能超过最大可关断阳极电流，否则无法关闭。电流关断增益小是其主要的缺点 习题 总结 全控型器件-GTR(电力晶体管) 采用达林顿接法的意义，有效增大电流增益 基本特性 主要参数 具有二次击穿 习题 总结 全控型器件-MOS(电力场效应晶体管)特点 结构与原理 基本特性 正温度系数，温度升高，阻值升高 该元件，静态特性重要于动态特性 习题 全控型器件-IGBT(绝缘栅双极晶体管) 基本特性 主要参数 习题 总结 整流电路 本章重学吧，没听懂 单相可控整流电路 单相半波可控整流电路 单相桥式整流电路 三相可控整流电路 三相半波可控整流电路 三相桥式整流电路 单相半波可控整流电路电阻负载 晶闸管的导通条件变压器的作用$u_{d}$与$i_{d}$是输出电压与输出电流,R为输出负载 移项范围和平均值的计算重要触发延迟角，导通角a的移相范围即为正相导通角的范围 带阻感负载 直流磁化现象，是由双向不对称或只单相导致的触发延迟角，导通角续流二极管的作用是抑制$u_{d}&#x3D;0$,此时假设L很大 练习 单相桥式整流电路 $i_{2}$是对称分布，不会发生直流磁化现象 注意有效值与平均值的写法 带阻感负载 每一行晶闸管的导通角都是180度，与控制角无关 带反电动势时的工作情况 习题 三相半波整流电路 控制角的起点 此时a为0度 a等于30度 出现断续现象 最大反相电压与最大正相电压 阻感负载 直流磁化，单相半波和三相半波 习题 三相桥式全控整流电路 自然换相点 什么是宽脉冲，什么是双脉冲 a为0度的波形图 a为30度 a为60度 a为90度 阻感负载 a为0度 a为30度 a为90度 习题 变压器漏感对整流电路的影响 卡住了，得练习 换流方式 基本原理 换流方式 习题 总结 电压型逆变电路 三大特点 单相电压型逆变电路单相半桥逆变电路 单相全桥逆变电路 全桥逆变电路有两种调压方式，1，改变$U_{d}$，2，移相调压 三相电压型逆变电路 三相电压型逆变电路的特点 练习 电流型逆变电路 主要特点 单相电流型逆变电路 三相电流型逆变电路 PWM控制技术 理论基础，面积等效原理 三相电压型PWM逆变器 练习 总结 软开关技术","tags":["课程"]},{"title":"无聊的盒子制作","path":"/2024/06/23/无聊的盒子制作/","content":"前言一开始想把这个当成一个开源项目来做，然后发现想要超越网上现有的开源项目，还是需要费一番功夫，至少不是花一两天就能完成的。目前的项目其实还不是很完善，甚至部分打印件需要用小刀进行修正，遂本次制作仅自娱自乐，作为自己的练习项目。文件仓库如下 https://github.com/liwuyou/box.git arduino代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 无聊的盒子//使用mg90s舵机#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象int close_pos = 110; // 该变量用与存储舵机能够关闭钮子开关的角度int home_pos = 20; // 回正角度int pin_on = 2;void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制 myservo.write(home_pos); pinMode(pin_on,INPUT_PULLUP); randomSeed(analogRead(0));//随机数种子&#125; void case_1()&#123; // 快进快出 myservo.write(close_pos); delay(300); myservo.write(home_pos); delay(300); &#125;void case_2()&#123; //中速 delay(500); myservo.write(close_pos); delay(500); myservo.write(home_pos); delay(1000); &#125;void case_3()&#123; //低速 delay(500); myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(1000); &#125;void case_4()&#123; //疲惫 int pos; for(pos = home_pos; pos&lt;=close_pos-20; pos+=1) &#123; myservo.write(pos); delay(30); &#125; myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(500);&#125;void case_5()&#123; //生气 int pos; for(pos = home_pos; pos&lt;=close_pos-20; pos+=1) &#123; myservo.write(pos); delay(10); &#125; for(pos = close_pos-20; pos&gt;=home_pos+30; pos-=1) &#123; myservo.write(pos); delay(10); &#125; myservo.write(close_pos); delay(1000); myservo.write(home_pos); delay(500);&#125;void loop() &#123; int randNumber = random(5); if(digitalRead(2)==0)&#123; switch(randNumber)&#123; case 0:case_1();break; case 1:case_2();break; case 2:case_3();break; case 3:case_4();break; case 4:case_5();break; &#125; &#125;&#125;","tags":["arduino"]},{"title":"台式电脑组装DIY指南","path":"/2024/05/23/台式电脑组装DIY指南/","content":"前言该篇主要针对台式电脑一些基础知识的扫盲工作。 电脑基础硬件 快速链接CPU天梯图 https://topic.expreview.com/CPU/ 显卡天梯图 https://topic.expreview.com/GPU/ 其他1、内存条套条牌子不一样没事，蓝条，绿条，黑条也没事。但是频率要一样，不一样只能按照低的那个走2、io挡版上，如果你有核显接主板，有独显也尽量接主板，没有核显再接独显3、笔记本和台式机命名稍微有点不一样，比如intel中U是低压，H是高压但是不超频3、显卡前面数字是代数，后面是叠马甲，比如1080就比1650强点（玄学警告04、PCI-e这玩意功能很多，各种网卡、蓝牙等都能差，但是这种东西插的时候插低档次的条，高档次还是留给显卡比较好，PCI-e4虽然很牛逼，但是受到选择不一样结果相趋甚远5、SATA接口并不是区分也有固态，m.2就只有固态了。m.2由于电子原理上导致运行效率高，但是固态硬盘数据丢了几乎恢复不了。机械硬盘的电磁强弱，比较好恢复数据（多备份才是王道）6、SATA不能单独供电。m.2虽然固态硬盘虽然大部分都是这个接口，但是长短有不一样的，也是型号区别，记得甄别7、CPU三级缓存是虚的，你猜它为什么不说1、2级缓存，1、2级大家做的都一样。3级有区别但是意义不大8、内存确实是断电无，但是根据设置不同，可以操作超频，也可以把系统本身装进内存（相信我爽到起飞）9、intel很多系列芯片虽然不能超频但是可以睿频，就是智能忽高忽低。超频需要在BIOS设置，设置好频率和电压的关系，好好考虑散热压不压得住10、南桥芯片组很重要，掌管电脑除了显卡、CPU之外鼠标、键盘等小玩意11、装机有的时候真的要大力出奇迹12、装机版最麻烦的不是上面说的那些，而是理线13、台式机一般不自带蓝牙、WIFI需要自己购买14、不要装xp，xp只能用4G内存15、双通道内存条要错开装，13、24这样16、m.2有的情况和pcie供用带宽，注意看主板说明书17、新手不推荐水冷。风冷血滴子手剧痛18、硅脂是为了填补cpu盖板表面和散热器直接的缝隙，别涂在针脚 上，硅脂一般酷冷至尊效果好点吧，论克卖的，好的硅脂、正确手法真的猛压住了温度19、水冷不是没有风扇，只是导热和循环变成水，但是也不是自来水。同价位风冷好20、风冷水冷都有热管，里面是热胀冷缩，相变冷凝的原理，如果有瑕疵就废了21、风扇内外别装反22、cpu分成盒装和散片，盒装就intel、AMD直接卖给个人消费者分，自带散热器（垃圾玩意，挤铝下压工艺，被动散热效果极差，但是政府机关买的台式机一般都这个）。散片也叫流片，是Intel、amd卖给dell、惠普等OTA厂商后，他们基于某些原因又倒卖的，品质完全一样，只是没有散热器赠送，质保也不一样23、要装机的话选个长螺丝刀，散热器的弹簧螺丝角度很刁钻24、机箱不是必须的，拿鞋盒当机箱也行 CPU主要参数 频率 基频 睿频 超频 核心 架构 缓存 厂家 intel（celeron,pentium,core,xeon） AMD（速龙，线程撕裂者，RYZen） 其他 正式版（盒装，散片） ES版（不显版，正显版QS） 购买需检查CPU上的小电容是否脱落，特别防拆贴在电容上的 intel第一代处理器会省掉1 洋垃圾系类E3,E5 E5E5 2666V3第一位数字表示可同时工作的CPU第二位数字表示主板对应针脚，4为1356针，6为2011针V1,V2 使用x79平台V3,V4 使用X99平台 显卡CPU 线程少，逻辑能力强GPU 线程多，逻辑能力弱 显卡的分类 集成显卡 核心显卡 独立显卡集成显卡是将显卡集成在主板上，使得显卡和主板融为一体，但它会占用系统内存，可能会对电脑性能产生一定影响。 核显则是集成在 CPU 里的图形处理单元，与CPU融为一体，它依托CPU强大的运算能力和智能能效调节设计，进一步加强了图像处理的效率。 厂家 英伟达 AMD 公版卡和非公板卡 常见矿卡 RX580 GTX1660s RX5600XT RX5700XT RTX2080s 性能指标 流处理器数量（画师数量） 处理器架构（画师水平） 频率（画师绘画的速度） 显存频率（运输叉车的速度） 显存带宽（运输叉车每次运多少） 显存容量（仓库大小） 成果E5洋垃圾","tags":["电脑组装DIY"]},{"title":"第二十六届人工智能操作手册，测试版","path":"/2024/05/13/第二十六届人工智能操作手册，测试版/","content":"初始介绍用户名：racecar密码：1 思路通过gmapping算法建图，然后通过打点程序储存需要的导航点，在运行程序过程中，发布导航点，车辆就会达到目标点。 建图将车辆发在起始点，注意标注位置，⽐如说后编码器抵着后挡板 启动底盘，启动电调打开在终端中输入 1python3 ~/car_2024_rengong/src/auto_go/scripts/run_mapping.py 启动建图脚本，会弹出若干个弹窗。 在显示有control的终端进行键盘操作， W为向前⾛，Q为向左⽅⾛，E为向右⽅⾛，s为停止。 建图完成后，请按键盘上的m保存地图，此时会弹出⼀个新的终端，终端运⾏完成即可。 如果建图失败，或建图重叠，键盘控制界面按s停止，关闭所有终端，再次输入脚本。 建图时尽量直行，不要过多拐弯，观察rviz,有完。整图后及时按m保存。 标点标注的点为导航点，第一个点是第一个导航点结束标点时，发布⼀个和终点处箭头坐标⼀样的点即可请按照坐标抵达的先后顺序进⾏标点 1python3 ~/car_2024_rengong/src/auto_go/scripts/run_way_point_click.py 如果需要读取并修改之前保存的点，请填⼊1并回⻋，然后需要在rviz的任意处使⽤rviz的Publish Point功能发布⼀个点后，之前保存的点位才会显示。 然后在rviz中进⾏标点，使⽤2D nav goal 按钮进⾏坐标点的发布，如果需要移动以及发布的坐标点，请使⽤Publish Point对已经存在的点进⾏点击，箭头变红，然后就可以使⽤点 结束标点时，发布⼀个和终点处箭头坐标⼀样的点即可 打点时终点一段路多打几个，方便拟合 发车1python3 ~/car_2024_rengong/src/auto_go/scripts/wj_run.py 所有程序都打开后，在出现go?的终端回车，车辆运行 车辆运行关键：1.正确的地图2.合理的参数 参数调整: 12345678打开~/car_2024_rengong/src/racecar/launch/acml_nav.launch文件该参数及其附近参数能够调整其速度 &lt;param name=&quot;vp_min&quot; value=&quot;160&quot;/&gt; 打开~/car_2024_rengong/src/auto_go/scripts/wj_go_hh.py文件该参数能够调整距离导航点多远时，发布下一个导航点。Distance_min = 1.2","tags":["ros"]},{"title":"校巡线车校赛决赛代码","path":"/2024/04/19/校巡线车校赛决赛代码/","content":"校赛第二名，净挣1000，当然不妨碍代码是垃圾代码，没啥必要发github,发发博客差不多得了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;Servo.h&gt; #include &lt;MsTimer2.h&gt;Servo myservo; int pos = 70; //舵机中值，对于我的舵机左-&gt;右 40-100int lift = 20;int right = 120;// 舵机PWM引脚9，左电机PWM引脚5,右电机PWM引脚6；int servo = 9; int motor1=5; int motor2=6;int motor1_speed =60; int motor2_speed =60;// 设置对管状态int white = 0;int black = 1;int err,last_err; //pid 参数定义int output;float kp=10,ki=0,kd=0;float P,I,D;// 红外对管左-&gt;右引脚为2,3,4,7,8,12,13int infrared[7]=&#123;2,3,4,7,8,12,13&#125;;//实例特判int zhijiao = 0;int hu = 0;int hu2 = 0;int hu2_flag =0;int final =0;void flash() &#123; final =1;&#125;void setup() &#123; myservo.attach(9); // 该舵机由arduino第九脚控制 myservo.write(pos); //电机pwm引脚初始化，模式设置为输出模式 pinMode(motor1,OUTPUT); pinMode(motor2,OUTPUT); pinMode(10,OUTPUT); Serial.begin(9600);//串口初始化 //红外对管引脚模式设置为输入上拉模式 pinMode(infrared[0],INPUT_PULLUP); pinMode(infrared[1],INPUT_PULLUP); pinMode(infrared[2],INPUT_PULLUP); pinMode(infrared[3],INPUT_PULLUP); pinMode(infrared[4],INPUT_PULLUP); pinMode(infrared[5],INPUT_PULLUP); pinMode(infrared[6],INPUT_PULLUP); //初始速度 analogWrite(motor1,motor1_speed); analogWrite(motor2,motor2_speed);&#125;void loop() &#123; if(zhijiao == 0)&#123; zhijiao = 1; analogWrite(motor2,80); delay(1800); myservo.write(40); analogWrite(motor2,100); delay(1000); &#125; if((hu == 0 &amp;&amp; zhijiao == 1 &amp;&amp; digitalRead(infrared[0])==black &amp;&amp; digitalRead(infrared[3])==black) || (hu == 0 &amp;&amp; zhijiao == 1 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[3])==black))&#123; hu = 1; analogWrite(5,0); analogWrite(6,0); analogWrite(11,100); myservo.write(70); delay(1800); myservo.write(30); analogWrite(11,0); analogWrite(5,100); analogWrite(6,100); delay(1500); &#125; if(final==1 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[2])==black &amp;&amp; digitalRead(infrared[3])==black)&#123; analogWrite(5,0); analogWrite(6,0); delay(5500); &#125; if(hu==1 &amp;&amp; hu2==0 &amp;&amp; digitalRead(infrared[1])==black &amp;&amp; digitalRead(infrared[2])==black &amp;&amp; digitalRead(infrared[3])==black)&#123; hu2 = 1; analogWrite(5,0); analogWrite(6,0); analogWrite(11,140); myservo.write(90); delay(2000); myservo.write(30); analogWrite(11,0); analogWrite(5,120); analogWrite(6,120); delay(1000); motor1_speed =70;motor2_speed =70; MsTimer2::set(25000, flash); // 5000ms period MsTimer2::start(); &#125; sensor(); int control_turn =pos + pid(); myservo.write(control_turn); if(err == 4)&#123; analogWrite(motor1,motor1_speed+60); &#125; else if(err == -4)&#123; analogWrite(motor2,motor2_speed+60); &#125; else if(err == 2)&#123; analogWrite(motor1,motor1_speed+20); if(hu==1 &amp;&amp; hu2==0)&#123; analogWrite(motor1,motor1_speed+40); &#125; &#125; else if(err == -2)&#123; analogWrite(motor2,motor2_speed+20); if(hu==1 &amp;&amp; hu2==0)&#123; analogWrite(motor2,motor2_speed+40); &#125; &#125; else&#123; analogWrite(motor1,motor1_speed); analogWrite(motor2,motor2_speed); &#125;&#125;int pid()&#123; P = err; I += err; D = err - last_err; output = kp*P + ki*I + kd*D; last_err = err; return output;&#125;void sensor()&#123; int a_1 = digitalRead(infrared[0]); int a_2 = digitalRead(infrared[1]); int a_3 = digitalRead(infrared[2]); int a_4 = digitalRead(infrared[3]); int a_5 = digitalRead(infrared[4]); int a_6 = digitalRead(infrared[5]); int a_7 = digitalRead(infrared[6]); if(a_1==black &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -4; &#125; else if(a_1==white &amp;&amp; a_2==black &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -2; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==black &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = -1; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==black &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = 0; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==black &amp;&amp; a_6==white &amp;&amp; a_7==white)&#123; err = 1; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==black &amp;&amp; a_7==white)&#123; err = 2; &#125; else if(a_1==white &amp;&amp; a_2==white &amp;&amp; a_3==white &amp;&amp; a_4==white &amp;&amp; a_5==white &amp;&amp; a_6==white &amp;&amp; a_7==black)&#123; err = 4; &#125; Serial.println(err); //测试代码&#125;"},{"title":"讯飞二代车记录","path":"/2024/03/30/讯飞二代车记录/","content":"开始二代车https://github.com/liwuyou/xunfei_second.git 初始配置官方包编译键盘控制python文件使用，放在ucar_ws&#x2F;src&#x2F;目录下 建图配置1234567891011121314151617181920212223# 启动键盘节点roslaunch ucar_map ucar_gmapping.launch# 键盘控制节点python3 ~/ucar_ws/src/ucar_map/launch/mbot_teleop.py # 保存地图rosrun map_server map_saver -f /home/iflytek/ucar_ws/src/ucar_map/maps/name# name为自己命名的文件``` ## 挂载地图并取得点坐标```python# 发布已建好的地图rosrun map_server map_server /home/iflytek/ucar_ws/src/ucar_map/maps/name# 打开rviz,挂载地图，选择publisher,看左下角，确定x,yrviz# 修改pose文件欧拉角转四元数https://quaternions.online/ 导航123# 启动导航文件roslaunch ucar_nav ucar_navigation_wy.launch# rviz发布目标点，观察小车轨迹是否有异常，修改配置文件 官方局部路径规划不可用， 1234567891011# 安装teb_local_planner路径规划sudo apt-get install ros-noetic-teb-local-planner# 修改ucar_navi.launch文件下局部路径规划为teb_local_planner，在movebase下添加配置文件 &lt;param name=&quot;base_global_planner&quot; value=&quot;global_planner/GlobalPlanner&quot; /&gt; &lt;param name=&quot;planner_frequency&quot; value=&quot;10.0&quot; /&gt; &lt;param name=&quot;planner_patience&quot; value=&quot;2&quot; /&gt; &lt;param name=&quot;use_dijkstra&quot; value=&quot;true&quot; /&gt; &lt;param name=&quot;base_local_planner&quot; value=&quot;teb_local_planner/TebLocalPlannerROS&quot; /&gt; &lt;param name=&quot;controller_frequency&quot; value=&quot;30.0&quot; /&gt; &lt;param name=&quot;controller_patience&quot; value=&quot;10.0&quot; /&gt; &lt;param name=&quot;clearing_rotation_allowed&quot; value=&quot;true&quot; /&gt;","tags":["讯飞"]},{"title":"讯飞车找板子返回坐标点程序","path":"/2024/03/22/讯飞车找板子返回坐标点程序/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import numpy as npdef rotate_vector(vector, angle): &quot;&quot;&quot; 将向量旋转一定的角度 &quot;&quot;&quot; # 将角度转换为弧度 angle_rad = np.deg2rad(angle) # 构造旋转矩阵 rotation_matrix = np.array([[np.cos(angle_rad), -np.sin(angle_rad)], [np.sin(angle_rad), np.cos(angle_rad)]]) # 使用旋转矩阵对向量进行旋转 rotated_vector = np.dot(rotation_matrix, vector) # 保留三位有效数字 rotated_vector = np.around(rotated_vector, decimals=3) return rotated_vectordef radians_to_vector(theta): &quot;&quot;&quot; 将theta转化为向量 &quot;&quot;&quot; # 计算向量的 x 和 y 分量 x = np.cos(theta)*1 y = np.sin(theta)*1 # 保留三位小数 x = np.around(x, decimals=3) y = np.around(y, decimals=3) return np.array([x, y])def is_angle_less_than_X(x, v1, v2): # 计算向量的点积 dot_product = np.dot(v1, v2) # 计算向量的模长 v1_norm = np.linalg.norm(v1) v2_norm = np.linalg.norm(v2) # 计算夹角的余弦值 cos_angle = dot_product / (v1_norm * v2_norm) # 计算 X 度的余弦值 cos_x_deg = np.cos(np.deg2rad(x)) return cos_angle &gt; cos_x_degdef is_angle_greater_than_90(v1, v2): &quot;&quot;&quot; 判断两向量夹角是否大于90度，大于返回True &quot;&quot;&quot; # 计算向量的点积 dot_product = np.dot(v1, v2) # 如果点积小于 0，则夹角大于 90 度 return dot_product &lt; 0class BoardTrue: &quot;&quot;&quot; 用于判断并筛选出有效的板子 &quot;&quot;&quot; def __init__(self, my_list, car_x, car_y, car_theta, cv_po): self.my_list = my_list self.car_x = np.around(car_x, decimals=3) self.car_y = np.around(car_y, decimals=3) self.car_theta = np.around(car_theta, decimals=3) self.cv_po = np.around(cv_po, decimals=3) def chose_board(self): if len(self.my_list) == 0: return None else: n = len(self.my_list) print(n) for i in range(n): if 0.2 &lt; self.my_list[i][2] &lt; 0.7: x = self.my_list[i][0] - self.car_x y = self.my_list[i][1] - self.car_y v1 = np.array([x, y]) v2 = radians_to_vector(self.car_theta) print(&quot;i为&quot; + str(i)) print(is_angle_less_than_X(70, v1, v2)) if is_angle_less_than_X(70, v1, v2): print(&quot;dfg&quot;) mapped_value = (self.cv_po - (0)) * (70 - (-10)) / (640 - 0) + (-70) v3 = rotate_vector(v2, mapped_value) if is_angle_less_than_X(25, v1, v3): print(&quot;asd&quot;) return self.my_list[i] else: continue else: continue return Noneclass BoardWithCv: &quot;&quot;&quot; 使用此类时，请确保传入的板子是一个且有效,他会返回一个导航点x,y,theta &quot;&quot;&quot; def __init__(self, car_x, car_y, car_theta, board_x, board_y, board_theta): # 实例属性 self.car_x = np.around(car_x, decimals=3) self.car_y = np.around(car_y, decimals=3) self.car_theta = np.around(car_theta, decimals=3) self.board_x = np.around(board_x, decimals=3) self.board_y = np.around(board_y, decimals=3) self.board_theta = np.around(board_theta, decimals=3) def is_board_theta_ture(self): &quot;&quot;&quot; 判断并执行板子的角度是否需要反转,并返回导航点,弧度，是否有效 :return: &quot;&quot;&quot; v1 = np.array([self.board_x - self.car_x, self.board_y - self.car_y]) v2 = radians_to_vector(self.board_theta) if is_angle_greater_than_90(v1, v2): self.board_theta = self.board_theta + 3.141 v2 = radians_to_vector(self.board_theta) goal_x = np.around(self.board_x - 0.3 * v2[0], decimals=3) goal_y = np.around(self.board_y - 0.3 * v2[1], decimals=3) return goal_x, goal_y, self.board_thetaif __name__ == &quot;__main__&quot;: ## 测试代码 # board=[-1,1,0.785] board = [-1.6258577108383179, 1.445590853691101, 0.456392377614975, 0.011698315851390362, 1.518639469495104] # board=[-3,1,3.14-0.785] pos = BoardWithCv(-2, 0, 1.57, board[0], board[1], board[4]) print(pos.is_board_theta_ture()) my_list = [[-1, 1,0.5,0.02, 0.785], [-3, 1,0.5,0.02,3.14-0.785], [-2, 1,0.5,0.02,1.3]] my_list2 =[] my_list3 = [[-1.1039749383926392, -1.6410338878631592, 0.459942102432251, 0.006066703703254461, 2.404021134944642], [-1.0234383344650269, 1.4331644773483276, 0.6236299276351929, 0.0975717082619667, 0.6774194980518585], [-1.6258577108383179, 1.445590853691101, 0.456392377614975, 0.011698315851390362, 1.518639469495104], [-2.016007423400879, 1.6973320245742798, 0.17067547142505646, 0.008529485203325748, 1.4121627729088593], [-2.3203864097595215, 1.3803951740264893, 0.4648244082927704, 0.011016763746738434, 2.12274152271989]] my_list4 = [[-2.2005648612976074, -1.9698346853256226, 0.26301005482673645, 0.02629818394780159, 1.2184761268334674], [-1.6092170476913452, -1.8576725721359253, 0.3533917963504791, 0.029181374236941338, 1.9172304414045462], [-1.0438616275787354, -1.4628329277038574, 0.47950631380081177, 0.013515759259462357, 2.4409537863628334], [-1.6358827352523804, 1.4406025409698486, 1.5764230489730835, 0.26953673362731934, 1.4236640668400438]] my_list5 = [[-2.2020256519317627, -1.9928362369537354, 0.2039794772863388, 0.025548739358782768, 1.1120026801359906], [-1.6541303396224976, -1.898160457611084, 0.3227234482765198, 0.01702151633799076, 1.7969596897315867], [-1.4612840414047241, -1.1711866855621338, 0.4812791049480438, 0.05817915499210358, 2.159874044377892], [-1.0457868576049805, 1.2947330474853516, 0.44938141107559204, 0.009451523423194885, 0.8893285575700086], [-2.283306121826172, 1.518304705619812, 0.4721873700618744, 0.007294466253370047, 2.0108069978910965]] posa = BoardTrue(my_list5, -2, 0, 0.8, 331) print(posa.chose_board())&quot;&quot;&quot;[00:15:08.34] 前往pose_3&#123;u&#x27;spontoon&#x27;: 284.0&#125;targetspontoonfirst_1&#123;u&#x27;spontoon&#x27;: 284.0&#125;boards[[-2.20574951171875, -1.9964897632598877, 0.19374234974384308, 0.0202349741011858, 1.0713866771931375], [-1.6379033327102661, -1.9009284973144531, 0.34384506940841675, 0.010412354953587055, 1.8343551319682068], [-1.4544870853424072, -1.176705002784729, 0.4698032736778259, 0.053842246532440186, 2.147697938715995], [-1.02494215965271, 1.2817209959030151, 0.468691885471344, 0.005473896395415068, 0.8983430915438178], [-2.271810293197632, 1.5118887424468994, 0.46807199716567993, 0.00690682977437973, 2.0043066211443765]][-1.02494215965271, 1.2817209959030151, 0.468691885471344, 0.005473896395415068, 0.8983430915438178]quat=[0, 0, 0.434, 0.901]send the goal&quot;&quot;&quot;"},{"title":"ROS车记录","path":"/2024/03/12/ROS车记录/","content":"基于一代讯飞车的ROS记录 常见命令行123456789# 更改屏幕分辨率xrandr --fb 1600x900更改完后，远程桌面要关闭再打开压缩文件夹zip -r file.zip file 常用launch文件包12roslaunch ucar_controller base_driver.launch启动底盘节点 地图操作地图发布，rviz查看12rosrun map_server map_server 文件名.yamlrosrun rviz rviz 建图，并保存1234# 启动建图launch包# 启动键盘控制，小车运动# 保存地图rosrun map_server map_saver -f &lt;map_file_name&gt;","tags":["ros"]},{"title":"python算法实战","path":"/2024/03/12/python算法实战/","content":"去年报名了蓝桥杯，却一直没有练习，也该开始了，为了300的报名费 时间复杂度O(1),O(n),O($n^{2}$),O($log_{2}n$),O(n!)… 空间复杂度 递归 调用条件 结束自身 实例 12345678910def jiecheng(n): if n != 1: sum = n * jiecheng(n - 1) return sum else: return 1print(jiecheng(5)) 12#结果120 查找 顺序查找 二分查找 顺序查找12345678910def shuxu(list_1, val): for i in range(len(list_1)): if val == list_1[i]: return i else: returnlist_my = list(range(5))print(shuxu(list_my, 3)) 12#结果3 二分查找1234567891011121314def binary_search(my_list, val): # my_list 为list,val为待查找的值 lift = 0 right = len(my_list) - 1 mid = (lift + right) // 2 while lift &lt;= right: if my_list[mid] == val: return mid elif my_list[mid] &gt; val: right = mid - 1 else: lift = mid + 1 else: return None 排序将一组无序序列变为有序序列升序与降序内置排序算法sort() LOW 冒泡排序 选择排序 插入排序 NB 快速排序 堆排序 归并排序 其他 希儿排序 计数排序 基数排序 sort的使用需要注意的是，sort()方法会直接修改原列表，而不是返回一个新的排序后的列表 冒泡排序 列表每相邻的两个数，如果后面比前面大，交换两个数 一次排序，无序区减少一个数，有序区增加一个数 12345678910111213import randomdef bubble_sort(my_list): for i in range(len(my_list)-1): # -1防止内存溢出 for j in range(len(my_list)-1-i): if my_list[j]&gt;my_list[j+1]: my_list[j],my_list[j+1]=my_list[j+1],my_list[j]my_list = [random.randint(0,10000) for i in range(5)]print(my_list)bubble_sort(my_list)print(my_list) 123# 结果[3003, 7653, 1759, 5541, 3176][1759, 3003, 3176, 5541, 7653] range详解range() 函数是 Python 中常用的一个函数，用于生成一个整数序列。它常用于循环中，可以生成指定范围的整数序列。 range() 函数有三种常用的用法： range(stop): 生成从 0 开始到 stop-1 的整数序列。 range(start, stop): 生成从 start 开始到 stop-1 的整数序列。 range(start, stop, step): 生成从 start 开始到 stop-1 的整数序列，步长为 step。123456789101112# 生成从 0 到 4 的整数序列for i in range(5): print(i) # 输出：0, 1, 2, 3, 4# 生成从 2 到 5 的整数序列for i in range(2, 6): print(i) # 输出：2, 3, 4, 5# 生成从 1 到 10 的偶数序列for i in range(2, 11, 2): print(i) # 输出：2, 4, 6, 8, 10 需要注意的是，range() 函数生成的是一个可迭代对象，而不是一个列表。如果需要得到一个列表，可以使用 list() 函数将其转换为列表：12my_list = list(range(5)) # 将 range 对象转换为列表print(my_list) # 输出：[0, 1, 2, 3, 4] random详解使用前需要import random random.random(): 返回一个 [0.0, 1.0) 之间的随机浮点数。 random.randint(a, b): 返回一个 [a, b] 之间的随机整数。 random.uniform(a, b): 返回一个 [a, b] 之间的随机浮点数。 random.choice(seq): 从序列 seq 中随机选择一个元素返回。 random.shuffle(seq): 将序列 seq 中的元素随机排序 random.sample(population, k): 从 population 中随机选择 k 个不重复的元素返回，返回一个列表。 选择排序打擂台排序 1234567891011import randomdef select_sort(my_list): for i in range(len(my_list)): for j in range(i,len(my_list)): if my_list[j]&lt;my_list[i]: my_list[j],my_list[i]=my_list[i],my_list[j]my_list = [random.randint(0,10000) for i in range(5)]print(my_list)select_sort(my_list)print(my_list) 123# 结果[3871, 3692, 8939, 1310, 1203][1203, 1310, 3692, 3871, 8939] 插入排序 初始时手里（有序区）只有一张牌 每次（从无序区）摸一张牌，插入到手里已有牌的正确位置123456789101112131415161718import randomdef insert_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j &gt;= 0 and arr[j] &gt; key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = keymy_list = [random.randint(0, 10000) for i in range(5)]print(my_list)insert_sort(my_list)print(my_list) 123# 结果[904, 5335, 5843, 9487, 1597][904, 1597, 5335, 5843, 9487] 数据结构python中数据结构的类型 元组 无法修改，tuple,不可变数据结构 利用in查找 列表 支持增删改查 切片[x:y],左闭右开 追加，列表末尾增加元素list.append(元素) 插入，list.insert(下标,元素) 删除, list.pop(下标)，默认为最后一个元素 字典 删除，dictionary.pop(“键”) 字符与字符串实战统计出其中数字字符的个数输入一行字符，统计出其中数字字符的个数。 12345678user_input = input()digit_count = 0for char in user_input: if char &lt;= &#x27;9&#x27; and char &gt;= &#x27;0&#x27;: digit_count += 1print(digit_count) isdigit() 是 Python 中字符串对象的一个方法，用于检查字符串中的所有字符是否都是数字字符（即 0-9）。可以改为 12345678user_input = input()digit_count = 0for char in user_input: if char.isdigit(): digit_count += 1print(digit_count) 给定一个只包含小写字母的字符串请你找到第一个仅出现一次的字符。如果没有，输出 no 12345678my_list = input()for char in my_list: if my_list.count(char) == 1: print(char) breakelse: print(&quot;no&quot;) 详解countcount() 方法是字符串对象的一个内置方法，用于统计指定子字符串在原字符串中出现的次数。count() 方法只会统计不重叠的子字符串。例如，在字符串 “aaaaa” 中统计子字符串 “aa” 的出现次数，结果为 2，而不是 4，因为两个 “aa” 子字符串之间重叠","tags":["python"]},{"title":"数电重置版","path":"/2024/03/08/数电重置版/","content":"我希望在3月20号之前学完数电，开始挑战！数电第三章不学，七八章选学，带星号不写，over————2024.3.20 整体逻辑框架图 数制与码制10进制转2进制 2进制转10进制 10进制转8421BCD互转 逻辑代数基础异或与同或及其常见与或非 基本公式与常用公式 反演定理与对偶定理 卡诺图 最小项及其无关项无关项（d表示，卡诺图中用X） 任意项 约束项 目的：矩形圈最大，矩形数量最少 化简 转化 组合逻辑电路常见组合逻辑模块编码器 普通编码器 优先编码器（允许同时输入两个以上的编码信号） 译码器与显示译码器 数据选择器 半加器与全加器 数值比较器 竞争冒险现象及其如何消解消除方法 接入滤波电容 引入选通脉冲 增加冗余项（eg: Y&#x3D;A+A’+BC） 半导体电路分类存储大小 存储单元（一个字节） 静态存储单元 动态存储单元（需要定时刷新，主要用电容） 寄存器（一组字节） 存储器（大量字节） SR锁存器 与非门SR锁存器 或非门SR锁存器 触发器电平触发的SR触发器 电平触发的D触发器为了适应单端输入信号需求，常用D输入代替S,R输入利用CMOS传输门组成电平触发的D触发器在clk有效期间，输出与输入相同，该触发器又被称为透明D触发器 边沿触发的D触发器该电路上升沿有效Q*&#x3D;D 脉冲触发的SR触发器 脉冲触发的JK触发器 边沿触发的T触发器 触发器的分类触发方式分类 无触发 电平触发 边缘触发 脉冲触发 触发器分类 SR触发器 D触发器 JK触发器 T触发器 触发方式与逻辑功能无逻辑关系 存储器随机存储器RAM(断电丢失) 静态存储器（SRAM,速度快，集成度低，成本高） 动态存储器（DRAM，速度慢，集成度高，成本低）只读存储器ROM(断电不丢失) 掩膜ROM 可编程ROM 可擦除可编程ROM 存储器的拼装时序逻辑电路 同步，一个时钟信号 异步 同步时序电路"},{"title":"陀螺仪的工作原理","path":"/2024/02/15/陀螺仪的工作原理/","content":"陀螺仪的分类提供位置与角速度的装置 机械陀螺仪 光学陀螺仪 测量各部分压力 光学陀螺仪，计算接受的合成光束与初始光束的相位差，算得偏转量","tags":["其他"]},{"title":"基础电气知识部分综合","path":"/2024/01/29/基础电气知识部分综合/","content":"上拉电阻与下拉电阻下拉电阻没有下拉电阻，引脚浮空，将不确定的信号钳位在低电平不确定阻值设置为10k-100K 上拉电阻将不确定的信号钳位在高电平，有时io驱动能力不足时也可以加上拉电阻 寄生电容即电路中的元件在物理上不是电容时表现得像电容。在高频电路中会导致信号的失真和噪声的增加 如何减少寄生电容1.缩短元件之间的距离，从而减小元件之间的电容。2.将元件引脚与地之间的距离尽量缩短，减小元件与地之间的电容。3.合适的PCB布局，有效减小PCB板上的电容。4.采用屏蔽措施，以便减小电磁干扰。 滤波电容 GPIO的输出模式 高阻输出（有内置上拉电阻，或外加上拉电阻） 推挽输出（参考CMOS功能，输出高低电平）","tags":["PCB设计"]},{"title":"12V转5V电源模块","path":"/2024/01/27/12V转5V电源模块/","content":"前言看了B站孙老师的视频，受益匪浅，决定设计自己的12V转5V的电源模块采用同步整流芯片TPS54302，改芯片数据手册如下 https://www.ti.com/cn/lit/ds/symlink/tps54302.pdf?ts=1706321372159&amp;ref_url=https%253A%252F%252Fitem.szlcsc.com%252F 2 4.5V 至 28V 输入、3A 输出、EMI 友好型同步降压转换 降压电路原理 芯片原理图 自己画的原理图由于实际封装与原理图不一致，自己画的并没有芯片原理图那么规整 第一版pcb设计设计注意要点 线宽 避免直角走线 元件选型 正面 反面 第二版pcb设计设计要点 反馈电路选取电在电容附近 铜箔走线，过大电流 对称，美观 电容电阻选型时要选择合适的封装，电容电阻常见封装为0603,0805,1206等 正面 反图 实物图","tags":["PCB设计"]},{"title":"模电","path":"/2024/01/20/模电/","content":"信号时间和数值 时间连续，数值连续（模拟信号） 时间不连续，数值连续（抽样信号） 时间连续，数值不连续（脉冲信号） 时间不连续，数值不连续（数字信号） 常用半导体器件基础知识 导体 半导体 绝缘体 常见半导体，硅(si)和锗(ge)四价元素 半导体分类，本征半导体与杂质半导体 载流子有自由电子与空穴 N型半导体(五价磷)与P型半导体(三价硼) 重点 PN节硅(si)原子结构 单晶硅齐纳击穿与雪崩击穿扩散运动与漂移运动正向特征 截止区（死区） 导通区 过流区 反向特征 反向饱和区 反向击穿区","tags":["课程"]},{"title":"数电","path":"/2024/01/11/数电/","content":"数制与码制进制转化原码，反码，补码 正数三码合一 负数，反码标志位不变，其他取反，补码，在反码基础上加1 计算机以补码形式运算 逻辑代数基础与或非及其变种 门电路概述 单开关电路与互补开关电路门电路的基本元件 二极管 三极管 MOS管 半导体二极管学习要点 二极管 理想二极管 实际二极管 理想开关 二极管的动态电流效应（类似电容） 二极管实现门电路实现0&#x2F;1实现与电路实现或电路 二极管门电路的缺陷 二极管实现的与或门有高低电平的偏移 负载影响输出的高电平 MOS管P沟道与n沟道MOS管 mos管的输入输出特性 截止区 可变电阻区 恒流区 P沟道与N沟道MOS的区别 CMOS反相器 组合逻辑电路逻辑电路分类 组合逻辑电路 时序逻辑电路（含存储器） 编码器 普通编码器 优先编码器 74HC148引脚定义 16线-4线输出原理图 74HC147（二-十进制优先编码器） 竞争与冒险现象是什么？有尖峰-冒险可能尖峰-竞争 如何判断？是否出现Y&#x3D;A+A’或Y&#x3D;AA’用EDA软件检查是否有毛刺现象，检查时序 如何解决？ 接滤波电容 引入选通信号（再有毛刺发生的时候不输出） 修改逻辑设计（增加冗余项）","tags":["课程"]},{"title":"电子电路基础知识","path":"/2024/01/06/电子电路基础知识/","content":"基础元件 电阻 电容 电感 二极管 三极管&#x2F;mos管 电阻色环电阻的辨认电阻的符号电阻的单位转换电阻的封装 三极管基极B,集电极C,发射极D.B极小电流控制C极大电流，具有电流放大作用 三种工作状态 截止状态 放大状态 饱和状态 MOS管源极S 栅极G 漏极D 特性 栅极阻抗高 易被静电击穿 参数 Vgsth 电压临界值 Rdson 电阻 Cgs 栅极电容 三极管与MOS管的区别 三极管是电流控制的元件，MOS管是电压控制的元件 MOS管省电，阻抗小 三极管便宜，耐高压大电流","tags":["电路"]},{"title":"51单片机核心板绘制","path":"/2024/01/01/51单片机核心板绘制/","content":"参考资料 https://blog.csdn.net/weixin_61121477/article/details/127743905 https://mp.weixin.qq.com/s/Ca96Eaom3HDGVuQAlgokvg https://blog.csdn.net/flying_man_/article/details/82557816 原理图 pcb图 3D渲染图 详解单片机最小系统包括核心模块有： 电源模块 复位模块 外部晶振模块 下载模块 本原理图中，采用type-c 16pin为下载和电源接口，根据单片机手册，输入电压为3.8v~5.5v.根据手册，P0开漏输出，原理图设计时，加上拉电阻作为I&#x2F;O口使用。 晶振模块采用32M,由手册提供，原理图并不完全符合。 https://zhuanlan.zhihu.com/p/72583737晶振电路原理详解 滤波电容，消除震荡。 usb转串口模块常用的有CH340N与CH340G。","tags":["单片机"]},{"title":"电子设计实训小组计划","path":"/2024/01/01/电子设计实训小组计划/","content":"电子设计实训小组计划于2024-01-01开启，新年新气象，这是一次积极的尝试。 初始成员6人 data:2024-01-01目的：锻炼电路设计，编程能力基本准则：共同商议，共同管理，共同进步 第一次计划：51单片机核心板的绘制 寒假学习：1.数电模电2.嘉立创的学习与使用3.个人博客（选修） data:2024-01-06四人完成51单片机的原理图绘制与pcb绘板工作准备开始打板测试工作 data:2024-01-17第一次寒假线上会议，确定基本任务 任务一：个人博客的制作 任务二：12V转5V电源模块 任务三：数电模电第一章的学习 任务四：在嘉立创免费范围内打点小东西 其他：电赛题目搜集。1月25复盘总结。 data:2024-01-25第二次寒假线上会议，总结上次成果12V转5V电源模块 个人博客的汇总http://shisan-ok.gitee.io https://sherlock000125.github.io https://fransic.top https://liwuyou.github.io 下阶段任务 数电第二章，模电第一章未完成继续 设计一个电机驱动模块 跑跑仿真 data:2024-02-02第三次寒假线上会议，总结上次成果电机驱动模块 data:2024-02-14会议重点:1.软件方面，自行处理2.本次做陀螺仪模块，主要处理信号方面，模块外围电路较少，尽量的设计好一点，熟悉芯片的选型，PCB走线信号线设计3.数电模电向前推进一章4.完善个人博客5.我们还差ADC的转换和射频，自行处理。ADC的转换比较重要","tags":["计划"]},{"title":"单片机的常见通讯协议","path":"/2023/12/30/单片机的常见通讯协议/","content":"常见单片机通讯协议 I2c通信 spi通信 I2c通信 https://blog.csdn.net/yanlaifan/article/details/72843577?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170393696216800226590203%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170393696216800226590203&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-72843577-null-null.142^v99^pc_search_result_base3&amp;utm_term=i2c%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E5%9B%BE&amp;spm=1018.2226.3001.4187 硬件层两根线，SDA(数据)和SCL(时钟)从最高位到最低位发送（MSB—&gt;LSB） 协议层协议 空闲态 起始信号 逻辑电平 时序图 停止位在时钟线为高时，数据线为高，为1，否则为0 代码以51单片机为例I2C.h文件 123456789101112#ifndef __I2C_H__#define __I2C_H__void I2C_Start(void);void I2C_Stop(void);void I2C_SendByte(unsigned char Byte);unsigned char I2C_ReceiveByte(void);void I2C_SendAck(unsigned char AckBit);unsigned char I2C_ReceiveAck(void);#endif I2C.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;REGX52.H&gt;sbit I2C_SCL=P2^1;sbit I2C_SDA=P2^0;/** * @brief I2C开始 * @param 无 * @retval 无 */void I2C_Start(void)&#123;\tI2C_SDA=1;\tI2C_SCL=1;\tI2C_SDA=0; I2C_SCL=0; &#125;/** * @brief I2C停止 * @param 无 * @retval 无 */void I2C_Stop(void)&#123;\tI2C_SDA=0;\tI2C_SCL=1;\tI2C_SDA=1;&#125;/** * @brief I2C发送一个字节 * @param Byte 要发送的字节 * @retval 无 */void I2C_SendByte(unsigned char Byte)&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; I2C_SDA=Byte&amp;(0x80&gt;&gt;i); I2C_SCL=1; I2C_SCL=0;\t&#125;&#125;/** * @brief I2C接收一个字节 * @param 无 * @retval 接收到的一个字节数据 */unsigned char I2C_ReceiveByte(void)&#123;\tunsigned char i,Byte=0x00;\tI2C_SDA=1;\tfor(i=0;i&lt;8;i++)\t&#123; I2C_SCL=1; if(I2C_SDA)&#123;Byte|=(0x80&gt;&gt;i);&#125; I2C_SCL=0;\t&#125;\treturn Byte;&#125;/** * @brief I2C发送应答 * @param AckBit 应答位，0为应答，1为非应答 * @retval 无 */void I2C_SendAck(unsigned char AckBit)&#123;\tI2C_SDA=AckBit;\tI2C_SCL=1;\tI2C_SCL=0;&#125;/** * @brief I2C接收应答位 * @param 无 * @retval 接收到的应答位，0为应答，1为非应答 */unsigned char I2C_ReceiveAck(void)&#123;\tunsigned char AckBit;\tI2C_SDA=1;\tI2C_SCL=1;\tAckBit=I2C_SDA;\tI2C_SCL=0;\treturn AckBit;&#125; 写入与读取1帧的数据 123456789101112131415161718192021222324252627282930313233void AT24C02_WriteByte(unsigned char WordAddress,Data)&#123;\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS);\tI2C_ReceiveAck();\tI2C_SendByte(WordAddress);\tI2C_ReceiveAck();\tI2C_SendByte(Data);\tI2C_ReceiveAck();\tI2C_Stop();&#125;/** * @brief AT24C02读取一个字节 * @param WordAddress 要读出字节的地址 * @retval 读出的数据 */unsigned char AT24C02_ReadByte(unsigned char WordAddress)&#123;\tunsigned char Data;\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS);\tI2C_ReceiveAck();\tI2C_SendByte(WordAddress);\tI2C_ReceiveAck();\tI2C_Start();\tI2C_SendByte(AT24C02_ADDRESS|0x01);\tI2C_ReceiveAck();\tData=I2C_ReceiveByte();\tI2C_SendAck(1);\tI2C_Stop();\treturn Data;&#125; 实验验证4路OLED的驱动基于I2C通信的陀螺仪","tags":["单片机"]},{"title":"大物下，复习补充","path":"/2023/12/24/大物下，复习补充/","content":"量子的部分，6-8分左右，速成课无本部分内容，特补充","tags":["课程"]},{"title":"复变函数与积分变换","path":"/2023/12/15/复变函数与积分变换/","content":"马上就要考试了，悲 复数与复变函数复数的三种形式 复数的一般形式 $Z&#x3D;x+yi$ 复数的三角表示 $Z&#x3D;r(\\cos\\theta+j\\sin\\theta)$ 复数的指数形式 $Z&#x3D;re^{i\\theta}$ 复数的主值与辐值$$ArgZ &#x3D; argZ + 2k\\pi$$其中 $0 \\leq argZ&lt;2\\pi$ 主值的求解公式 棣莫弗公式 ★$$Z^n&#x3D;[r(\\cos\\theta+i\\sin\\theta)]^n&#x3D;r^n(\\cos{n\\theta}+\\sin{n\\theta})&#x3D;re^{in\\theta}$$当r&#x3D;1时，有$$(\\cos\\theta+i\\sin\\theta)^n&#x3D;\\cos{n\\theta}+\\sin{n\\theta}$$逆运用$$w&#x3D;r^{\\frac{1}{n}}[\\cos(\\frac{1}{n}(\\theta+2k\\pi))+i\\sin(\\frac{1}{n}(\\theta+2k\\pi))]$$ 其中$k&#x3D;0,1,2,…,n-1$$r&#x3D;|Z|$ 练习共轭复数$ReZ&#x3D;\\frac{Z+\\overline{Z}}{2}$$ImZ&#x3D;\\frac{Z-\\overline{Z}}{2i}$ 解析函数解析函数：概念性质、充分&#x2F;必要条件、调和函数、初等函数 解析概念：$w&#x3D;f(Z)$如果在$Z_{0}$及其领域内处处可导，则$f(Z)$在$Z_{0}$处解析解析-&gt;可导-&gt;连续反之不行 函数解析的充要条件（柯西-黎曼方程）C-R方程$f(z)&#x3D;u(x,y)+iv(x,y)$在$z&#x3D;x+iy$处处可导的充要条件是$u(x,y)$，$v(x,y)$在点$(x,y)$处可微$$\\frac{\\partial u}{\\partial x}&#x3D;\\frac{\\partial v}{\\partial y}且\\frac{\\partial u}{\\partial y}&#x3D;-\\frac{\\partial v}{\\partial x}$$ 调和函数调和函数和解析函数针对的对象不同解析函数针对$f(Z)$调和函数针对$u(x,y)与v(x,y)$ 拉普拉斯方程（Laplace）$$\\frac{\\partial^{2} \\varphi}{\\partial^{2}x}+ \\frac{\\partial^{2} \\varphi}{\\partial^{2}y}&#x3D;0$$解析函数的实部和虚部是调和函数 初等函数指数函数$$e^{Z}&#x3D;e^{x+iy}&#x3D;e^{x}(\\cos x +i\\sin y)$$指数函数性质有： $ |e^{Z}|&#x3D;e^{x}$ $Arg(e^{Z})&#x3D;y+2k\\pi$ $e^{Z+i2k\\pi}&#x3D;e^{Z}，即e^{Z}是以2k\\pi 为周期的周期函数$ $(e^{Z})’&#x3D;e^{Z}$ 对数函数$LnZ&#x3D;lnZ+i2k\\pi&#x3D;ln|Z|+iargZ+i2k\\pi$ 幂函数$a^{b}&#x3D;e^{(Lna)b}$ 三角函数 反三角函数 练习复变函数的积分定义及如何积分定义在简单光滑或分段光滑上的有向曲线上的积分$$f(Z)&#x3D;u(x,y)+iv(x,y)$$$$f_{c}(Z)dZ$$如何积分？两种方法 第二型曲线积分$$\\int_{c}(Z)dZ&#x3D;\\int_{c}u(x,y)+iv(x,y)dZ&#x3D;\\int_{c}udx-vdy+i\\int_{c}vdx+udy$$ 参数法$$\\int_{c}(Z)dZ&#x3D;\\int^{\\beta}_{\\alpha}f(Z(t))Z’(t)dt$$ 柯西-古萨定理$$\\oint_{c}f(Z)dZ&#x3D;0$$$f(Z)$在C上及D内解析则成立 复合闭路定理推导$f(Z)$在$\\Gamma$上解析，且$\\Gamma&#x3D;C+C^{-}{1}+C^{-}{2}$+…，则$\\oint_{\\Gamma}f(Z)dZ&#x3D;0$，代入$\\Gamma &#x3D;C+C^{-}{1}+C^{-}{2}$+…则$\\oint_{C+C^{-}{1}+C^{-}{2}+…}f(Z)dZ&#x3D;0$ 化简移项可得 $$\\oint_{c}f(Z)dZ&#x3D; \\sum_{n&#x3D;1}^n\\oint_{C_{k}}f(Z)dZ$$当k&#x3D;1时，则得 $$\\oint_{c}f(Z)dZ&#x3D; \\oint_{k}f(Z)dZ$$ 柯西积分公式 ★适用条件：$f(Z)$要在C上及其内部解析$$\\oint_{c}\\frac{f(Z)}{Z-Z_{0}}dZ&#x3D; 2\\pi if(Z_{0})$$高阶$$\\oint_{c}\\frac{f(Z)}{(Z-Z_{0})^{n-1}}dZ&#x3D; \\frac{2\\pi i}{n!} f(Z_{0})$$ 级数(研究其敛散性)级数的一些性质$\\sum_{n&#x3D;1}^n|Z|$收敛，则$\\sum_{n&#x3D;1}^nZ$也收敛 $\\sum_{n&#x3D;1}^n\\frac{1}{n}$是发散的 复数序列$Z_{1}&#x3D;a_{1}+b_{1}i$，$Z_{2}&#x3D;a_{2}+b_{2}i$，…$Z_{n}&#x3D;a_{n}+b_{n}i$，…上面的序列，简记为$${Z_{n}}$$ 项级数如何判断一个项级数是收敛还是发散的呢？部分和判断部分和为$$S_{n}&#x3D;Z_{1}+Z_{2}+…Z_{n}$$部分和序列$${S_{n}}&#x3D;S_{1}+S_{2}+…S_{n}$$ 幂级数 ★形式和收敛半径要记住，收敛半径的求法，比值法和根值法。其级数在其收敛半径内部绝对收敛，在其收敛半径上不一定。 幂级数和函数性质2的应用 幂级数的运算（加减乘除）对应题型，将函数展开为Z的幂级数（不熟练） 泰勒级数常见泰勒展开泰勒展开的形式 洛朗级数洛朗级数&#x3D;负幂项+正幂项洛朗级数是收敛圆环题型 求收敛圆环的半径 展开为洛朗级数负幂项的收敛半径按正幂项求，最后取倒数。 留数及其应用奇点及奇点的分类及求法 孤立奇点（洛朗展开仅有正幂项） n阶极点（有负幂项，部分为0） 本性奇点（洛朗展开既有正幂项，又有负幂项） 零点及m阶零点零点和极点的关系 留数定义计算 ★一阶极点的留数的快速求法","tags":["课程"]},{"title":"爬虫入门","path":"/2023/12/14/爬虫入门/","content":"爬虫简介爬虫的概念通过编写程序，模拟浏览器上网，然后让其抓取数据的过程 爬虫分类 通用爬虫（整张页面） 聚焦爬虫（局部内容） 增量式爬虫（抓取更新内容） 爬虫的矛与盾 爬虫 反爬机制 反反爬策略 robots.txt协议君子协议，规定可爬取，不可爬取网址后面加&#x2F;robots.txt 即可访问 http协议 概念：服务器与客户端进行数据交互的一种形式 常用请求头信息 User-Agent:请求载体的身份标识 Connection:请求完毕后，是断开连接还是保持连接 常用响应头信息 Content-Type: 服务器响应回客户端的数据类型 https协议:安全的超文本传输协议 加密方式 对称秘钥加密 非对称秘钥加密 证书秘钥加密 requests请求requests模块: python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 作用:模拟浏览器发请求。 如何使用: (requests模块的编码流程) 指定urT 发起请求 获取响应数据 持久化存储环境安装:pip install requests 实战编码:需求: 爬取搜狗首页的页面数据1234567891011121314import requestsif __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/&#x27; # 发起请求 response = requests.get(url=url) # 获取响应数据,text返回的是字符串 page_text = response.text print(page_text) # 持久化存储 with open(&quot;./sogou.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://blog.csdn.net/m0_46778548/article/details/121201868Python文件读写操作 https://blog.csdn.net/qiqicos/article/details/79200089python 里with… as.. 的操作方法 需求: 爬取搜狗指定头条学习点UA伪装 123456789101112131415161718192021222324252627import requests#UA:User-Agent.(请求载体的身份标识)# UA检测门户网站的服务器会检测对应请求的载体身份标识,不正常则服务器端就很有可能拒绝该次请求# UA伪装if __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/web&#x27; # UA伪装:将对应的User-Agent封装到一个完典中 headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0&#x27;&#125; # 处理参数并字典封装 ws = input(&quot;Please enter a word:&quot;) param = &#123;&#x27;query&#x27;: ws&#125; # 对指定的url发起的请求对应的urL是携带参数的，并且请求过程中处理了参数 response = requests.get(url=url, params=param, headers=headers) # 持久化存储 page_text = response.text print(page_text) with open(&quot;./&quot;+ws+&quot;.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://www.runoob.com/python3/python-requests.htmlrequest模块详解","tags":["python"]},{"title":"基于树莓派上位机与arduino下位机实现键盘控制","path":"/2023/12/14/基于树莓派上位机与arduino下位机实现键盘控制/","content":"实现键盘控制小车行驶 下位机代码，Arduino的5号引脚为电机引脚，9号引脚为舵机引脚 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;Servo.h&gt; Servo myservo;String str;int pos = 92; //舵机角度int motor_pwm = 100; //电机数值0 ~255int pos_mid = 92; // 储存舵机中值角度int motorPin = 5; // 确定motor控制引脚int servoPin = 9; //确定servo控制引脚 void setup() &#123; Serial.begin(115200); myservo.attach(servoPin); // 该舵机由arduino第9脚控制 pinMode(motorPin, OUTPUT); // 将电机引脚设为输出模式 myservo.write(pos_mid); // 舵机复位 analogWrite(motorPin,0); // 电机初始转动 delay(1000);&#125; void loop() &#123; if (Serial.available() &gt;= 2) &#123; int servoValue = Serial.read(); int motorValue = Serial.read(); // 控制舵机 myservo.write(servoValue); if (servoValue &lt;40) servoValue=40; else if(servoValue &gt; 140) servoValue=140; Serial.print(&quot;servo: &quot;); Serial.println(servoValue); // 控制电机 if (motorValue &lt;0) motorValue=0; else if(motorValue &gt; 255) motorValue=255; analogWrite(motorPin, motorValue); Serial.print(&quot;motor: &quot;); Serial.println(motorValue); &#125; &#125; 上位机代码文件名 key_control.py 123456789101112131415161718192021222324252627282930313233343536373839404142# Author: 无忧# Date: 2023-12-02# Description: 这是一个键盘控制的简单代码# 请调节键盘状态为英语小写状态# -------------------- import keyboardimport time# 要下包keyboardfrom send_M_S import * speed = 0speed_max = 60 # 速度的最大值turn = 92 # 舵机中值turn_l = 60 # 舵机打角最左turn_r = 120 # 舵机打角最右 if __name__ == &quot;__main__&quot;: ser = init_send() while True: try: if keyboard.is_pressed(&#x27;w&#x27;): speed += 5 if speed &gt;= speed_max: speed = speed_max elif keyboard.is_pressed(&#x27;a&#x27;): turn -= 8 if turn &lt;= turn_l: turn = turn_l elif keyboard.is_pressed(&#x27;d&#x27;): turn += 8 if turn &gt;= turn_r: turn = turn_r elif keyboard.is_pressed(&#x27;s&#x27;): speed -= 5 if speed &lt;= 0: speed = 0 time.sleep(0.1) # 系统响应速度 send_values(ser, turn, speed) except KeyboardInterrupt: break 上位机串口代码文件名send_M_S 123456789101112131415161718192021222324252627282930313233# Author:# Date: 2023-12-02# Description: This script does XYZ.import serialimport timeimport sys # 设置串口参数def init_send(): ser = serial.Serial(&#x27;COM4&#x27;, 115200, timeout=1) return ser def send_values(ser, servo_value, motor_value): # 向串口发送舵机值和电机值 time.sleep(0.1) ser.write(bytes([servo_value, motor_value])) while ser.in_waiting: arduino_feedback = ser.readline().decode() print(&quot;Arduino:&quot;, arduino_feedback) if __name__ == &#x27;__main__&#x27;: # 初始化串口 ser = init_send() try: while True: for i in range(60, 120, 1): send_values(ser, i, 50) for i in range(120, 60, -1): send_values(ser, i, 50) except KeyboardInterrupt: # 在用户按下 Ctrl+C 时，关闭串口并退出程序 ser.close() sys.exit()","tags":["arduino"]},{"title":"电路复习","path":"/2023/11/14/电路复习/","content":"写在前面的话我打算尝试一下，用markdown，部署到网页进行电路的学习与记录困难点来自两1.多图片，图床问题2.多数学公式 这是一次有意义的探索，一次尝试 电路的简化电压源串联电流源并联电压源与电流源的串联相当与电流源 电压源与电流源的并联相当与电压源 电流源的内阻为无穷大 电压源与电流源的转化$\\Delta$与Y的等效变换$\\Delta$ -&gt; Y $$Y型电阻 &#x3D; \\frac{\\Delta相邻电阻乘积}{\\Delta电阻之和}$$Y -&gt; $\\Delta$$$\\Delta型电阻 &#x3D; \\frac{Y型电阻两两乘积之和}{Y型不相邻电阻}$$相同阻值情况下，3Y&#x3D;$\\Delta$ 电源置零独立电压源短路，独立电流源断路 独立源与受控源受控源 vcvc 电压控制的电压源 vccs 电压控制的电流源 ccvs 电流控制的电压源 cccs 电流控制的电流源 voltage 电压 current 电流 control控制 source源 输入电阻无源一端口网络的等效变换，无源指的是无独立电源简而言之，一个不含独立源的一端口网路，等效为一个电阻$R_{eq}$输入电阻求法 外加电源法 建议外加电压源$$R_{eq} &#x3D; \\frac{u}{i}$$注意，在存在受控源的情况下，R可能为负。 【大学电路习题讲解——求输入电阻1】 【精准空降到 00:19】 https://www.bilibili.com/video/BV1z7411W72Z/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6&amp;t=19 三种电流方法基本概念 结点(n) 支路(b) 网孔 网孔数&#x3D;独立回路数 支路电流法（基本用不到） 找出支路数(b)，找出结点数(n) 列n-1个KCL方程 列b-n+1个KVL方程 联立求解 回路电流法 找出b-n+1个回路 列方程求解 $$R_{11}i_{1}+R_{12}i_{2}+… &#x3D; u_{11}$$$$R_{21}i_{1}+R_{22}i_{2}+… &#x3D; u_{22}$$$$R_{31}i_{1}+R_{32}i_{2}+… &#x3D; u_{22}$$$$……$$$$R_{n1}i_{1}+R_{n2}i_{2}+… &#x3D; u_{22}$$ 其中，$R_{11}$…$R_{nn}$为回路n的电阻之和$R_{21}$&#x3D;$R_{12}$为回路1，2共有的电阻(方向相同则为正)$u_{11}$回路1所有电压源之和，指定电流由“+” -&gt; “—”取负，反之 结点电压 找出所有结点，选取待测相关的一个结点为0，其他分别为1，2，… 将与电流源串联的电阻变导线，与电压源并联的电阻变短路 列方程求解$$G_{11}u_{n1}+G_{12}u_{n2}+… &#x3D; i_{s11}$$$$G_{21}u_{n1}+G_{22}u_{n2}+… &#x3D; i_{s22}$$$$G_{31}u_{n1}+G_{32}u_{n2}+… &#x3D; i_{s33}$$ 其中，$i_{s11}$&#x3D;$\\frac{电压源}{所在支路电阻}+电流源$，流入结点为正，流出为负 例题精讲（待补充）电路原理叠加定理 https://www.bilibili.com/video/BV1HF411W7L9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=755a0f899976f771c7923daed9448d48 表述：在线性电阻电路中，某处电压或电流都是各个独立电源单独作用时，电压与电流的叠加 注意： 某电源作用时，其他独立源置零 受控源不置零 线性电路 可设置0电压的点，即接地 替换定理简述：任何一个支路（端口）已知电压或电流，就可以将该支路（端口）用电压源或电流源替代。既可以线性电路，也可以非线性 适用条件及其注意点不要把受控源的控制量替换掉 戴维南定理（等效电压源定理）简述：将一个二端网路，等效为一个电压源串联一个等效电阻。注意开路，开路！！步骤： 剥离待求项，将原电路化为开路二端网络，求U, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电压源串联一个等效电阻 诺顿定理（等效电流源定理）简述：将一个二端网路，等效为一个电流源并联一个等效电阻。 剥离待求项，将原电路d待求项短接，求I, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电流源并联一个等效电阻 戴维宁求谁断路谁，诺顿求谁断路谁，然后电源置零，用外加电压法$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$，求输入电阻 储能元件电容（电流记忆元件）VCR为$$i &#x3D; C\\frac{ d_{u}}{d_{t}}$$ 电感（电压记忆元件）VCR为$$u&#x3D; L\\frac{ d_{i}}{d_{t}}$$ 电容与电感的串并联电容的串并联与电阻相反电感的串并联与电阻类似 RC电路与RL电路的响应$$U_{c}&#x3D;U_{c}(\\infty)+[U_{c}(0_{+})-U_{c}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;RC)$$1.电容断路，求$U_{c}(\\infty)$和$U_{c}(0_{+})$，求变化前后稳定时的电压。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电容断路，求输入电阻3.代入求解 $$I_{L}&#x3D;I_{L}(\\infty)+[I_{L}(0_{+})-I_{L}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;R&#x2F;L)$$1.电感短路路，求$I_{L}(\\infty)$和$I_{L}(0_{+})$，求变化前后稳定时的电流。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电感断路，求输入电阻3.代入求解 补充$$U(t)&#x3D;U(t_{0})+\\frac{1}{C}\\int_{t_{0}}^tI_{t}d\\xi$$$$I(t)&#x3D;I(t_{0})+\\frac{1}{L}\\int_{t_{0}}^tu_{t}d\\xi$$ 一阶电路与二阶电路的时域分析零输入响应（无电源）零状态响应（未充能）全响应（有电源且电容已充能）向量法复数的三种形式$$F&#x3D;|F|(\\cos\\theta+j\\sin\\theta)&#x3D;a+jb$$$$F&#x3D;|F|e^{j\\theta}$$$$F&#x3D;|F|\\angle\\theta$$ 欧拉公式$$e^{j\\theta}&#x3D;(\\cos\\theta+j\\sin\\theta)$$$$e^{j\\pi}+1&#x3D;0$$ 正弦量$$u&#x3D;U_{max}\\cos(wt+\\psi)&#x3D;\\sqrt{2}V\\cos(wt+\\psi)&#x3D;V\\angle\\theta$$注意，向量法表述时为有效值 https://zhuanlan.zhihu.com/p/110148728 电路定理的向量形式基尔霍夫定律$$\\Sigma i(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{I}(t)&#x3D;0$$$$\\Sigma u(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{U}(t)&#x3D;0$$ 电路元件的向量关系$$u&#x3D;Ri \\rightleftarrows \\dot{U}&#x3D;R\\dot{I}$$$$u&#x3D; L\\frac{ d_{i}}{d_{t}} \\rightleftarrows \\dot{U}&#x3D;jwL\\dot{I}$$$$u&#x3D;\\frac{1}{C}\\int idt \\rightleftarrows \\dot{U}&#x3D;\\frac{1}{jwC}\\dot{I}&#x3D;-j\\frac{1}{wC}\\dot{I}$$","tags":["课程"]},{"title":"numpy库的学习","path":"/2023/10/24/numpy库的学习/","content":"参考资料 https://www.runoob.com/numpy/numpy-tutorial.html 线性代数基础概念理解线性代数的概念忘了，这里补一补 https://zhuanlan.zhihu.com/p/422251943 numpyNumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C&#x2F;C++&#x2F;Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能","tags":["python"]},{"title":"python的os库的使用","path":"/2023/10/22/python的os库的使用/","content":"参考资料 https://blog.csdn.net/m0_55697123/article/details/119464001 https://blog.csdn.net/wulishinian/article/details/106420532 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport time# print(os.system(&#x27;C:\\\\Windows\\\\System32\\\\calc.exe&#x27;))print(os.name) # linux 显示posixprint(os.environ) # 环境变量# windows \\ , linux /# 常用系统相关变量，sep分隔符print(os.sep)print(os.pathsep)print(os.linesep)# 文件和目录操作# os.mkdir(&quot;test&quot;) # 在当前路径下创建目录# os.rmdir(&quot;test&quot;) # delete目录# os.remove(&quot;文件名&quot;) #delete文件print(os.getcwd()) # 打印当前目录# os的子模块 os.pathfile = os.getcwd()+&quot;/main.py&quot;print(os.path.split(file)) # 分割文件名和路径mkdir, filename = os.path.split(file)print(filename)# 判断绝对路径与相对路径print(os.path.isabs(file)) # 是绝对，则返回TRUE# 判断文件或目录是否存在print(os.path.exists(file))# 拿到目录或文件最后修改时间，开始创建时间print(os.path.getatime(file)) # 显示时间戳print(os.path.getctime(file)) #print(os.path.getsize(file)) # 拿到文件大小,字节# 执行命令# os system popen 不推荐使用 执行结果 1234567891011121314151617181920ntenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming&#x27;, &#x27;COMMONPROGRAMFILES&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMMONPROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)\\\\Common Files&#x27;, &#x27;COMMONPROGRAMW6432&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMPUTERNAME&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;COMSPEC&#x27;: &#x27;C:\\\\Windows\\\\system32\\\\cmd.exe&#x27;, &#x27;DRIVERDATA&#x27;: &#x27;C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData&#x27;, &#x27;HOMEDRIVE&#x27;: &#x27;C:&#x27;, &#x27;HOMEPATH&#x27;: &#x27;\\\\Users\\\\Windows&#x27;, &#x27;IDEA_INITIAL_DIRECTORY&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\Desktop&#x27;, &#x27;LOCALAPPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local&#x27;, &#x27;LOGONSERVER&#x27;: &#x27;\\\\\\\\DESKTOP-0R6DJK5&#x27;, &#x27;NUMBER_OF_PROCESSORS&#x27;: &#x27;4&#x27;, &#x27;ONEDRIVE&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;ONEDRIVECONSUMER&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;OS&#x27;: &#x27;Windows_NT&#x27;, &#x27;PATH&#x27;: &#x27;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\ odejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Scripts\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming\\ pm;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PATHEXT&#x27;: &#x27;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#x27;, &#x27;PROCESSOR_ARCHITECTURE&#x27;: &#x27;AMD64&#x27;, &#x27;PROCESSOR_IDENTIFIER&#x27;: &#x27;Intel64 Family 6 Model 78 Stepping 3, GenuineIntel&#x27;, &#x27;PROCESSOR_LEVEL&#x27;: &#x27;6&#x27;, &#x27;PROCESSOR_REVISION&#x27;: &#x27;4e03&#x27;, &#x27;PROGRAMDATA&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;PROGRAMFILES&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)&#x27;, &#x27;PROGRAMW6432&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PSMODULEPATH&#x27;: &#x27;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules&#x27;, &#x27;PUBLIC&#x27;: &#x27;C:\\\\Users\\\\Public&#x27;, &#x27;PYCHARM&#x27;: &#x27;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PYCHARM_DISPLAY_PORT&#x27;: &#x27;63342&#x27;, &#x27;PYCHARM_HOSTED&#x27;: &#x27;1&#x27;, &#x27;PYTHONIOENCODING&#x27;: &#x27;UTF-8&#x27;, &#x27;PYTHONPATH&#x27;: &#x27;D:\\\\opencv_study;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_matplotlib_backend;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_display&#x27;, &#x27;PYTHONUNBUFFERED&#x27;: &#x27;1&#x27;, &#x27;SESSIONNAME&#x27;: &#x27;Console&#x27;, &#x27;SYSTEMDRIVE&#x27;: &#x27;C:&#x27;, &#x27;SYSTEMROOT&#x27;: &#x27;C:\\\\Windows&#x27;, &#x27;TEMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;TMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;USERDOMAIN&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERDOMAIN_ROAMINGPROFILE&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERNAME&#x27;: &#x27;Windows&#x27;, &#x27;USERPROFILE&#x27;: &#x27;C:\\\\Users\\\\Windows&#x27;, &#x27;WINDIR&#x27;: &#x27;C:\\\\Windows&#x27;&#125;)\\;D:\\opencv_study(&#x27;D:\\\\opencv_study&#x27;, &#x27;main.py&#x27;)main.pyTrueTrue1697922899.98245931697807194.7697878986Process finished with exit code 0 python文件打开新的终端，并执行文件linux 环境在写Python程序的时候遇到需要打开一个新的终端(terminal)或者说命令行窗口进行监视的情况 12345import osos.system(&quot;gnome-terminal -e &#x27;ls&#x27;&quot;) # 窗口执行后关闭os.system(&quot;gnome-terminal -e &#x27;bash -c \\&quot;ls; exec bash\\&quot;&#x27;&quot;) # 窗口执行后不关闭# 其中 &#x27;ls&#x27; 部分即为所需执行的内容。 Windows环境1234import osos.system(&quot;start powershell.exe cmd /k &#x27;dir&#x27;&quot;)# 其中 &#x27;dir&#x27; 部分即为所需执行的内容","tags":["python"]},{"title":"opencv學習","path":"/2023/10/19/opencv學習/","content":"参考资料 https://www.bilibili.com/video/BV1ET4y127vd/?spm_id_from=333.999.0.0&amp;vd_source=755a0f899976f771c7923daed9448d48 https://opencv.apachecn.org/ opencv简介是什么？计算机视觉开源软件库 numpy opencv-python的安装打开cmd输入 123pip install opencv-pythonpip install opencv-contrib-python 开梯子下载更快 测试代码 123456import cv2# 读一个图片并进行显示(图片路径需自己指定)lena=cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, lena) # 打开新窗口，窗口名为image,显示Lenacv2.waitKey(0) opencv模块其中core、highgui、imgproc是最基础的模块，该课程主要是围绕这几个模块展开的，分别介绍如下: core模块实现了最核心的数据结构及其基本运算，如绘图函数、数组操作相关函数等 highgui模块实现了视频与图像的读取、显示、存储等接口。 imgproc模块实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、闻值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。 其他 features2d模块用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。obidetect模块实现了一些目标检测的功能，经典的基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification (级联分类)和Latent SVM等。 stitching模块实现了图像拼接功能。 FLANN模块 (Fast Library for Approximate Nearest Neighbors)，包含快速近似最近搜索FLANN和聚类Clustering算法。 ml模块机器学习模块 (SVM，决策树，Boosting等等) photo模块包含图像修复和图像去噪两部分。 video模块针对视频处理，如背景分离，前景检测、对象跟踪等。 calib3d模块即Calibration (校准)3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。G-API模块包含超高效的图像处理pipeline引擎 图像的基础操作 掌握图像的读取和保存方法 能够使用OpenCV在图像上绘制几何图形 能够访问图像的像素 能够获取图像的属性，并进行通道的分离和合并0 能够实现颜色空间的变换 读取图像1cv.imread(&quot;路径&quot;) cv.IMREAD*COLOR:以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。 cv.IMREAD*GRAYSCALE: 以灰度模式加载图像 Cv.IMREAD UNCHANGED: 包括alpha通道的加载图像模式。可以使用1、0或者-1来替代上面三个标志12345678import numpy as npimport cv2#以灰度图的形式读取图像img = cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, img)cv2.waitKey(0) 注意:如果加载的路径有错误，不会报错，会返回一个None值 显示图像1cv.imshow(&quot;窗口名&quot;， 图片) 注意:在调用显示图像的API后，要调用cv.waitKey()&#x2F;&#x2F;等待键盘输入 给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来。waitkey(0)，永远等待另外我们也可使用matplotlib对图像进行展示。 保存图像1cv.imwrite(&quot;文件名&quot;， 图片变量) 总结： 12345678910import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt#读取图像img = cv.imread(&#x27;1.png&#x27;,1)# 利用opencv展示图像cv.imshow( &#x27; image&#x27;, img)k = cv.waitKey(0)# 3 保存图像cv.imwrite( &#x27;messigray.png&#x27;,img) course_1code123456789101112131415161718192021222324252627# 学习了基本操作，imread(), imwrite()等import cv2 as cv# 获取摄像头cap = cv.VideoCapture(0)# set the height(3) and width(4) of the windows# windows系统下，微软surface的系统摄像头，该设置失效，原因未明# 外置摄像头OKcap.set(3, 640)cap.set(4, 480)# set brightness# 但好像也没什么用cap.set(10, 0.00001)while True: success, img = cap.read() cv.imshow(&quot;camera&quot;, img) if cv.waitKey(1) == ord(&#x27;Q&#x27;) or cv.waitKey(1) == 27: # 当所有事完成，释放 VideoCapture 对象 cap.release() cv.destroyAllWindows() break 详解1234cap = cv.VideoCapture(2)VideoCapture()中参数是0，表示打开笔记本的内置摄像头，参数是视频文件路径，打开方式如下：cap = cv2.VideoCapture(“../test.avi”) 12success, img = cap.read()cap.read()按帧读取视频，ret,frame是获cap.read()方法的两个返回值。 其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就为False。frame就是每一帧的图像，是个三维矩阵。 1234waitKey（）方法本身表示等待键盘输入，参数是1，表示延时1ms切换到下一帧图像。对于视频而言；参数为0，如cv2.waitKey(0)只显示当前帧图像，相当于视频暂停；参数过大如cv2.waitKey(1000)，会因为延时过久而卡顿感觉到卡顿。c得到的是键盘输入的ASCII码，esc键对应的ASCII码是27，即当按esc键是if条件句成立 course_2code1234567891011121314151617181920212223242526272829303132333435import cv2 as cvimport numpy as npaaa = np.ones((5, 5), np.uint8)# cv.imread(&quot;路径&quot;， 参数)，参数不传，默认参数1img = cv.imread(&quot;img/1 (1).jpg&quot;)# cv2.namedWindow(‘窗口标题’,默认参数) 创建新窗口cv.namedWindow(&#x27;Local Camera&#x27;, 0)# 设置显示的窗口大小为500,500，建议大于等于摄像头分辨率cv.resizeWindow(&quot;Local Camera&quot;, 300, 300)cv.imshow(&quot;Local Camera&quot;, img)# 灰度图片imgGray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)cv.imshow(&quot;show imgGray&quot;, imgGray)# 高斯模糊imgBlur = cv.GaussianBlur(img, (7, 7), 0)cv.imshow(&quot;show imgBlur&quot;, imgBlur)# 边缘检测imgCanny = cv.Canny(img, 150, 200)cv.imshow(&quot;show imgCanny&quot;, imgCanny)# 膨胀imgDilation = cv.dilate(imgCanny, aaa, iterations=1)cv.imshow(&quot;show imgDilation&quot;, imgDilation)# 腐蚀imgErode = cv.erode(imgDilation, aaa, iterations=1)cv.imshow(&quot;show imgErode&quot;, imgErode)cv.waitKey(0) course_3学习图像像素查看，图片大小调整，图片裁剪 opencv的X,Y的位置 code12345678910111213141516171819202122232425import cv2 as cvimport numpy as npimg = cv.imread(&quot;img/1 (1).jpg&quot;)print(img.shape)print(img.shape[0])# 打印出(1526, 1080, 3)# 打印出的分别是，高，宽，BGR# 图像大小调整，参数为宽，高a = int(img.shape[1]*0.3)b = int(img.shape[0]*0.3)imgResize = cv.resize(img, (a, b))print(imgResize.shape)# 图像裁剪 高与宽imgCropped = img[0:400, 200:400]cv.imshow(&quot;LOCAL img&quot;, img)cv.imshow(&quot;LOCAL imgResize&quot;, imgResize)cv.imshow(&quot;LOCAL imgCropped&quot;, imgCropped)cv.waitKey(0) course_4 绘画12345678910111213141516171819202122import cv2 as cvimport numpy as np# 0为黑，1为白img = np.zeros((400, 400))img1 = np.zeros((400, 400, 3))imgBlue = img1.copy() # 令imgBlub = img，则会报错，img为二维数组，只有黑白imgBlue[:] = 255, 0, 0# 划线，参数1,图片，参数2，起始点,参数3，终止点，参数4，color 参数5，厚度cv.line(img1, (0, 0), (400, 250), (255, 255, 255), 1)# 画矩形，参数配置同上,参数5也可用cv.FILLED,填充cv.rectangle(img1, (0, 0), (400, 200), (255, 255, 0), 2)# 画圆cv.circle(img1, (200, 70), 30, (255, 255, 100), cv.FILLED)cv.imshow(&quot;img&quot;, img)cv.imshow(&quot;img2&quot;, img1)cv.imshow(&quot;imgBlue&quot;, imgBlue)cv.waitKey(0) course_5 透视变换12345678910111213141516import cv2 as cvimport numpy as np# 矩阵变换width, height = 250, 350img = cv.imread(&quot;img/1 (15).png&quot;)pts1 = np.float32([[108, 240], [276, 209], [150, 491], [342, 451]])pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])matrix = cv.getPerspectiveTransform(pts1, pts2) # 获得透视矩阵out_img = cv.warpPerspective(img, matrix, (width, height)) # 透视cv.imshow(&quot;local img&quot;, img)cv.imshow(&quot;out_img img&quot;, out_img)cv.waitKey(0) 解析cv2.getPerspectiveTransform()是一个OpenCV函数，用于获取透视变换矩阵。它需要两个参数，分别是源图像中待测矩形的四点坐标和目标图像中矩形的四点坐标。它返回一个3x3的变换矩阵，可以用于cv2.warpPerspective()函数进行透视变换。 1234567891011121314import cv2import numpy as np# 定义源图像中待测矩形的四点坐标pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])# 定义目标图像中矩形的四点坐标pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])# 获取透视变换矩阵M = cv2.getPerspectiveTransform(pts1, pts2)# 输出变换矩阵print(M) 输出为 123[[ 8.24482681e-01 -1.02318154e-01 -3.33674687e+01] [ 1.18180922e-01 9.43895645e-01 1.17818491e+01] [ 1.65498408e-04 -1.69338403e-04 1.00000000e+00]] warpPerspective()函数主要作用：对图像进行透视变换，就是变形cv.warpPerspective是OpenCV中的一个函数，主要用于对图像进行透视变换。它可以将原始图像中的任意四边形区域转换为目标图像中的矩形区域，从而实现图像的透视变换。该函数的语法如下： 1dst = cv.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) 其中，参数含义如下：src：输入图像，可以是8位无符号整数、32位浮点数或16位有符号整数。M：3x3变换矩阵。dsize：输出图像的大小。dst：输出图像，与输入图像具有相同的数据类型和通道数。flags：插值方法的标志，可以是cv2.INTER_NEAREST、cv2.INTER_LINEAR、cv2.INTER_CUBIC、cv2.INTER_AREA、cv2.INTER_LANCZOS4等。borderMode：边界填充模式，可以是cv2.BORDER_CONSTANT、cv2.BORDER_REPLICATE、cv2.BORDER_REFLECT、cv2.BORDER_WRAP等.borderValue：边界填充值。","tags":["opencv"]},{"title":"linux系统学习","path":"/2023/10/10/linux系统学习/","content":"计算机硬件结构冯 诺依曼结构 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 其他主流计算机硬件结构 哈佛体系 计算机之父 冯 诺依曼图灵 计算机硬件组成输入设备输出设备存储器RAMRAM(random access memory) 即随机存储内存 速度快，容量小 掉电易失 逻辑IO ROMROM (Read-Onboy Memory) 即只读内存硬盘 容量大，速度相对较慢 长久保存 物理10 运算器、控制器网络连接 ip地址 子网掩码 默认网关 DNS ip地址IPADDRip地址 &#x3D; 网络地址+主机地址ip地址是一个4*8bit由0&#x2F;1组成的字符串（ip4协议） 子网掩码","tags":["linux"]},{"title":"arduino的系统学习","path":"/2023/09/29/arduino的系统学习/","content":"我还是决定系统学一下arduino，虽然系统学，但仍是速成，由于碰到一些事情我意识到自己还不够努力，就从arduino开始吧 arduino IDE下载 www.arduino.cc arduino uno引脚图 Arduino UNO是基于ATmega328P的Arduino开发板。它有14个数字输入&#x2F;输出引脚（其中6个可用于PWM输出）、6个模拟输入引脚，一个16 MHz的晶体振荡器，一个USB接口，一个DC接口，一个ICSP接口，一个复位按钮。它包含了微控制器所需的一切，你只用简单地把它连接到计算机的USB接口，或者使用AC-DC适配器，再或者用电池，就可以驱动它。 存储空间ATmega328 有32KB Flash存储空间（其中0.5KB被用于存储bootloader），2KB 的SRAM和1KB 的EEPROM。可以使用官方提供的EEPROM库读写EEPROM空间。 输入输出Arduino Uno有14个数字输入输出引脚，可使用 pinMode()、digitalWrite() 和 digitalRead() 控制。其中一些带有特殊功能，这些引脚如下 Serial0（RX）、1（TX），被用于接收和发送串口数据。这两个引脚通过连接到ATmega16u2来与计算机进行串口通信。 外部中断2、3，可以输入外部中断信号。中断有四种触发模式：低电平触发、电平改变触发、上升沿触发、下降沿触发。 PWM输出：3、5、6、9、10、11，可用于输出8-bit PWM波。对应函数 analogWrite() 。 SPI：10（SS）、11（MOSI）、12（MISO）、13（SCK），可用于SPI通信。可以使用官方提供的SPI库操纵。 L-LED：13。13号引脚连接了一个LED，当引脚输出高电平时打开LED，当引脚输出低电平时关闭LED。 TWI：A4（SDA）、A5（SCL）和TWI接口，可用于TWI通信，兼容I²C通信。可以使用官方提供的Wire库操纵。 点亮一个LED灯点灯大师，闪亮登场LED灯正负两端会有2v的电压差 pinMode(引脚号，状态) 设置引脚模式 输出(OUTPUT) 输入(INPUT) 输入上拉模式(INPUT_PULLUP) digitalWrite(引脚号,状态); 引脚输出状态 HIGH(高电平) LOW(低电平) 上拉电阻arduino开发板上拉电阻10K 引脚悬空引脚设置成INPUT却没有加任何电路，引脚检测状态不定（0&#x2F;1） 123456789//点亮二号引脚void setup() &#123; pinMode(2,OUTPUT);&#125;void loop() &#123; digitalWrite(2,HIGH);&#125; 串口通信digitalRead(引脚号)读取某个引脚状态，常与pinMode(引脚号,INOUT)搭配使用 Serial.begin(9600);串口初始化设置9600为常用波特率 Serial.println(打印内容);在电脑的串口监视器上输出相应内容 delay(时间)延时函数，单位为ms 12345678910void setup() &#123; pinMode(2,INPUT); Serial.begin(9600);&#125;void loop() &#123; int buttonState = digitalRead(2); Serial.println(buttonState); delay(1);&#125; 模拟输出标有~的数字引脚可输出PWM信号 analogWrite(Pin,bringtness)模拟输出，Pin,引脚号; brigngness为亮度范围0~255,输出的为Pwm信号，PWM信号的频率大约为490Hz.在Arduino UNO控制器中，5号引脚和6号引脚的PWM频率为980Hz。 呼吸灯（周期未测）12345678910111213141516void setup() &#123; Serial.begin(9600);&#125;void loop() &#123;for (int brightness = 0;brightness &lt;= 255;brightness+=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;for (int brightness = 255;brightness &gt;= 0;brightness-=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;&#125; 模拟输入电位器 ananaloRead(Pin)读取范围0-5v,返回0~1023的数值，读入的最大频率为10 000次，引脚悬空状态读的数值不定 变量B &#x3D; map(变量A,A_min,A_max,B_min,B_max)将变量A等比映射到变量B 1234567891011void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; int a = map(analogRead(A0),0,1023,0,255); Serial.println(a); delay(10);&#125; 电机驱动电机种类 直流电机(DC) 交流电机(AC) 交直流两用电机(Universal) 使用arduino的引脚直接驱动直流电机简直蠢爆了，引脚输出电流不够,pwm给小了根本不动，当然，这里只是验证analogWrite是PWM信号，周期490Hz 12345678void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; analogWrite(9,200);&#125; 舵机驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 12345678910111213141516171819202122232425262728293031323334353637383940/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 步进电机驱动步进电机优点 精准控制电机输出轴角度 低速运行时扭矩大 开环控制&#x2F;性价比高 步进电机的分类 单极性步进电机 5-6条引脚，相对输出扭矩低，控制简单 双极性步进电机 4条引脚，相对输出扭矩高，控制复杂 步进电机的参数 额定电流 额定电压 定位转矩 不通电 保持转矩 通电 相数 可独立通电的定子电磁线圈数步进电机详解 http://t.csdnimg.cn/TkxCb","tags":["arduino"]},{"title":"gazebo的学习与应用","path":"/2023/09/26/gazebo的学习与应用/","content":"学习目标与任务 Gazebo和环境模型设计 机器人模型设计 为模型上装备传感器与执行器 https://gazebosim.org/docs","tags":["ros"]},{"title":"基于古月居的ros入门","path":"/2023/09/21/基于古月居的ros入门/","content":"前言由于前段时间的学习总结的习惯不好，决定新开一栏用于ros基础学习。有一说一，通过和学长的进度比较，总感觉自己是个废物。 虚拟机的安装不要装机械盘，运行慢。使用VMwareubantu系统18 linux基本命令行123456789101112cdlsmvrm -rcppwdmkdirtouchshutdown -h nowrebootsudo 基本命令行12sudo apt-get update //更新源source ~/catkin_ws/devel/setup.bash //刷新环境变量 前置安装123456789//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim//ros安装wget http://fishros.com/install -O fishros &amp;&amp; . fishros ros的核心概念节点（node）与节点管理器（ros master）节点名称唯一 话题(topic)与服务(serve) 话题：单向 发布者 订阅者 消息(massage):话题的数据由.msg文件定义 服务：双向 客户端 服务端 .srv文件定义命名请求应答数据 参数(parameter)—全局共享字典适合静态，非二进制的配置参数 文件系统 功能包（package） ：含节点源码，配置文件，数据定义 功能包清单： 作者信息，许可信息，依赖选项 元功能包：组织多个同一目的的功能包 ros命令行工具123456rostopicrosservicerosnoderosparamrosmsgrossrv 小海龟123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 工具123456789rqt_graph //节点可视化rosnode //显示节点rostopic //话题 pubrosmsgrosservice //服务 callrosbag record -a -O cmd_record //话题记录 cmd_record位保存文件名，默认hom目录下rosbag play cmd_record.bag //话题复现 ros的文件结构 1234567891011121314151617181920212223242526272829303132WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 创建工作空间123456789101112131415//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_makecatkin_make install //可要可不要//设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash 问题：我需要在原有的ROS工程基础之上，新建一个ROS功能包。我直接复制了其他目录下原有的一个包，进行修改。然后问题来了：catkin_make后竟然没有反应。甚至没有检测到我新改写的cmake 解决：ros允许多个工作空间使用相同功能包，但多个工作空间source不要放在脚本里，手动敲，否则会被覆盖,在catkin_make之前source一下，之后再source一下。而且要多次执行，如下。注意要先开下roscore，py文件要给其可执行权限. 123456//将文件复制过来后，在工作空间目录下打开终端source ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bash 脚本文件的source只在新的终端开启时才运行 发布者与订阅者以海龟为例 python文件要记得给可执行权限 发布者123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher():\t# ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True)\t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)\t#设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 订阅者123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber():\t# ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True)\t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)\t# 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 消息的自定义定义msg文件在功能包的src同级目录下创建msg文件夹12345678910// 举例，该文件名为Person.msgstring nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 launch文件使用 launch 文件，可以一次性启动多个 ROS 节点launch文件自动启动ROS Master 123456789101112131415161718192021&lt;!-- 包名 节点名称 自定义节点名 --&gt;&lt;!-- 注释 --&gt;&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt; &lt;!-- 参数设置 --&gt; &lt;param name=&quot;output_feame&quot; value=&quot;odom&quot;/&gt; &lt;!-- name:参数名称，value 参数值 --&gt; &lt;rosparam= file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!-- 重映射remap --&gt; &lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt; &lt;!-- from:原名 to:映射后的名字 --&gt; &lt;!-- 嵌套include --&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 客户端与服务端客户端 rosservice call &#x2F;clear “{}” 参数的使用parameter Server 全局变量存储空间 123456789101112// 列出当前有多个参数rosparam list// 显示某个参数值rosparam get param_key// 设置某个参数值rosparam set param_key param_value//保存参数到文件rosparam dump file_name// 从文件读取参数rosparam load file_anme// 删除参数rosparam delete param_key yaml 参数文件在程序里实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config():\t# ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True)\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;);\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() TF坐标管理系统tf功能包，默认10秒 实现机制 广播TF变换 监听TF变换12345678//安装功能包sudo apt-get install ros-melodic-turtle-tf//启动节点roslaunch turtle tfturtle tf demo.launch//turtles键盘控制节点rosrun turtlesim turtle teleop_key//保存tf tree为 pdf 至当前目录rosrun tf view frames tf工具 命令行工具rosrun tf tf_echo turtle1 turtle2 可视化工具 rosrun rviz rviz -d rospack find turtle tf &#x2F;rviz&#x2F;turtle rviz.rviz tf坐标的广播与监听单词释义quaternion 四元数radian 弧度degree 角度 常用可视化工具QT工具箱 日志输出rqt_console 计算图ret_graph 数据绘图rqt_plot 图像渲染rqt_image_view rviz gazebo 进阶 控制与仿真 gazebo + ros +ros_control","tags":["ros"]},{"title":"stc驱动TM1608","path":"/2023/09/16/stc驱动TM1608/","content":"tm1638.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef _TM1638_H#define _TM1638_H#include &lt;STC32G.H&gt;//TM1638模块引脚定义sbit DIO=P1^3; //数据线sbit CLK=P1^0; //时钟线sbit STB=P1^1; //片选线//共阴数码管显示代码unsigned char code dis[11]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x00&#125;; unsigned char while_one[8]=&#123;0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce&#125;;void TM1638_Write(unsigned char Data) //写数据函数&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; CLK=0; DIO=Data&amp;0x01; Data&gt;&gt;=1; CLK=1;\t&#125;&#125;void Write_Command(unsigned char Command) //发送命令&#123;\tSTB=0;\tTM1638_Write(Command);\tSTB=1;&#125;void Write_Data(unsigned char add,unsigned char Data) //指定地址写入数据&#123;\tSTB=0;\tTM1638_Write(0x00|add);\tTM1638_Write(Data);\tSTB=1;&#125;//TM1638初始化函数void init_TM1638(void)&#123;\tunsigned char i;\tWrite_Command(0x8F); Write_Command(0x40); //采用地址自动加1\tSTB=0; TM1638_Write(0xc0); //设置起始地址\tfor(i=0;i&lt;16;i++) //传送16个字节的数据 TM1638_Write(0x00);\tSTB=1;&#125;#endif tm1638.c 123456789101112131415161718192021#include &lt;STC32G.H&gt;#include &quot;tm1638.h&quot;void TMmain(void)&#123; unsigned char i;\tP0=0xff;P2=0x80;P2&amp;=0x1f; P0=0;P2=0xa0;P2&amp;=0x1f; //关闭单片机LED、蜂鸣器、继电器，主要是刺眼。。。 init_TM1638(); //初始化TM1638\tfor(i=0;i&lt;8;i++)\tWrite_Data(i,dis[10]); //初始化寄存器\twhile(1)\t&#123; Write_Data(while_one[0],dis[6]); //选中GRID1，令第一位数码管显示0\t&#125;&#125;","tags":["单片机"]},{"title":"stc32学习","path":"/2023/09/14/stc32学习/","content":"时隔三月，再摸单片机，这一次我要把遗忘的全部拿回来 STC32介绍 STC I&#x2F;O口工作模式 除了P3.0和P3.1（准双向口）外，其他默认高阻输入模式准双向口和推挽输出模式默认为高电平 define和typedef12typedf unsigned char u8;给已存在的数据类型起别名 WTST程序读取等待控制寄存器，上电默认为70-255 volatile设置变量，防止优化 预编译处理12345678910//主要命令有#include#ifndef //如果宏未定义则执行#define //定义宏#endif //结束有if的定义#elif#undef // 取消已定义的宏#line#program#error 模块化编程思想 移位法点亮LED 1234567while(1)&#123; for(i = 0;i &lt; 8; i++) &#123; P2 = ~(0x01 &lt;&lt; i); delayms(500); &#125;&#125; 上拉电阻和下拉电阻所有IO口都配置了一个4.1K的上拉电阻和10K的下拉电阻都是8位寄存器上拉电阻控制寄存器：PxPU上拉电阻控制寄存器：PxPD(x &#x3D;0,1,2,3,4,5,6,7) 123456789P7M1 = 0xFF;P7M0 = 0x00; //高阻输入模式EAXFR = 1; //使能XFR,特殊寄存器，设置使之能访问while(1)&#123; P7PU = 0x01; //加上拉电阻等于准双向口模式 delayms(1000); P&amp;PD = 0x00; delayms(1000);&#125; 自适应delayms()函数12345678#define MAIN_Fose = 35000000 //设置主频void delayms(int ms)&#123; int i; do&#123; i = MAIN_Fose/6000; while(i--); &#125;while(--ms);&#125; 特殊功能寄存器（SFR，XFR） 地址范围0x7E0000-0x7EFFF如需访问扩展寄存器，需先设置SFR使能寄存器CKCON 外部数据总线时钟控制寄存器CKCON &#x3D; 0x00;(上电默认为7，建议设为0) 74HC595独立按键定时器与计数器5个24位定时器&#x2F;计数器（八位预分频+16位计数）","tags":["单片机"]},{"title":"python study","path":"/2023/08/10/python-study/","content":"python规范 结尾空一行 导入库空两行 注释# 空一格 Python库的安装1pip install 库名 Python的导包方式12345678910111213# 1.import 常规导入，直接导入整个包的所有的功能函数##eg# 2.import多个导入，导入多个包的所有功能函数。##eg# 3.from … import …导入整个包的部分功能函数。##eg# 4.当然也可以通过from … import * 这个也是直接导入包的所有功能。相当于import … 重要的，在实际的应用中用得也是比较多的，我们自定义我们自己写的功能包。第一：在test_package文件夹中创建_init_.py文件，里边什么都不需要编辑。第二：在代码中把test_package的文件的路径加入到python解释器可以搜索到的路径列表中，这里就用到了python的包sys模块。下边是运行过一次的目录结构：pyc文件是py文件编译后生成的字节码文件，不需要自己创建，在你第一次成功导入包并运行成功之后会自动生成。 自定义导包 https://blog.csdn.net/weixin_45577864/article/details/121714956?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-121714956.nonecase&amp;spm=1018.2226.3001.4187","tags":["python"]},{"title":"links","path":"/2023/07/30/links/","content":"图标 介绍 网址 triority’s blog https://triority.cn/ 天鹅绒房间 https://qwqpap.xyz/ 北矿3D打印社 https://cumtb.club/"},{"title":"arduino小项目2——电压表","path":"/2023/07/30/arduino小项目2——电压表/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕，小按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V; void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; float a = Voltage_detect(); displayMenu(a);&#125; //oled屏幕显示void displayMenu(float a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); u8g2.print(&quot;Voltage, (0-5v)&quot;); // 显示电压表... u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.setCursor(20, 34); u8g2.println(a); u8g2.sendBuffer();&#125; //检测并转化为0-5vfloat Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); //读取io口模拟值 float Voltage = analogdate*5.0/1023.0; //转化 //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); //串口打印 &#125; else Serial.println(Voltage); return Voltage; //返回值&#125; 本来想弄万用表来着，emmp,放弃了,没写完，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int gear = 0; // 万用表状态 0.菜单；1.电压表；2.电流表；3.电阻表int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V;int R_I=220; // 电流表状态，电阻为220欧姆 void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; double a = Voltage_detect(); switch1(); displayMenu(a); int analogdate = analogRead(A0); &#125; void switch1() &#123; int key = digitalRead(2); // 第一次判断 if (key == 0) &#123; // 延时20ms 消除按键抖动 delay(20); // 第二次判断 if (key == 0) &#123; gear++; // 状态++ if (gear &gt; 3) &#123; gear = 0; // 循环到第一个菜单状态 &#125; &#125; // 等待按键被松开 while (!digitalRead(2)) &#123; // 等待按键松开 &#125; &#125;&#125; void displayMenu(double a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); switch (gear) &#123; case 0: //u8g2.print(&quot;Menu&quot;); // 显示菜单选项... face(); break; case 1: u8g2.print(&quot;Voltage&quot;); // 显示电压表... u8g2.setCursor(20, 34); u8g2.println(a); break; case 2: u8g2.print(&quot;Current&quot;); // 显示电流表... break; case 3: u8g2.print(&quot;Resistance&quot;); // 显示电阻表... break; &#125; u8g2.sendBuffer();&#125; void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; float Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); float Voltage = analogdate*5.0/1023.0; //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); &#125; else Serial.println(Voltage); return Voltage;&#125;","tags":["arduino"]},{"title":"arduino小项目1——小时钟","path":"/2023/07/30/arduino小项目1——小时钟/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕 接线图，文字描述。单片机上的A4接小屏幕上的SDA，A5接SCL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;MsTimer2.h&gt;#include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int year = 2020, month = 1, day = 1, hour = 0, minute = 0, second = 0; void onTimer() &#123; second++; if (second &gt;= 60) &#123; second = 0; minute++; if (minute &gt;= 60) &#123; minute = 0; hour++; if (hour &gt;= 24) &#123; hour = 0; &#125; &#125; &#125;&#125; void setup() &#123; Serial.begin(9600); u8g2.begin(); u8g2.clearBuffer(); MsTimer2::set(1000, onTimer); // 中断时间为1秒 MsTimer2::start(); // 启动定时器&#125; void loop() &#123; displayTime();&#125; void displayTime() &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.drawStr(0, 15, &quot;TIME:&quot;); u8g2.setFont(u8g2_font_ncenB12_tr); char strTemp[12]; sprintf(strTemp, &quot; %d.%.2d.%.2d&quot;, year, month, day); u8g2.drawStr(35, 15, strTemp); u8g2.setFont(u8g2_font_ncenB14_tr); sprintf(strTemp, &quot;%.2d.%.2d.%.2d&quot;, hour, minute, second); u8g2.drawStr(25, 45, strTemp); u8g2.sendBuffer();&#125;","tags":["arduino"]},{"title":"markdown基本介绍与语法","path":"/2023/07/26/markdown基本介绍与语法/","content":"markdown是什么？Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等 我为什么使用markdown写个人博客需要，且markdown使用简单，b站搜索十分钟学会，word无法完成个人博客的书写.markdown和word可相互转化,但效果不好，排版问题较大。markdown无法实现精细排版要求。 在线编译器网址https://markdown.com.cn/editor/在线转化器网址https://www.easeconvert.com/markdown-to-word/ 基本语法12345678910111213141516171819202122232425262728293031323334353637383940——————标题——————# 一级标题## 二级标题### 三级标题...###### 六级标题——————字体———————**这个是粗体***这个是斜体****这个是粗体加斜体***~~这里想用删除线~~--- 分割线——————列表———————无序列表的使用，在符号`-`后加空格使用有序列表的使用，在数字及符号`.`后加空格后输入内容——————图片———————使用符号&gt;&gt; 引用内容——————表格———————可以使用冒号来定义表格的对齐方式，如下：| 姓名 | 年龄 | 工作 || :----- | :--: | -------: || 小可爱 | 18 | 吃可爱多 || 小小勇敢 | 20 | 爬棵勇敢树 || 小小小机智 | 22 | 看一本机智书 |——————链接———————[描述](链接)——————图片———————&#123;% image 链接 %&#125;——————代码———————```语言代码块``` (占位，不管) 笔记over","tags":["markdown"]},{"title":"ros车基本学习（基于讯飞车）","path":"/2023/07/24/ros车基本学习/","content":"ros是什么（个人理解）ros是个机器人操作系统，可以在上面实现对机器人的操作，好比一个工作台，别人给你造好，直接使用上面的工具方便造自己的作品. 我为什么学ROS竞赛需要,智能车讯飞比赛及人工智能比赛甚至电赛控制类赛题也能用到 节系统是乌班图18的系统。 123456//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim 代码运行实例（c++） 123456789101112//终端输入，在主目录下创造一个test的文件夹。mkdir test//创建一个名为hello的点cpp文件。touch hello.cpp//在文件中写入内容//写完后保存关闭//打开终端输入,编译C加加文件g++ hello.cpp -o hello//执行可执行文件。./hello//同理。执行python文件python hello.py ros安装 1234567891011121314151617181920//添加ros软件源sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; //添加密匙sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 //安装rossudo apt updatesudo apt install ros-melodic-desktop-full //初始化rosdepsudo rosdep initrosdep update //设置环境变量echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc //安装rosinstallsudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 鱼香ros一键安装 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 小乌龟实例 123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 创建工作空间 1234567891011121314//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_make //设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译 12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs geometry_msgs turtlesim //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash C++编译配置&lt;cmakelists.txt&gt;12add_executable($&#123;PROJECT_NAME&#125;_node src/my_package_name_node.cpp)target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;)自定义消息1.在功能包文件夹内创建msg文件夹，并新建Person.msg文件，在里面写入 1234567string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 2.在package.xml文件内添加依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.在CMakeLists.txt内加入： 123456789 add_message_files( FILES Person.msg) generate_messages( DEPENDENCIES std_msgs)并把1# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim改为1CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime系统关机及重启 1234//关机shutdown -h now//重启sudo reboot ctrl all+T打开新的终端 摄像头参数命令1qv4l2 launch文件启动rviz每次启动rviz都要设置订阅的话题、点云大小等等机械化的设置，为了方便快捷的操作，把rviz的设置写入launch文件内，就可以一键启动了。1.先启动需要运行的节点，再启动一个rviz；2.设置好订阅的话题、点云大小、坐标轴等需要用到的设置3.点击左上角的file，选择另存为到一个指定地址(功能包文件夹下创建config文件夹，rviz配置文件放里面)；4、写入launch文件 1234&lt;launch&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find my_package)/config/path_to_your_rviz_config_file.rviz&quot; /&gt;&lt;/launch&gt; 其中 find my_package 为你的功能包名，path_to_your_rviz_config_file.rviz为rviz文件名","tags":["ros"]},{"title":"我的技术栈","path":"/2023/07/24/我的技术栈/","content":"我的技术栈语言类： c++&#x2F;c python不懂算法，C的指针操作忘了，会基础的代码编写，小车雷达找板子，键盘控制小车移动，上下位机通信 软件类： ros基本框架及实际ROS小车搭建 51单片机 stc32单片机 arduino单片机 linux基础&#x2F;驱动开发 eps32 stm32(未学) 网络基础 树莓派 opencv 神经网络 通讯协议 硬件类： solidwords&#x2F;3d打印 四层板以下pcblayout设计 非BGA封装，0402的元件等电路板焊接 通信协议（硬件类） 贴片机的了解与使用，及garber文件的操作，CAM350的使用 轮式车运动学"},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的个人博客联系邮箱：&#x33;&#x33;&#x31;&#49;&#x37;&#48;&#x34;&#x35;&#x30;&#x39;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d; 姓名：李无忧爱好：睡觉和吃饭以及听音乐性格：温和喜静理想：实现共产主义，追求社会公平讨厌的事：被他人意志所裹挟擅长的事：模仿与学习 为什么写博客？ 主要原因有二个方面吧，首先呢，记录学习状态。学习的时候很多代码确实很难记住，知道怎么用就好了，必要的时候翻翻个人博客就可以找到。然后吧，记录生活日常。当然这个可能比较少。 我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32 stm32 网络基础 树莓派 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"成就","path":"/achievement/index.html","content":"学科竞赛 第十七届智能车室外组ROS 省二（首座） 第十八届智能车室外组ROS 国一（首座） 第十八届智能车讯飞创意组 国一 第二十五届中国机器人及人工智能大赛智能驾驶 国二（首座） 2023全国大学生电子设计大赛 省三 第二十六届中国机器人及人工智能大赛智能驾驶 国一 第二十六届中国机器人及人工智能大赛百度星火 国一 第十九届智能车讯飞创意组 国二 学校奖励 2023年校级三等奖学金 学院新生辩论赛一等奖 优秀团员"}]