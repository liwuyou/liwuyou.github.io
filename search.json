[{"title":"复变函数与积分变换","path":"/2023/12/15/复变函数与积分变换/","content":"马上就要考试了，悲 复数与复变函数复数的三种形式 复数的一般形式 $Z&#x3D;x+yi$ 复数的三角表示 $Z&#x3D;r(\\cos\\theta+j\\sin\\theta)$ 复数的指数形式 $Z&#x3D;re^{i\\theta}$ 复数的主值与辐值$$ArgZ &#x3D; argZ + 2k\\pi$$其中 $0 \\leq argZ&lt;2\\pi$ 主值的求解公式 棣莫弗公式 ★$$Z^n&#x3D;[r(\\cos\\theta+i\\sin\\theta)]^n&#x3D;r^n(\\cos{n\\theta}+\\sin{n\\theta})&#x3D;re^{in\\theta}$$当r&#x3D;1时，有$$(\\cos\\theta+i\\sin\\theta)^n&#x3D;\\cos{n\\theta}+\\sin{n\\theta}$$逆运用$$w&#x3D;r^{\\frac{1}{n}}[\\cos(\\frac{1}{n}(\\theta+2k\\pi))+i\\sin(\\frac{1}{n}(\\theta+2k\\pi))]$$ 其中$k&#x3D;0,1,2,…,n-1$$r&#x3D;|Z|$ 练习共轭复数$ReZ&#x3D;\\frac{Z+\\overline{Z}}{2}$$ImZ&#x3D;\\frac{Z-\\overline{Z}}{2i}$ 解析函数解析函数：概念性质、充分&#x2F;必要条件、调和函数、初等函数 解析概念：$w&#x3D;f(Z)$如果在$Z_{0}$及其领域内处处可导，则$f(Z)$在$Z_{0}$处解析解析-&gt;可导-&gt;连续反之不行 函数解析的充要条件（柯西-黎曼方程）C-R方程$f(z)&#x3D;u(x,y)+iv(x,y)$在$z&#x3D;x+iy$处处可导的充要条件是$u(x,y)$，$v(x,y)$在点$(x,y)$处可微$$\\frac{\\partial u}{\\partial x}&#x3D;\\frac{\\partial v}{\\partial y}且\\frac{\\partial u}{\\partial y}&#x3D;-\\frac{\\partial v}{\\partial x}$$ 调和函数调和函数和解析函数针对的对象不同解析函数针对$f(Z)$调和函数针对$u(x,y)与v(x,y)$ 拉普拉斯方程（Laplace）$$\\frac{\\partial^{2} \\varphi}{\\partial^{2}x}+ \\frac{\\partial^{2} \\varphi}{\\partial^{2}y}&#x3D;0$$解析函数的实部和虚部是调和函数 初等函数指数函数$$e^{Z}&#x3D;e^{x+iy}&#x3D;e^{x}(\\cos x +i\\sin y)$$指数函数性质有： $ |e^{Z}|&#x3D;e^{x}$ $Arg(e^{Z})&#x3D;y+2k\\pi$ $e^{Z+i2k\\pi}&#x3D;e^{Z}，即e^{Z}是以2k\\pi 为周期的周期函数$ $(e^{Z})’&#x3D;e^{Z}$ 对数函数$LnZ&#x3D;lnZ+i2k\\pi&#x3D;ln|Z|+iargZ+i2k\\pi$ 幂函数$a^{b}&#x3D;e^{(Lna)b}$ 三角函数 反三角函数 练习复变函数的积分定义及如何积分定义在简单光滑或分段光滑上的有向曲线上的积分$$f(Z)&#x3D;u(x,y)+iv(x,y)$$$$f_{c}(Z)dZ$$如何积分？两种方法 第二型曲线积分$$\\int_{c}(Z)dZ&#x3D;\\int_{c}u(x,y)+iv(x,y)dZ&#x3D;\\int_{c}udx-vdy+i\\int_{c}vdx+udy$$ 参数法$$\\int_{c}(Z)dZ&#x3D;\\int^{\\beta}_{\\alpha}f(Z(t))Z’(t)dt$$ 柯西-古萨定理$$\\oint_{c}f(Z)dZ&#x3D;0$$$f(Z)$在C上及D内解析则成立 复合闭路定理推导$f(Z)$在$\\Gamma$上解析，且$\\Gamma&#x3D;C+C^{-}{1}+C^{-}{2}$+…，则$\\oint_{\\Gamma}f(Z)dZ&#x3D;0$，代入$\\Gamma &#x3D;C+C^{-}{1}+C^{-}{2}$+…则$\\oint_{C+C^{-}{1}+C^{-}{2}+…}f(Z)dZ&#x3D;0$ 化简移项可得 $$\\oint_{c}f(Z)dZ&#x3D; \\sum_{n&#x3D;1}^n\\oint_{C_{k}}f(Z)dZ$$当k&#x3D;1时，则得 $$\\oint_{c}f(Z)dZ&#x3D; \\oint_{k}f(Z)dZ$$ 柯西积分公式 ★适用条件：$f(Z)$要在C上及其内部解析$$\\oint_{c}\\frac{f(Z)}{Z-Z_{0}}dZ&#x3D; 2\\pi if(Z_{0})$$高阶$$\\oint_{c}\\frac{f(Z)}{(Z-Z_{0})^{n-1}}dZ&#x3D; \\frac{2\\pi i}{n!} f(Z_{0})$$ 级数(研究其敛散性)级数的一些性质$\\sum_{n&#x3D;1}^n|Z|$收敛，则$\\sum_{n&#x3D;1}^nZ$也收敛 $\\sum_{n&#x3D;1}^n\\frac{1}{n}$是发散的 复数序列$Z_{1}&#x3D;a_{1}+b_{1}i$，$Z_{2}&#x3D;a_{2}+b_{2}i$，…$Z_{n}&#x3D;a_{n}+b_{n}i$，…上面的序列，简记为$${Z_{n}}$$ 项级数如何判断一个项级数是收敛还是发散的呢？部分和判断部分和为$$S_{n}&#x3D;Z_{1}+Z_{2}+…Z_{n}$$部分和序列$${S_{n}}&#x3D;S_{1}+S_{2}+…S_{n}$$ 幂级数 ★形式和收敛半径要记住，收敛半径的求法，比值法和根值法。其级数在其收敛半径内部绝对收敛，在其收敛半径上不一定。 幂级数和函数性质2的应用 幂级数的运算（加减乘除）对应题型，将函数展开为Z的幂级数（不熟练） 泰勒级数常见泰勒展开","tags":["课程"]},{"title":"爬虫入门","path":"/2023/12/14/爬虫入门/","content":"爬虫简介爬虫的概念通过编写程序，模拟浏览器上网，然后让其抓取数据的过程 爬虫分类 通用爬虫（整张页面） 聚焦爬虫（局部内容） 增量式爬虫（抓取更新内容） 爬虫的矛与盾 爬虫 反爬机制 反反爬策略 robots.txt协议君子协议，规定可爬取，不可爬取网址后面加&#x2F;robots.txt 即可访问 http协议 概念：服务器与客户端进行数据交互的一种形式 常用请求头信息 User-Agent:请求载体的身份标识 Connection:请求完毕后，是断开连接还是保持连接 常用响应头信息 Content-Type: 服务器响应回客户端的数据类型 https协议:安全的超文本传输协议 加密方式 对称秘钥加密 非对称秘钥加密 证书秘钥加密 requests请求requests模块: python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 作用:模拟浏览器发请求。 如何使用: (requests模块的编码流程) 指定urT 发起请求 获取响应数据 持久化存储环境安装:pip install requests 实战编码:需求: 爬取搜狗首页的页面数据1234567891011121314import requestsif __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/&#x27; # 发起请求 response = requests.get(url=url) # 获取响应数据,text返回的是字符串 page_text = response.text print(page_text) # 持久化存储 with open(&quot;./sogou.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://blog.csdn.net/m0_46778548/article/details/121201868Python文件读写操作 https://blog.csdn.net/qiqicos/article/details/79200089python 里with… as.. 的操作方法 需求: 爬取搜狗指定头条学习点UA伪装 123456789101112131415161718192021222324252627import requests#UA:User-Agent.(请求载体的身份标识)# UA检测门户网站的服务器会检测对应请求的载体身份标识,不正常则服务器端就很有可能拒绝该次请求# UA伪装if __name__ == &quot;__main__&quot;: # 指定URL url = &#x27;https://www.sogou.com/web&#x27; # UA伪装:将对应的User-Agent封装到一个完典中 headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0&#x27;&#125; # 处理参数并字典封装 ws = input(&quot;Please enter a word:&quot;) param = &#123;&#x27;query&#x27;: ws&#125; # 对指定的url发起的请求对应的urL是携带参数的，并且请求过程中处理了参数 response = requests.get(url=url, params=param, headers=headers) # 持久化存储 page_text = response.text print(page_text) with open(&quot;./&quot;+ws+&quot;.html&quot;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(&quot;爬取数据结束&quot;) https://www.runoob.com/python3/python-requests.htmlrequest模块详解","tags":["python"]},{"title":"基于树莓派上位机与arduino下位机实现键盘控制","path":"/2023/12/14/基于树莓派上位机与arduino下位机实现键盘控制/","content":"实现键盘控制小车行驶 下位机代码，Arduino的5号引脚为电机引脚，9号引脚为舵机引脚 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;Servo.h&gt; Servo myservo;String str;int pos = 92; //舵机角度int motor_pwm = 100; //电机数值0 ~255int pos_mid = 92; // 储存舵机中值角度int motorPin = 5; // 确定motor控制引脚int servoPin = 9; //确定servo控制引脚 void setup() &#123; Serial.begin(115200); myservo.attach(servoPin); // 该舵机由arduino第9脚控制 pinMode(motorPin, OUTPUT); // 将电机引脚设为输出模式 myservo.write(pos_mid); // 舵机复位 analogWrite(motorPin,0); // 电机初始转动 delay(1000);&#125; void loop() &#123; if (Serial.available() &gt;= 2) &#123; int servoValue = Serial.read(); int motorValue = Serial.read(); // 控制舵机 myservo.write(servoValue); if (servoValue &lt;40) servoValue=40; else if(servoValue &gt; 140) servoValue=140; Serial.print(&quot;servo: &quot;); Serial.println(servoValue); // 控制电机 if (motorValue &lt;0) motorValue=0; else if(motorValue &gt; 255) motorValue=255; analogWrite(motorPin, motorValue); Serial.print(&quot;motor: &quot;); Serial.println(motorValue); &#125; &#125; 上位机代码文件名 key_control.py 123456789101112131415161718192021222324252627282930313233343536373839404142# Author: 无忧# Date: 2023-12-02# Description: 这是一个键盘控制的简单代码# 请调节键盘状态为英语小写状态# -------------------- import keyboardimport time# 要下包keyboardfrom send_M_S import * speed = 0speed_max = 60 # 速度的最大值turn = 92 # 舵机中值turn_l = 60 # 舵机打角最左turn_r = 120 # 舵机打角最右 if __name__ == &quot;__main__&quot;: ser = init_send() while True: try: if keyboard.is_pressed(&#x27;w&#x27;): speed += 5 if speed &gt;= speed_max: speed = speed_max elif keyboard.is_pressed(&#x27;a&#x27;): turn -= 8 if turn &lt;= turn_l: turn = turn_l elif keyboard.is_pressed(&#x27;d&#x27;): turn += 8 if turn &gt;= turn_r: turn = turn_r elif keyboard.is_pressed(&#x27;s&#x27;): speed -= 5 if speed &lt;= 0: speed = 0 time.sleep(0.1) # 系统响应速度 send_values(ser, turn, speed) except KeyboardInterrupt: break 上位机串口代码文件名send_M_S 123456789101112131415161718192021222324252627282930313233# Author:# Date: 2023-12-02# Description: This script does XYZ.import serialimport timeimport sys # 设置串口参数def init_send(): ser = serial.Serial(&#x27;COM4&#x27;, 115200, timeout=1) return ser def send_values(ser, servo_value, motor_value): # 向串口发送舵机值和电机值 time.sleep(0.1) ser.write(bytes([servo_value, motor_value])) while ser.in_waiting: arduino_feedback = ser.readline().decode() print(&quot;Arduino:&quot;, arduino_feedback) if __name__ == &#x27;__main__&#x27;: # 初始化串口 ser = init_send() try: while True: for i in range(60, 120, 1): send_values(ser, i, 50) for i in range(120, 60, -1): send_values(ser, i, 50) except KeyboardInterrupt: # 在用户按下 Ctrl+C 时，关闭串口并退出程序 ser.close() sys.exit()","tags":["arduino"]},{"title":"电路复习","path":"/2023/11/14/电路复习/","content":"写在前面的话我打算尝试一下，用markdown，部署到网页进行电路的学习与记录困难点来自两1.多图片，图床问题2.多数学公式 这是一次有意义的探索，一次尝试 电路的简化电压源串联电流源并联电压源与电流源的串联相当与电流源 电压源与电流源的并联相当与电压源 电流源的内阻为无穷大 电压源与电流源的转化$\\Delta$与Y的等效变换$\\Delta$ -&gt; Y $$Y型电阻 &#x3D; \\frac{\\Delta相邻电阻乘积}{\\Delta电阻之和}$$Y -&gt; $\\Delta$$$\\Delta型电阻 &#x3D; \\frac{Y型电阻两两乘积之和}{Y型不相邻电阻}$$相同阻值情况下，3Y&#x3D;$\\Delta$ 电源置零独立电压源短路，独立电流源断路 独立源与受控源受控源 vcvc 电压控制的电压源 vccs 电压控制的电流源 ccvs 电流控制的电压源 cccs 电流控制的电流源 voltage 电压 current 电流 control控制 source源 输入电阻无源一端口网络的等效变换，无源指的是无独立电源简而言之，一个不含独立源的一端口网路，等效为一个电阻$R_{eq}$输入电阻求法 外加电源法 建议外加电压源$$R_{eq} &#x3D; \\frac{u}{i}$$注意，在存在受控源的情况下，R可能为负。 【大学电路习题讲解——求输入电阻1】 【精准空降到 00:19】 https://www.bilibili.com/video/BV1z7411W72Z/?share_source=copy_web&amp;vd_source=bae7f44ac8b5e1669726b9f5e7d214b6&amp;t=19 三种电流方法基本概念 结点(n) 支路(b) 网孔 网孔数&#x3D;独立回路数 支路电流法（基本用不到） 找出支路数(b)，找出结点数(n) 列n-1个KCL方程 列b-n+1个KVL方程 联立求解 回路电流法 找出b-n+1个回路 列方程求解 $$R_{11}i_{1}+R_{12}i_{2}+… &#x3D; u_{11}$$$$R_{21}i_{1}+R_{22}i_{2}+… &#x3D; u_{22}$$$$R_{31}i_{1}+R_{32}i_{2}+… &#x3D; u_{22}$$$$……$$$$R_{n1}i_{1}+R_{n2}i_{2}+… &#x3D; u_{22}$$ 其中，$R_{11}$…$R_{nn}$为回路n的电阻之和$R_{21}$&#x3D;$R_{12}$为回路1，2共有的电阻(方向相同则为正)$u_{11}$回路1所有电压源之和，指定电流由“+” -&gt; “—”取负，反之 结点电压 找出所有结点，选取待测相关的一个结点为0，其他分别为1，2，… 将与电流源串联的电阻变导线，与电压源并联的电阻变短路 列方程求解$$G_{11}u_{n1}+G_{12}u_{n2}+… &#x3D; i_{s11}$$$$G_{21}u_{n1}+G_{22}u_{n2}+… &#x3D; i_{s22}$$$$G_{31}u_{n1}+G_{32}u_{n2}+… &#x3D; i_{s33}$$ 其中，$i_{s11}$&#x3D;$\\frac{电压源}{所在支路电阻}+电流源$，流入结点为正，流出为负 例题精讲（待补充）电路原理叠加定理 https://www.bilibili.com/video/BV1HF411W7L9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=755a0f899976f771c7923daed9448d48 表述：在线性电阻电路中，某处电压或电流都是各个独立电源单独作用时，电压与电流的叠加 注意： 某电源作用时，其他独立源置零 受控源不置零 线性电路 可设置0电压的点，即接地 替换定理简述：任何一个支路（端口）已知电压或电流，就可以将该支路（端口）用电压源或电流源替代。既可以线性电路，也可以非线性 适用条件及其注意点不要把受控源的控制量替换掉 戴维南定理（等效电压源定理）简述：将一个二端网路，等效为一个电压源串联一个等效电阻。注意开路，开路！！步骤： 剥离待求项，将原电路化为开路二端网络，求U, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电压源串联一个等效电阻 诺顿定理（等效电流源定理）简述：将一个二端网路，等效为一个电流源并联一个等效电阻。 剥离待求项，将原电路d待求项短接，求I, (kVL) 电源置零，求输入电阻，求外加电压法，$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$ 结合为电流源并联一个等效电阻 戴维宁求谁断路谁，诺顿求谁断路谁，然后电源置零，用外加电压法$R_{eq} &#x3D; \\frac{ U_{s}}{I_{s}}$，求输入电阻 储能元件电容（电流记忆元件）VCR为$$i &#x3D; C\\frac{ d_{u}}{d_{t}}$$ 电感（电压记忆元件）VCR为$$u&#x3D; L\\frac{ d_{i}}{d_{t}}$$ 电容与电感的串并联电容的串并联与电阻相反电感的串并联与电阻类似 RC电路与RL电路的响应$$U_{c}&#x3D;U_{c}(\\infty)+[U_{c}(0_{+})-U_{c}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;RC)$$1.电容断路，求$U_{c}(\\infty)$和$U_{c}(0_{+})$，求变化前后稳定时的电压。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电容断路，求输入电阻3.代入求解 $$I_{L}&#x3D;I_{L}(\\infty)+[I_{L}(0_{+})-I_{L}(\\infty)]e^{-\\frac{t-t_{0}}{\\tau}}(\\tau&#x3D;R&#x2F;L)$$1.电感短路路，求$I_{L}(\\infty)$和$I_{L}(0_{+})$，求变化前后稳定时的电流。2.$t_{0}$为开始突变的时间2.变化后，电源置零，电感断路，求输入电阻3.代入求解 补充$$U(t)&#x3D;U(t_{0})+\\frac{1}{C}\\int_{t_{0}}^tI_{t}d\\xi$$$$I(t)&#x3D;I(t_{0})+\\frac{1}{L}\\int_{t_{0}}^tu_{t}d\\xi$$ 一阶电路与二阶电路的时域分析零输入响应（无电源）零状态响应（未充能）全响应（有电源且电容已充能）向量法复数的三种形式$$F&#x3D;|F|(\\cos\\theta+j\\sin\\theta)&#x3D;a+jb$$$$F&#x3D;|F|e^{j\\theta}$$$$F&#x3D;|F|\\angle\\theta$$ 欧拉公式$$e^{j\\theta}&#x3D;(\\cos\\theta+j\\sin\\theta)$$$$e^{j\\pi}+1&#x3D;0$$ 正弦量$$u&#x3D;U_{max}\\cos(wt+\\psi)&#x3D;\\sqrt{2}V\\cos(wt+\\psi)&#x3D;V\\angle\\theta$$注意，向量法表述时为有效值 https://zhuanlan.zhihu.com/p/110148728 电路定理的向量形式基尔霍夫定律$$\\Sigma i(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{I}(t)&#x3D;0$$$$\\Sigma u(t)&#x3D;0 \\rightleftarrows \\Sigma \\dot{U}(t)&#x3D;0$$ 电路元件的向量关系$$u&#x3D;Ri \\rightleftarrows \\dot{U}&#x3D;R\\dot{I}$$$$u&#x3D; L\\frac{ d_{i}}{d_{t}} \\rightleftarrows \\dot{U}&#x3D;jwL\\dot{I}$$$$u&#x3D;\\frac{1}{C}\\int idt \\rightleftarrows \\dot{U}&#x3D;\\frac{1}{jwC}\\dot{I}&#x3D;-j\\frac{1}{wC}\\dot{I}$$","tags":["课程"]},{"title":"numpy库的学习","path":"/2023/10/24/numpy库的学习/","content":"参考资料 https://www.runoob.com/numpy/numpy-tutorial.html 线性代数基础概念理解线性代数的概念忘了，这里补一补 https://zhuanlan.zhihu.com/p/422251943 numpyNumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C&#x2F;C++&#x2F;Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能","tags":["python"]},{"title":"python的os库的使用","path":"/2023/10/22/python的os库的使用/","content":"参考资料 https://blog.csdn.net/m0_55697123/article/details/119464001 https://blog.csdn.net/wulishinian/article/details/106420532 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport time# print(os.system(&#x27;C:\\\\Windows\\\\System32\\\\calc.exe&#x27;))print(os.name) # linux 显示posixprint(os.environ) # 环境变量# windows \\ , linux /# 常用系统相关变量，sep分隔符print(os.sep)print(os.pathsep)print(os.linesep)# 文件和目录操作# os.mkdir(&quot;test&quot;) # 在当前路径下创建目录# os.rmdir(&quot;test&quot;) # delete目录# os.remove(&quot;文件名&quot;) #delete文件print(os.getcwd()) # 打印当前目录# os的子模块 os.pathfile = os.getcwd()+&quot;/main.py&quot;print(os.path.split(file)) # 分割文件名和路径mkdir, filename = os.path.split(file)print(filename)# 判断绝对路径与相对路径print(os.path.isabs(file)) # 是绝对，则返回TRUE# 判断文件或目录是否存在print(os.path.exists(file))# 拿到目录或文件最后修改时间，开始创建时间print(os.path.getatime(file)) # 显示时间戳print(os.path.getctime(file)) #print(os.path.getsize(file)) # 拿到文件大小,字节# 执行命令# os system popen 不推荐使用 执行结果 1234567891011121314151617181920ntenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming&#x27;, &#x27;COMMONPROGRAMFILES&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMMONPROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)\\\\Common Files&#x27;, &#x27;COMMONPROGRAMW6432&#x27;: &#x27;C:\\\\Program Files\\\\Common Files&#x27;, &#x27;COMPUTERNAME&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;COMSPEC&#x27;: &#x27;C:\\\\Windows\\\\system32\\\\cmd.exe&#x27;, &#x27;DRIVERDATA&#x27;: &#x27;C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData&#x27;, &#x27;HOMEDRIVE&#x27;: &#x27;C:&#x27;, &#x27;HOMEPATH&#x27;: &#x27;\\\\Users\\\\Windows&#x27;, &#x27;IDEA_INITIAL_DIRECTORY&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\Desktop&#x27;, &#x27;LOCALAPPDATA&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local&#x27;, &#x27;LOGONSERVER&#x27;: &#x27;\\\\\\\\DESKTOP-0R6DJK5&#x27;, &#x27;NUMBER_OF_PROCESSORS&#x27;: &#x27;4&#x27;, &#x27;ONEDRIVE&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;ONEDRIVECONSUMER&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\OneDrive&#x27;, &#x27;OS&#x27;: &#x27;Windows_NT&#x27;, &#x27;PATH&#x27;: &#x27;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\ odejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Scripts\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Windows\\\\AppData\\\\Roaming\\ pm;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PATHEXT&#x27;: &#x27;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC&#x27;, &#x27;PROCESSOR_ARCHITECTURE&#x27;: &#x27;AMD64&#x27;, &#x27;PROCESSOR_IDENTIFIER&#x27;: &#x27;Intel64 Family 6 Model 78 Stepping 3, GenuineIntel&#x27;, &#x27;PROCESSOR_LEVEL&#x27;: &#x27;6&#x27;, &#x27;PROCESSOR_REVISION&#x27;: &#x27;4e03&#x27;, &#x27;PROGRAMDATA&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;PROGRAMFILES&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PROGRAMFILES(X86)&#x27;: &#x27;C:\\\\Program Files (x86)&#x27;, &#x27;PROGRAMW6432&#x27;: &#x27;C:\\\\Program Files&#x27;, &#x27;PSMODULEPATH&#x27;: &#x27;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules&#x27;, &#x27;PUBLIC&#x27;: &#x27;C:\\\\Users\\\\Public&#x27;, &#x27;PYCHARM&#x27;: &#x27;D:\\\\pycharm\\\\PyCharm 2023.2.3\\\\bin;&#x27;, &#x27;PYCHARM_DISPLAY_PORT&#x27;: &#x27;63342&#x27;, &#x27;PYCHARM_HOSTED&#x27;: &#x27;1&#x27;, &#x27;PYTHONIOENCODING&#x27;: &#x27;UTF-8&#x27;, &#x27;PYTHONPATH&#x27;: &#x27;D:\\\\opencv_study;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_matplotlib_backend;D:/pycharm/PyCharm 2023.2.3/plugins/python/helpers/pycharm_display&#x27;, &#x27;PYTHONUNBUFFERED&#x27;: &#x27;1&#x27;, &#x27;SESSIONNAME&#x27;: &#x27;Console&#x27;, &#x27;SYSTEMDRIVE&#x27;: &#x27;C:&#x27;, &#x27;SYSTEMROOT&#x27;: &#x27;C:\\\\Windows&#x27;, &#x27;TEMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;TMP&#x27;: &#x27;C:\\\\Users\\\\Windows\\\\AppData\\\\Local\\\\Temp&#x27;, &#x27;USERDOMAIN&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERDOMAIN_ROAMINGPROFILE&#x27;: &#x27;DESKTOP-0R6DJK5&#x27;, &#x27;USERNAME&#x27;: &#x27;Windows&#x27;, &#x27;USERPROFILE&#x27;: &#x27;C:\\\\Users\\\\Windows&#x27;, &#x27;WINDIR&#x27;: &#x27;C:\\\\Windows&#x27;&#125;)\\;D:\\opencv_study(&#x27;D:\\\\opencv_study&#x27;, &#x27;main.py&#x27;)main.pyTrueTrue1697922899.98245931697807194.7697878986Process finished with exit code 0 python文件打开新的终端，并执行文件linux 环境在写Python程序的时候遇到需要打开一个新的终端(terminal)或者说命令行窗口进行监视的情况 12345import osos.system(&quot;gnome-terminal -e &#x27;ls&#x27;&quot;) # 窗口执行后关闭os.system(&quot;gnome-terminal -e &#x27;bash -c \\&quot;ls; exec bash\\&quot;&#x27;&quot;) # 窗口执行后不关闭# 其中 &#x27;ls&#x27; 部分即为所需执行的内容。 Windows环境1234import osos.system(&quot;start powershell.exe cmd /k &#x27;dir&#x27;&quot;)# 其中 &#x27;dir&#x27; 部分即为所需执行的内容","tags":["python"]},{"title":"opencv學習","path":"/2023/10/19/opencv學習/","content":"参考资料 https://www.bilibili.com/video/BV1ET4y127vd/?spm_id_from=333.999.0.0&amp;vd_source=755a0f899976f771c7923daed9448d48 https://opencv.apachecn.org/ opencv简介是什么？计算机视觉开源软件库 numpy opencv-python的安装打开cmd输入 123pip install opencv-pythonpip install opencv-contrib-python 开梯子下载更快 测试代码 123456import cv2# 读一个图片并进行显示(图片路径需自己指定)lena=cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, lena) # 打开新窗口，窗口名为image,显示Lenacv2.waitKey(0) opencv模块其中core、highgui、imgproc是最基础的模块，该课程主要是围绕这几个模块展开的，分别介绍如下: core模块实现了最核心的数据结构及其基本运算，如绘图函数、数组操作相关函数等 highgui模块实现了视频与图像的读取、显示、存储等接口。 imgproc模块实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、闻值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。 其他 features2d模块用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。obidetect模块实现了一些目标检测的功能，经典的基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification (级联分类)和Latent SVM等。 stitching模块实现了图像拼接功能。 FLANN模块 (Fast Library for Approximate Nearest Neighbors)，包含快速近似最近搜索FLANN和聚类Clustering算法。 ml模块机器学习模块 (SVM，决策树，Boosting等等) photo模块包含图像修复和图像去噪两部分。 video模块针对视频处理，如背景分离，前景检测、对象跟踪等。 calib3d模块即Calibration (校准)3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。G-API模块包含超高效的图像处理pipeline引擎 图像的基础操作 掌握图像的读取和保存方法 能够使用OpenCV在图像上绘制几何图形 能够访问图像的像素 能够获取图像的属性，并进行通道的分离和合并0 能够实现颜色空间的变换 读取图像1cv.imread(&quot;路径&quot;) cv.IMREAD*COLOR:以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。 cv.IMREAD*GRAYSCALE: 以灰度模式加载图像 Cv.IMREAD UNCHANGED: 包括alpha通道的加载图像模式。可以使用1、0或者-1来替代上面三个标志12345678import numpy as npimport cv2#以灰度图的形式读取图像img = cv2.imread(&quot;1.png&quot;)cv2.imshow(&quot;image&quot;, img)cv2.waitKey(0) 注意:如果加载的路径有错误，不会报错，会返回一个None值 显示图像1cv.imshow(&quot;窗口名&quot;， 图片) 注意:在调用显示图像的API后，要调用cv.waitKey()&#x2F;&#x2F;等待键盘输入 给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来。waitkey(0)，永远等待另外我们也可使用matplotlib对图像进行展示。 保存图像1cv.imwrite(&quot;文件名&quot;， 图片变量) 总结： 12345678910import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt#读取图像img = cv.imread(&#x27;1.png&#x27;,1)# 利用opencv展示图像cv.imshow( &#x27; image&#x27;, img)k = cv.waitKey(0)# 3 保存图像cv.imwrite( &#x27;messigray.png&#x27;,img) course_1code123456789101112131415161718192021222324252627# 学习了基本操作，imread(), imwrite()等import cv2 as cv# 获取摄像头cap = cv.VideoCapture(0)# set the height(3) and width(4) of the windows# windows系统下，微软surface的系统摄像头，该设置失效，原因未明# 外置摄像头OKcap.set(3, 640)cap.set(4, 480)# set brightness# 但好像也没什么用cap.set(10, 0.00001)while True: success, img = cap.read() cv.imshow(&quot;camera&quot;, img) if cv.waitKey(1) == ord(&#x27;Q&#x27;) or cv.waitKey(1) == 27: # 当所有事完成，释放 VideoCapture 对象 cap.release() cv.destroyAllWindows() break 详解1234cap = cv.VideoCapture(2)VideoCapture()中参数是0，表示打开笔记本的内置摄像头，参数是视频文件路径，打开方式如下：cap = cv2.VideoCapture(“../test.avi”) 12success, img = cap.read()cap.read()按帧读取视频，ret,frame是获cap.read()方法的两个返回值。 其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就为False。frame就是每一帧的图像，是个三维矩阵。 1234waitKey（）方法本身表示等待键盘输入，参数是1，表示延时1ms切换到下一帧图像。对于视频而言；参数为0，如cv2.waitKey(0)只显示当前帧图像，相当于视频暂停；参数过大如cv2.waitKey(1000)，会因为延时过久而卡顿感觉到卡顿。c得到的是键盘输入的ASCII码，esc键对应的ASCII码是27，即当按esc键是if条件句成立 course_2code1234567891011121314151617181920212223242526272829303132333435import cv2 as cvimport numpy as npaaa = np.ones((5, 5), np.uint8)# cv.imread(&quot;路径&quot;， 参数)，参数不传，默认参数1img = cv.imread(&quot;img/1 (1).jpg&quot;)# cv2.namedWindow(‘窗口标题’,默认参数) 创建新窗口cv.namedWindow(&#x27;Local Camera&#x27;, 0)# 设置显示的窗口大小为500,500，建议大于等于摄像头分辨率cv.resizeWindow(&quot;Local Camera&quot;, 300, 300)cv.imshow(&quot;Local Camera&quot;, img)# 灰度图片imgGray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)cv.imshow(&quot;show imgGray&quot;, imgGray)# 高斯模糊imgBlur = cv.GaussianBlur(img, (7, 7), 0)cv.imshow(&quot;show imgBlur&quot;, imgBlur)# 边缘检测imgCanny = cv.Canny(img, 150, 200)cv.imshow(&quot;show imgCanny&quot;, imgCanny)# 膨胀imgDilation = cv.dilate(imgCanny, aaa, iterations=1)cv.imshow(&quot;show imgDilation&quot;, imgDilation)# 腐蚀imgErode = cv.erode(imgDilation, aaa, iterations=1)cv.imshow(&quot;show imgErode&quot;, imgErode)cv.waitKey(0) course_3学习图像像素查看，图片大小调整，图片裁剪 opencv的X,Y的位置 code12345678910111213141516171819202122232425import cv2 as cvimport numpy as npimg = cv.imread(&quot;img/1 (1).jpg&quot;)print(img.shape)print(img.shape[0])# 打印出(1526, 1080, 3)# 打印出的分别是，高，宽，BGR# 图像大小调整，参数为宽，高a = int(img.shape[1]*0.3)b = int(img.shape[0]*0.3)imgResize = cv.resize(img, (a, b))print(imgResize.shape)# 图像裁剪 高与宽imgCropped = img[0:400, 200:400]cv.imshow(&quot;LOCAL img&quot;, img)cv.imshow(&quot;LOCAL imgResize&quot;, imgResize)cv.imshow(&quot;LOCAL imgCropped&quot;, imgCropped)cv.waitKey(0) course_4 绘画12345678910111213141516171819202122import cv2 as cvimport numpy as np# 0为黑，1为白img = np.zeros((400, 400))img1 = np.zeros((400, 400, 3))imgBlue = img1.copy() # 令imgBlub = img，则会报错，img为二维数组，只有黑白imgBlue[:] = 255, 0, 0# 划线，参数1,图片，参数2，起始点,参数3，终止点，参数4，color 参数5，厚度cv.line(img1, (0, 0), (400, 250), (255, 255, 255), 1)# 画矩形，参数配置同上,参数5也可用cv.FILLED,填充cv.rectangle(img1, (0, 0), (400, 200), (255, 255, 0), 2)# 画圆cv.circle(img1, (200, 70), 30, (255, 255, 100), cv.FILLED)cv.imshow(&quot;img&quot;, img)cv.imshow(&quot;img2&quot;, img1)cv.imshow(&quot;imgBlue&quot;, imgBlue)cv.waitKey(0) course_5 透视变换12345678910111213141516import cv2 as cvimport numpy as np# 矩阵变换width, height = 250, 350img = cv.imread(&quot;img/1 (15).png&quot;)pts1 = np.float32([[108, 240], [276, 209], [150, 491], [342, 451]])pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])matrix = cv.getPerspectiveTransform(pts1, pts2) # 获得透视矩阵out_img = cv.warpPerspective(img, matrix, (width, height)) # 透视cv.imshow(&quot;local img&quot;, img)cv.imshow(&quot;out_img img&quot;, out_img)cv.waitKey(0) 解析cv2.getPerspectiveTransform()是一个OpenCV函数，用于获取透视变换矩阵。它需要两个参数，分别是源图像中待测矩形的四点坐标和目标图像中矩形的四点坐标。它返回一个3x3的变换矩阵，可以用于cv2.warpPerspective()函数进行透视变换。 1234567891011121314import cv2import numpy as np# 定义源图像中待测矩形的四点坐标pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])# 定义目标图像中矩形的四点坐标pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])# 获取透视变换矩阵M = cv2.getPerspectiveTransform(pts1, pts2)# 输出变换矩阵print(M) 输出为 123[[ 8.24482681e-01 -1.02318154e-01 -3.33674687e+01] [ 1.18180922e-01 9.43895645e-01 1.17818491e+01] [ 1.65498408e-04 -1.69338403e-04 1.00000000e+00]] warpPerspective()函数主要作用：对图像进行透视变换，就是变形cv.warpPerspective是OpenCV中的一个函数，主要用于对图像进行透视变换。它可以将原始图像中的任意四边形区域转换为目标图像中的矩形区域，从而实现图像的透视变换。该函数的语法如下： 1dst = cv.warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) 其中，参数含义如下：src：输入图像，可以是8位无符号整数、32位浮点数或16位有符号整数。M：3x3变换矩阵。dsize：输出图像的大小。dst：输出图像，与输入图像具有相同的数据类型和通道数。flags：插值方法的标志，可以是cv2.INTER_NEAREST、cv2.INTER_LINEAR、cv2.INTER_CUBIC、cv2.INTER_AREA、cv2.INTER_LANCZOS4等。borderMode：边界填充模式，可以是cv2.BORDER_CONSTANT、cv2.BORDER_REPLICATE、cv2.BORDER_REFLECT、cv2.BORDER_WRAP等.borderValue：边界填充值。","tags":["opencv"]},{"title":"linux系统学习","path":"/2023/10/10/linux系统学习/","content":"计算机硬件结构冯 诺依曼结构 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 其他主流计算机硬件结构 哈佛体系 计算机之父 冯 诺依曼图灵 计算机硬件组成输入设备输出设备存储器RAMRAM(random access memory) 即随机存储内存 速度快，容量小 掉电易失 逻辑IO ROMROM (Read-Onboy Memory) 即只读内存硬盘 容量大，速度相对较慢 长久保存 物理10 运算器、控制器网络连接 ip地址 子网掩码 默认网关 DNS ip地址IPADDRip地址 &#x3D; 网络地址+主机地址ip地址是一个4*8bit由0&#x2F;1组成的字符串（ip4协议） 子网掩码","tags":["linux"]},{"title":"arduino的系统学习","path":"/2023/09/29/arduino的系统学习/","content":"我还是决定系统学一下arduino，虽然系统学，但仍是速成，由于碰到一些事情我意识到自己还不够努力，就从arduino开始吧 arduino IDE下载 www.arduino.cc arduino uno引脚图 Arduino UNO是基于ATmega328P的Arduino开发板。它有14个数字输入&#x2F;输出引脚（其中6个可用于PWM输出）、6个模拟输入引脚，一个16 MHz的晶体振荡器，一个USB接口，一个DC接口，一个ICSP接口，一个复位按钮。它包含了微控制器所需的一切，你只用简单地把它连接到计算机的USB接口，或者使用AC-DC适配器，再或者用电池，就可以驱动它。 存储空间ATmega328 有32KB Flash存储空间（其中0.5KB被用于存储bootloader），2KB 的SRAM和1KB 的EEPROM。可以使用官方提供的EEPROM库读写EEPROM空间。 输入输出Arduino Uno有14个数字输入输出引脚，可使用 pinMode()、digitalWrite() 和 digitalRead() 控制。其中一些带有特殊功能，这些引脚如下 Serial0（RX）、1（TX），被用于接收和发送串口数据。这两个引脚通过连接到ATmega16u2来与计算机进行串口通信。 外部中断2、3，可以输入外部中断信号。中断有四种触发模式：低电平触发、电平改变触发、上升沿触发、下降沿触发。 PWM输出：3、5、6、9、10、11，可用于输出8-bit PWM波。对应函数 analogWrite() 。 SPI：10（SS）、11（MOSI）、12（MISO）、13（SCK），可用于SPI通信。可以使用官方提供的SPI库操纵。 L-LED：13。13号引脚连接了一个LED，当引脚输出高电平时打开LED，当引脚输出低电平时关闭LED。 TWI：A4（SDA）、A5（SCL）和TWI接口，可用于TWI通信，兼容I²C通信。可以使用官方提供的Wire库操纵。 点亮一个LED灯点灯大师，闪亮登场LED灯正负两端会有2v的电压差 pinMode(引脚号，状态) 设置引脚模式 输出(OUTPUT) 输入(INPUT) 输入上拉模式(INPUT_PULLUP) digitalWrite(引脚号,状态); 引脚输出状态 HIGH(高电平) LOW(低电平) 上拉电阻arduino开发板上拉电阻10K 引脚悬空引脚设置成INPUT却没有加任何电路，引脚检测状态不定（0&#x2F;1） 123456789//点亮二号引脚void setup() &#123; pinMode(2,OUTPUT);&#125;void loop() &#123; digitalWrite(2,HIGH);&#125; 串口通信digitalRead(引脚号)读取某个引脚状态，常与pinMode(引脚号,INOUT)搭配使用 Serial.begin(9600);串口初始化设置9600为常用波特率 Serial.println(打印内容);在电脑的串口监视器上输出相应内容 delay(时间)延时函数，单位为ms 12345678910void setup() &#123; pinMode(2,INPUT); Serial.begin(9600);&#125;void loop() &#123; int buttonState = digitalRead(2); Serial.println(buttonState); delay(1);&#125; 模拟输出标有~的数字引脚可输出PWM信号 analogWrite(Pin,bringtness)模拟输出，Pin,引脚号; brigngness为亮度范围0~255,输出的为Pwm信号，PWM信号的频率大约为490Hz.在Arduino UNO控制器中，5号引脚和6号引脚的PWM频率为980Hz。 呼吸灯（周期未测）12345678910111213141516void setup() &#123; Serial.begin(9600);&#125;void loop() &#123;for (int brightness = 0;brightness &lt;= 255;brightness+=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;for (int brightness = 255;brightness &gt;= 0;brightness-=5)&#123; analogWrite(9,brightness); Serial.println(brightness); delay(10);&#125;&#125; 模拟输入电位器 ananaloRead(Pin)读取范围0-5v,返回0~1023的数值，读入的最大频率为10 000次，引脚悬空状态读的数值不定 变量B &#x3D; map(变量A,A_min,A_max,B_min,B_max)将变量A等比映射到变量B 1234567891011void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; int a = map(analogRead(A0),0,1023,0,255); Serial.println(a); delay(10);&#125; 电机驱动电机种类 直流电机(DC) 交流电机(AC) 交直流两用电机(Universal) 使用arduino的引脚直接驱动直流电机简直蠢爆了，引脚输出电流不够,pwm给小了根本不动，当然，这里只是验证analogWrite是PWM信号，周期490Hz 12345678void setup() &#123; Serial.begin(9600); pinMode(9,OUTPUT);&#125;void loop() &#123; analogWrite(9,200);&#125; 舵机驱动普通舵机有3根线：GND（黑）、VCC（红）、Signal（黄），一般情况下，建议为舵机单独供电，此处实验为了图方便，用arduino为舵机供电。 12345678910111213141516171819202122232425262728293031323334353637383940/*servo类下有以下成员函数attach()//连接舵机write()//角度控制writeMicroseconds()//read()//读上一次舵机转动角度attached()//detach()//断开舵机连接*/#include &lt;Servo.h&gt; Servo myservo; //创建一个舵机控制对象 // 使用Servo类最多可以控制8个舵机int pos = 0; // 该变量用与存储舵机角度位置/*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线~~~~~~~~~~~~~~~~~~~~~~~~~~ */void setup() &#123; Serial.begin(9600); myservo.attach(9); // 该舵机由arduino第九脚控制&#125; /*~~~~~~~~~~~~~~~~~~~~~~~~~~华丽的分割线 ~~~~~~~~~~~~~~~~~~~~~~~~~~ */ void loop() &#123; myservo.write(0); // 复位 for(pos = 0; pos &lt; 180; pos += 1) // 从0度到180度运动 &#123; // 每次步进一度 myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 &#125; for(pos = 180; pos&gt;=1; pos-=1) //从180度到0度运动 &#123; myservo.write(pos); // 指定舵机转向的角度 delay(15); // 等待15ms让舵机到达指定位置 Serial.println(myservo.read()); &#125; &#125; 步进电机驱动步进电机优点 精准控制电机输出轴角度 低速运行时扭矩大 开环控制&#x2F;性价比高 步进电机的分类 单极性步进电机 5-6条引脚，相对输出扭矩低，控制简单 双极性步进电机 4条引脚，相对输出扭矩高，控制复杂 步进电机的参数 额定电流 额定电压 定位转矩 不通电 保持转矩 通电 相数 可独立通电的定子电磁线圈数步进电机详解 http://t.csdnimg.cn/TkxCb","tags":["arduino"]},{"title":"gazebo的学习与应用","path":"/2023/09/26/gazebo的学习与应用/","content":"学习目标与任务 Gazebo和环境模型设计 机器人模型设计 为模型上装备传感器与执行器 https://gazebosim.org/docs","tags":["ros"]},{"title":"基于古月居的ros入门","path":"/2023/09/21/基于古月居的ros入门/","content":"前言由于前段时间的学习总结的习惯不好，决定新开一栏用于ros基础学习。有一说一，通过和学长的进度比较，总感觉自己是个废物。 虚拟机的安装不要装机械盘，运行慢。使用VMwareubantu系统18 linux基本命令行123456789101112cdlsmvrm -rcppwdmkdirtouchshutdown -h nowrebootsudo 基本命令行12sudo apt-get update //更新源source ~/catkin_ws/devel/setup.bash //刷新环境变量 前置安装123456789//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim//ros安装wget http://fishros.com/install -O fishros &amp;&amp; . fishros ros的核心概念节点（node）与节点管理器（ros master）节点名称唯一 话题(topic)与服务(serve) 话题：单向 发布者 订阅者 消息(massage):话题的数据由.msg文件定义 服务：双向 客户端 服务端 .srv文件定义命名请求应答数据 参数(parameter)—全局共享字典适合静态，非二进制的配置参数 文件系统 功能包（package） ：含节点源码，配置文件，数据定义 功能包清单： 作者信息，许可信息，依赖选项 元功能包：组织多个同一目的的功能包 ros命令行工具123456rostopicrosservicerosnoderosparamrosmsgrossrv 小海龟123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 工具123456789rqt_graph //节点可视化rosnode //显示节点rostopic //话题 pubrosmsgrosservice //服务 callrosbag record -a -O cmd_record //话题记录 cmd_record位保存文件名，默认hom目录下rosbag play cmd_record.bag //话题复现 ros的文件结构 1234567891011121314151617181920212223242526272829303132WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 创建工作空间123456789101112131415//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_makecatkin_make install //可要可不要//设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash 问题：我需要在原有的ROS工程基础之上，新建一个ROS功能包。我直接复制了其他目录下原有的一个包，进行修改。然后问题来了：catkin_make后竟然没有反应。甚至没有检测到我新改写的cmake 解决：ros允许多个工作空间使用相同功能包，但多个工作空间source不要放在脚本里，手动敲，否则会被覆盖,在catkin_make之前source一下，之后再source一下。而且要多次执行，如下。注意要先开下roscore，py文件要给其可执行权限. 123456//将文件复制过来后，在工作空间目录下打开终端source ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bashcatkin_makesource ~/ws_space/devel/setup.bash 脚本文件的source只在新的终端开启时才运行 发布者与订阅者以海龟为例 python文件要记得给可执行权限 发布者123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher():\t# ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True)\t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)\t#设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 订阅者123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber():\t# ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True)\t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)\t# 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 消息的自定义定义msg文件在功能包的src同级目录下创建msg文件夹12345678910// 举例，该文件名为Person.msgstring nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 launch文件使用 launch 文件，可以一次性启动多个 ROS 节点launch文件自动启动ROS Master 123456789101112131415161718192021&lt;!-- 包名 节点名称 自定义节点名 --&gt;&lt;!-- 注释 --&gt;&lt;launch&gt; &lt;node pkg=&quot;helloworld&quot; type=&quot;demo_hello&quot; name=&quot;hello&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;/&gt; &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;key1&quot; /&gt; &lt;!-- 参数设置 --&gt; &lt;param name=&quot;output_feame&quot; value=&quot;odom&quot;/&gt; &lt;!-- name:参数名称，value 参数值 --&gt; &lt;rosparam= file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!-- 重映射remap --&gt; &lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt; &lt;!-- from:原名 to:映射后的名字 --&gt; &lt;!-- 嵌套include --&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 客户端与服务端客户端 rosservice call &#x2F;clear “{}” 参数的使用parameter Server 全局变量存储空间 123456789101112// 列出当前有多个参数rosparam list// 显示某个参数值rosparam get param_key// 设置某个参数值rosparam set param_key param_value//保存参数到文件rosparam dump file_name// 从文件读取参数rosparam load file_anme// 删除参数rosparam delete param_key yaml 参数文件在程序里实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-############################################################################ Copyright 2020 GuYueHome (www.guyuehome.com). ############################################################################ 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config():\t# ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True)\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;);\t# 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue)\t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() TF坐标管理系统tf功能包，默认10秒 实现机制 广播TF变换 监听TF变换12345678//安装功能包sudo apt-get install ros-melodic-turtle-tf//启动节点roslaunch turtle tfturtle tf demo.launch//turtles键盘控制节点rosrun turtlesim turtle teleop_key//保存tf tree为 pdf 至当前目录rosrun tf view frames tf工具 命令行工具rosrun tf tf_echo turtle1 turtle2 可视化工具 rosrun rviz rviz -d rospack find turtle tf &#x2F;rviz&#x2F;turtle rviz.rviz tf坐标的广播与监听单词释义quaternion 四元数radian 弧度degree 角度 常用可视化工具QT工具箱 日志输出rqt_console 计算图ret_graph 数据绘图rqt_plot 图像渲染rqt_image_view rviz gazebo 进阶 控制与仿真 gazebo + ros +ros_control","tags":["ros"]},{"title":"stc驱动TM1608","path":"/2023/09/16/stc驱动TM1608/","content":"tm1638.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef _TM1638_H#define _TM1638_H#include &lt;STC32G.H&gt;//TM1638模块引脚定义sbit DIO=P1^3; //数据线sbit CLK=P1^0; //时钟线sbit STB=P1^1; //片选线//共阴数码管显示代码unsigned char code dis[11]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x00&#125;; unsigned char while_one[8]=&#123;0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce&#125;;void TM1638_Write(unsigned char Data) //写数据函数&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; CLK=0; DIO=Data&amp;0x01; Data&gt;&gt;=1; CLK=1;\t&#125;&#125;void Write_Command(unsigned char Command) //发送命令&#123;\tSTB=0;\tTM1638_Write(Command);\tSTB=1;&#125;void Write_Data(unsigned char add,unsigned char Data) //指定地址写入数据&#123;\tSTB=0;\tTM1638_Write(0x00|add);\tTM1638_Write(Data);\tSTB=1;&#125;//TM1638初始化函数void init_TM1638(void)&#123;\tunsigned char i;\tWrite_Command(0x8F); Write_Command(0x40); //采用地址自动加1\tSTB=0; TM1638_Write(0xc0); //设置起始地址\tfor(i=0;i&lt;16;i++) //传送16个字节的数据 TM1638_Write(0x00);\tSTB=1;&#125;#endif tm1638.c 123456789101112131415161718192021#include &lt;STC32G.H&gt;#include &quot;tm1638.h&quot;void TMmain(void)&#123; unsigned char i;\tP0=0xff;P2=0x80;P2&amp;=0x1f; P0=0;P2=0xa0;P2&amp;=0x1f; //关闭单片机LED、蜂鸣器、继电器，主要是刺眼。。。 init_TM1638(); //初始化TM1638\tfor(i=0;i&lt;8;i++)\tWrite_Data(i,dis[10]); //初始化寄存器\twhile(1)\t&#123; Write_Data(while_one[0],dis[6]); //选中GRID1，令第一位数码管显示0\t&#125;&#125;","tags":["单片机"]},{"title":"stc32学习","path":"/2023/09/14/stc32学习/","content":"时隔三月，再摸单片机，这一次我要把遗忘的全部拿回来 STC32介绍 STC I&#x2F;O口工作模式 除了P3.0和P3.1（准双向口）外，其他默认高阻输入模式准双向口和推挽输出模式默认为高电平 define和typedef12typedf unsigned char u8;给已存在的数据类型起别名 WTST程序读取等待控制寄存器，上电默认为70-255 volatile设置变量，防止优化 预编译处理12345678910//主要命令有#include#ifndef //如果宏未定义则执行#define //定义宏#endif //结束有if的定义#elif#undef // 取消已定义的宏#line#program#error 模块化编程思想 移位法点亮LED 1234567while(1)&#123; for(i = 0;i &lt; 8; i++) &#123; P2 = ~(0x01 &lt;&lt; i); delayms(500); &#125;&#125; 上拉电阻和下拉电阻所有IO口都配置了一个4.1K的上拉电阻和10K的下拉电阻都是8位寄存器上拉电阻控制寄存器：PxPU上拉电阻控制寄存器：PxPD(x &#x3D;0,1,2,3,4,5,6,7) 123456789P7M1 = 0xFF;P7M0 = 0x00; //高阻输入模式EAXFR = 1; //使能XFR,特殊寄存器，设置使之能访问while(1)&#123; P7PU = 0x01; //加上拉电阻等于准双向口模式 delayms(1000); P&amp;PD = 0x00; delayms(1000);&#125; 自适应delayms()函数12345678#define MAIN_Fose = 35000000 //设置主频void delayms(int ms)&#123; int i; do&#123; i = MAIN_Fose/6000; while(i--); &#125;while(--ms);&#125; 特殊功能寄存器（SFR，XFR） 地址范围0x7E0000-0x7EFFF如需访问扩展寄存器，需先设置SFR使能寄存器CKCON 外部数据总线时钟控制寄存器CKCON &#x3D; 0x00;(上电默认为7，建议设为0) 74HC595独立按键定时器与计数器5个24位定时器&#x2F;计数器（八位预分频+16位计数）","tags":["单片机"]},{"title":"python study","path":"/2023/08/10/python-study/","content":"python规范 结尾空一行 导入库空两行 注释# 空一格 Python库的安装1pip install 库名 Python的导包方式12345678910111213# 1.import 常规导入，直接导入整个包的所有的功能函数##eg# 2.import多个导入，导入多个包的所有功能函数。##eg# 3.from … import …导入整个包的部分功能函数。##eg# 4.当然也可以通过from … import * 这个也是直接导入包的所有功能。相当于import … 重要的，在实际的应用中用得也是比较多的，我们自定义我们自己写的功能包。第一：在test_package文件夹中创建_init_.py文件，里边什么都不需要编辑。第二：在代码中把test_package的文件的路径加入到python解释器可以搜索到的路径列表中，这里就用到了python的包sys模块。下边是运行过一次的目录结构：pyc文件是py文件编译后生成的字节码文件，不需要自己创建，在你第一次成功导入包并运行成功之后会自动生成。 自定义导包 https://blog.csdn.net/weixin_45577864/article/details/121714956?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-121714956.nonecase&amp;spm=1018.2226.3001.4187","tags":["python"]},{"title":"links","path":"/2023/07/30/links/","content":"图标 介绍 网址 triority’s blog https://triority.cn/ 天鹅绒房间 https://qwqpap.xyz/ 北矿3D打印社 https://cumtb.club/"},{"title":"arduino小项目2——电压表","path":"/2023/07/30/arduino小项目2——电压表/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕，小按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V; void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; float a = Voltage_detect(); displayMenu(a);&#125; //oled屏幕显示void displayMenu(float a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); u8g2.print(&quot;Voltage, (0-5v)&quot;); // 显示电压表... u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.setCursor(20, 34); u8g2.println(a); u8g2.sendBuffer();&#125; //检测并转化为0-5vfloat Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); //读取io口模拟值 float Voltage = analogdate*5.0/1023.0; //转化 //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); //串口打印 &#125; else Serial.println(Voltage); return Voltage; //返回值&#125; 本来想弄万用表来着，emmp,放弃了,没写完，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int gear = 0; // 万用表状态 0.菜单；1.电压表；2.电流表；3.电阻表int analogMax = 1008,analogMin = 14;//理想范围0-1023;由实际情况调整；1008~4.93v,0~0V;int R_I=220; // 电流表状态，电阻为220欧姆 void setup() &#123; Serial.begin(9600); pinMode(A0, INPUT_PULLUP); // 设置引脚2为上拉输入模式 pinMode(2, INPUT_PULLUP); // 设置引脚2为上拉输入模式 u8g2.begin();&#125; void loop() &#123; double a = Voltage_detect(); switch1(); displayMenu(a); int analogdate = analogRead(A0); &#125; void switch1() &#123; int key = digitalRead(2); // 第一次判断 if (key == 0) &#123; // 延时20ms 消除按键抖动 delay(20); // 第二次判断 if (key == 0) &#123; gear++; // 状态++ if (gear &gt; 3) &#123; gear = 0; // 循环到第一个菜单状态 &#125; &#125; // 等待按键被松开 while (!digitalRead(2)) &#123; // 等待按键松开 &#125; &#125;&#125; void displayMenu(double a) &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.setCursor(0, 14); switch (gear) &#123; case 0: //u8g2.print(&quot;Menu&quot;); // 显示菜单选项... face(); break; case 1: u8g2.print(&quot;Voltage&quot;); // 显示电压表... u8g2.setCursor(20, 34); u8g2.println(a); break; case 2: u8g2.print(&quot;Current&quot;); // 显示电流表... break; case 3: u8g2.print(&quot;Resistance&quot;); // 显示电阻表... break; &#125; u8g2.sendBuffer();&#125; void face()&#123; u8g2.clearBuffer(); //清空显示屏缓存 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆，圆心坐标（56,44），半径8 u8g2.drawCircle(56,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_LEFT); //画四分之一圆 u8g2.drawCircle(72,40,8,U8G2_DRAW_LOWER_RIGHT); //画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(56,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_LEFT); //加粗画四分之一圆 u8g2.drawCircle(72,41,8,U8G2_DRAW_LOWER_RIGHT); //加粗画四分之一圆 u8g2.drawLine(40,18,20,30); //画斜线，两端点坐标分别是（40，18）（20,30） u8g2.drawLine(88,18,108,30); //画斜线 u8g2.drawLine(40,17,20,29); //加粗画斜线 u8g2.drawLine(88,17,108,29); //加粗画斜线 u8g2.sendBuffer(); //加载以上内容&#125; float Voltage_detect()&#123; //range is 0.07 to 4.91 int analogdate = analogRead(A0); float Voltage = analogdate*5.0/1023.0; //Serial.println(Voltage); if(Voltage&gt;=4.92)&#123; Serial.println(&quot;out&quot;); &#125; else Serial.println(Voltage); return Voltage;&#125;","tags":["arduino"]},{"title":"arduino小项目1——小时钟","path":"/2023/07/30/arduino小项目1——小时钟/","content":"难度系数：★使用工具，arduino uno，面包板，杜邦线，4寸0.96寸I2C小屏幕 接线图，文字描述。单片机上的A4接小屏幕上的SDA，A5接SCL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;MsTimer2.h&gt;#include &lt;U8g2lib.h&gt; U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SCL, SDA); // 配置构造函数 int year = 2020, month = 1, day = 1, hour = 0, minute = 0, second = 0; void onTimer() &#123; second++; if (second &gt;= 60) &#123; second = 0; minute++; if (minute &gt;= 60) &#123; minute = 0; hour++; if (hour &gt;= 24) &#123; hour = 0; &#125; &#125; &#125;&#125; void setup() &#123; Serial.begin(9600); u8g2.begin(); u8g2.clearBuffer(); MsTimer2::set(1000, onTimer); // 中断时间为1秒 MsTimer2::start(); // 启动定时器&#125; void loop() &#123; displayTime();&#125; void displayTime() &#123; u8g2.clearBuffer(); u8g2.setFont(u8g2_font_ncenB08_tr); u8g2.drawStr(0, 15, &quot;TIME:&quot;); u8g2.setFont(u8g2_font_ncenB12_tr); char strTemp[12]; sprintf(strTemp, &quot; %d.%.2d.%.2d&quot;, year, month, day); u8g2.drawStr(35, 15, strTemp); u8g2.setFont(u8g2_font_ncenB14_tr); sprintf(strTemp, &quot;%.2d.%.2d.%.2d&quot;, hour, minute, second); u8g2.drawStr(25, 45, strTemp); u8g2.sendBuffer();&#125;","tags":["arduino"]},{"title":"markdown基本介绍与语法","path":"/2023/07/26/markdown基本介绍与语法/","content":"markdown是什么？Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等 我为什么使用markdown写个人博客需要，且markdown使用简单，b站搜索十分钟学会，word无法完成个人博客的书写.markdown和word可相互转化,但效果不好，排版问题较大。markdown无法实现精细排版要求。 在线编译器网址https://markdown.com.cn/editor/在线转化器网址https://www.easeconvert.com/markdown-to-word/ 基本语法12345678910111213141516171819202122232425262728293031323334353637383940——————标题——————# 一级标题## 二级标题### 三级标题...###### 六级标题——————字体———————**这个是粗体***这个是斜体****这个是粗体加斜体***~~这里想用删除线~~--- 分割线——————列表———————无序列表的使用，在符号`-`后加空格使用有序列表的使用，在数字及符号`.`后加空格后输入内容——————图片———————使用符号&gt;&gt; 引用内容——————表格———————可以使用冒号来定义表格的对齐方式，如下：| 姓名 | 年龄 | 工作 || :----- | :--: | -------: || 小可爱 | 18 | 吃可爱多 || 小小勇敢 | 20 | 爬棵勇敢树 || 小小小机智 | 22 | 看一本机智书 |——————链接———————[描述](链接)——————图片———————&#123;% image 链接 %&#125;——————代码———————```语言代码块``` (占位，不管) 笔记over","tags":["markdown"]},{"title":"ros车基本学习（基于讯飞车）","path":"/2023/07/24/ros车基本学习/","content":"ros是什么（个人理解）ros是个机器人操作系统，可以在上面实现对机器人的操作，好比一个工作台，别人给你造好，直接使用上面的工具方便造自己的作品. 我为什么学ROS竞赛需要,智能车讯飞比赛及人工智能比赛甚至电赛控制类赛题也能用到 节系统是乌班图18的系统。 123456//安装C加加编译器sudo apt-get install g++//安装python解释器sudo apt-get install python//安装vim文本编译器sudo apt install vim 代码运行实例（c++） 123456789101112//终端输入，在主目录下创造一个test的文件夹。mkdir test//创建一个名为hello的点cpp文件。touch hello.cpp//在文件中写入内容//写完后保存关闭//打开终端输入,编译C加加文件g++ hello.cpp -o hello//执行可执行文件。./hello//同理。执行python文件python hello.py ros安装 1234567891011121314151617181920//添加ros软件源sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; //添加密匙sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 //安装rossudo apt updatesudo apt install ros-melodic-desktop-full //初始化rosdepsudo rosdep initrosdep update //设置环境变量echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc //安装rosinstallsudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 鱼香ros一键安装 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 小乌龟实例 123456//启动ros mastreroscore//启动小海龟仿真器rosrun turtlesim turtlesim_node//启动海龟控制节点rosrun turtlesim turtle_teleop_key 创建工作空间 1234567891011121314//创建工作空间mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace //编译工作空间cd catkin_ws/catkin_make //设置环境变量source devel/setup.bash //检查环境变量echo $ROS_PACKAGE_PATH 功能包创建与编译 12345678910//创建功能包cd ~/catkin_ws/srccatkin_create_pkg my_package_name rospy roscpp std_msgs geometry_msgs turtlesim //编译cd catkin_ws/catkin_make //刷新环境变量source ~/catkin_ws/devel/setup.bash C++编译配置&lt;cmakelists.txt&gt;12add_executable($&#123;PROJECT_NAME&#125;_node src/my_package_name_node.cpp)target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;)自定义消息1.在功能包文件夹内创建msg文件夹，并新建Person.msg文件，在里面写入 1234567string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 2.在package.xml文件内添加依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.在CMakeLists.txt内加入： 123456789 add_message_files( FILES Person.msg) generate_messages( DEPENDENCIES std_msgs)并把1# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim改为1CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime系统关机及重启 1234//关机shutdown -h now//重启sudo reboot ctrl all+T打开新的终端 摄像头参数命令1qv4l2 launch文件启动rviz每次启动rviz都要设置订阅的话题、点云大小等等机械化的设置，为了方便快捷的操作，把rviz的设置写入launch文件内，就可以一键启动了。1.先启动需要运行的节点，再启动一个rviz；2.设置好订阅的话题、点云大小、坐标轴等需要用到的设置3.点击左上角的file，选择另存为到一个指定地址(功能包文件夹下创建config文件夹，rviz配置文件放里面)；4、写入launch文件 1234&lt;launch&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find my_package)/config/path_to_your_rviz_config_file.rviz&quot; /&gt;&lt;/launch&gt; 其中 find my_package 为你的功能包名，path_to_your_rviz_config_file.rviz为rviz文件名","tags":["ros"]},{"title":"我的技术栈","path":"/2023/07/24/我的技术栈/","content":"我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32(未学) stm32(未学) 网络基础 树莓派(未学) 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的个人博客联系邮箱：&#51;&#51;&#49;&#49;&#x37;&#48;&#52;&#x35;&#x30;&#57;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d; 姓名：李无忧爱好：睡觉和吃饭以及听音乐性格：温和喜静理想：实现共产主义，追求社会公平讨厌的事：被他人意志所裹挟擅长的事：模仿与学习 为什么写博客？ 主要原因有二个方面吧，首先呢，记录学习状态。学习的时候很多代码确实很难记住，知道怎么用就好了，必要的时候翻翻个人博客就可以找到。然后吧，记录生活日常。当然这个可能比较少。 我的技术栈语言类： c++&#x2F;c (较熟练) python(基础) 软件类： ros基础 51单片机 stc32单片机 arduino单片机 linux基础 eps32(未学) stm32(未学) 网络基础 树莓派(未学) 硬件类： solidwords&#x2F;3d打印 简单的pcb板绘制 简单的电路板焊接"},{"title":"成就","path":"/achievement/index.html","content":"学科竞赛 第十七届智能车室外组ROS 省二（首座） 第十八届智能车室外组ROS 国一（首座） 第十八届智能车讯飞创意组 国一 第二十五届中国机器人及人工智能大赛 国二（首座） 2023全国大学生电子设计大赛 省三 学校奖励 2023年校级三等奖学金 学院新生辩论赛一等奖 优秀团员"}]